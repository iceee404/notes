<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:智能合约&amp;全栈Web3开发</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="-web3-">智能合约&amp;全栈Web3开发</h1>
<h2 id="-">课程学习建议</h2>
<p>因为区块链和智能合约技术发展很快,一直在更新,所以要保证自己看到的是最新的信息。</p>
<p>要回头查看一下自己的代码模板是不是最新的</p>
<p>如果你想确认你是否真正学会了,可以在下一个课程学习前,复习上节课的内容。</p>
<p>Solidity工程师不仅仅需要关注Solidity本身,擅长使用这些交流工具,从社区成员身上获得帮助,并且提供帮助,是成功的必要因素。</p>
<hr>
<h2 id="1-">1.区块链通识(已)</h2>
<h3 id="-">区块链基础</h3>
<p>区块链基础知识可以指导我们如何去架构自己的去中心化应用。</p>
<h4 id="-">智能合约简介</h4>
<blockquote>
<p>智能合约是通过去中心化的方式来执行一系列的指令,在这些指令执行中,并不需要中心化或者第三方的中介.</p>
<p><strong>区块链或者说是以太坊实现了智能合约的概念</strong>。</p>
<p>智能合约也是约定多个参与方的一系列指令。不同的是,传统的合同是通过笔写到纸上,或者通过word把内容打进去,而智能合约是代码写的,并且嵌入到一个去中心化区块链平台。智能合约就是<strong>在这个去中心化区块链平台中被执行</strong>,而不是被二个,三个或者多个参与方去执行,所以智能合约解决了中心化所带来的问题。</p>
</blockquote>
<p>技术上讲,比特币也有智能合约,但是比特币不是图灵完备的,也就是比特币不能执行一个编程语言的所有指令。</p>
<p>比特币开发者想把比特币作为价值存储,而以太坊开发者除了把以太坊看作价值存储外,还把它当成一个运行去中心化合约的平台。</p>
<h4 id="-">智能合约与链下的交互</h4>
<blockquote>
<p>如果我想用这些智能合约来代替我们日常使用的合同,那么他们就需要真实世界的数据输入,区块链自己没有办法获取真实世界的信息。这些区块链网络都是确定性系统,他们会根据预设的规则去验证。</p>
<p>智能合约能够获得发生在区块链上的所有信息,但是他们想要作为日常合同使用的话,他们需要外部的数据和外部的计算,而这些就是预言机(The Oracle)发挥的作用。预言机是可以向区块链输入数据或者进行链下计算的设备.</p>
</blockquote>
<p><img src="img/8.png" alt="8"></p>
<h4 id="-">混合智能合约</h4>
<blockquote>
<p>然而,如果我们想要我们的应用是真正去中心化的,我们不能只通过单个预言机或者单个数据提供商获得数据,也不能拿着单个资源去进行外部运算。</p>
<p>我们需要一个去中心化的预言机网络,正如去中心化区块链网络一样。你在链上的逻辑是去中心化的,你在链下的数据和计算也需要是去中心化的,将链上去中心化逻辑和链下去中心化数据和计算相结合,这个东西叫做混合型智能合约(<em>包含区块链上运行的代码以及区块链下的数据和计算资源，这些资源由去中心化预言机网络传输至链上</em>)。大多数我们现在使用的最流行的协议,都是某种类型的混合型智能合约,或者在某种程度上与混合型智能合约交互。混合智能合约会用到Chainlink。<strong>Chainlink是一个组件化,去中心化的预言机网络</strong>。Chainlink不仅可以给智能合约提供外部数据,还可以提供链下计算。Chainlink可以让混合型智能合约在链上和链下两部分都是去中心化的。它提供丰富的功能,让智能合约可以像日常合同一样使用。Chainlink可以让我们获得数据，合约自动化执行，随机数，以任何有意义的方式自定义你的智能合约。</p>
</blockquote>
<h4 id="-">区块链网络</h4>
<blockquote>
<p>混合智能合约:特指那些有链下组件的智能合约。在混合型智能合约出现以后,很多智能合约平台都对此做了支持。比如说Avalanche,Polygon,Fantom,Harmony,等等。</p>
<p>也就是说我们平时在以太坊上部署智能合约,同时在大多数其他的区块链网络也是适用的,像是Polygon,Avalanche,Fantom,Harmony等等。</p>
<p>只需要改动一行代码就可以适配其他链,非常简单。不需要担心不了解某些链上某些工具,因为他们大部分都可以互通。</p>
<p>尽管有一些智能合约平台不使用Solidity,但是学习过后也可以更好地理解和使用它们。</p>
</blockquote>
<h4 id="-">课程建议</h4>
<blockquote>
<p>区块链包括了价值存储和智能合约平台。在课程中区块链和智能合约平台指一个东西。</p>
<p>Chainlink-当下最流行和最强大的去中心化预言机网络。</p>
<p>同时Chainlink对于所有区块链都是中立的,它和以太坊,Polygon,Avalanche,Solana,Terra和很多其他的区块链都有集成。</p>
<p><strong>DApp,去中心化协议,智能合约应用,去中心化应用指的都是同一个东西。</strong></p>
<p>去中心化应用通常是由多个智能合约组成。</p>
</blockquote>
<h4 id="web-">Web阶段发展分类</h4>
<blockquote>
<p>Web3是一种观点,指的是以区块链和智能合约为基础的下一代的网络</p>
<p>Web1指的是一个有着固定内容的非许可的开源网络。</p>
<p>Web2指的是一个有着动态内容的许可网络,你的所有逻辑和协议运行在中心化的服务器上,这些中心化服务器控制着你的信息。</p>
<p>Web3中又回到了非许可网络,但是再一次承载动态内容,相比于中心化服务器，去中心化网络运行着你的逻辑，智能合约可以允许你创建无需审核的合同和逻辑，在Web3中，通常伴随着一个概念，即用户拥有他们所使用的协议，也叫拥有者经济。</p>
</blockquote>
<hr>
<h3 id="-">智能合约的作用</h3>
<p><strong>Fair Chance:公平的机会</strong></p>
<h4 id="-the-purpose-of-smart-contracts-">智能合约的作用(The purpose of Smart Contracts)?</h4>
<blockquote>
<p>智能合约创建了信任最小化协议(<strong>Trust Minimized Agreements</strong>)，智能合约创建了不可违背的承诺(<strong>Unbreakable Promises</strong>)另外,它也提升了性能，透明度和很多其他的方面。</p>
</blockquote>
<h4 id="-">区块链的目的</h4>
<blockquote>
<p>区块链的目的很简单,就是来保证承诺不被违背。生活中的几乎所有东西都是某种程度,某种形式的合同结果。</p>
<p>智能合约是不可更改(Immutable),去中心化(Decentralized)和透明(Transparent)的，这些都是区块链被开发出来的目的。        </p>
</blockquote>
<h4 id="-">智能合约到底是什么?</h4>
<blockquote>
<p>智能合约简单来说就是部署在去中心化区块链上的一个合约或者一组指令，当这个合约或者这组指令被部署以后它就不能被改变了，它会自动执行，每个人都可以看到合约中的条款，更深层次的理解是这些代码会被去中心化地执行，没有一个人或一个主体可以修改这些合约或者更改条款，特别是智能合约部署在去中心化的区块链(ETH)上,    同时结合另一个去中心化的预言机(ORACLE)网络获取真实世界的资产和信息。</p>
<p>将智能合约与Chainlink的VRF相结合，获得一个可验证的随机数，这样的智能合约不可能被攻击(Impossible to hack),不可能实施欺诈(Impossible to defraud0),不可能被操纵(Impossible to manipulate)</p>
</blockquote>
<p>UniSwap:去中心化交易所。</p>
<p>DeFi:去中心化金融。</p>
<p>智能合约是通往更好的世界的通道。</p>
<hr>
<h3 id="-">区块链其他优势</h3>
<h4 id="-">去中心化预言机网络</h4>
<blockquote>
<p>比特币是第一个把区块链技术引入大众视野的协议，它也把加密货币带到了主流世界，比特币是一种电子黄金或者说是一种价值存储，用户之间可以以去中心化的方式发送交易，其他的智能合约平台推动区块链技术更进一步，它们使人们可以开发智能合约和去中心化信任最小化合约，这些智能合约和去中心化应用可以通过一个工具和真实世界交互，这个工具被称为去中心化预言机网络。</p>
<p>Chainlink是一个去中心化预言机网络，它允许我们去开发混合型智能合约，混合型智能合约将我们的链上逻辑和链下去中心化的数据和计算结合起来，使得我们的逻辑是完全去中心化的，数据和外部计算也是完全去中心化的，让我们能够像使用传统的合同一样去使用智能合约。</p>
</blockquote>
<p>另一个开发智能合约的理由:<strong>去中心化价值存储超过传统金融。</strong></p>
<h4 id="-">优势</h4>
<blockquote>
<p>1.去中心化(Decentralized)</p>
<p>一个区块链由不同的参与者运行，这些参与者被称为<strong>节点运营者(node operators)</strong>，成千上万的节点运营着运行同一个软件，运行着智能合约，才使得区块链网络是去中心化的。</p>
<p>2.透明性和灵活性(Transparency&amp;Flexibility)</p>
<p>每个节点运营者可以看到链上发生的任何事情，没有内幕交易，任何不公平的事情人们都会看到，每个人获得的信息是一致的，并且在统一规则下协作。这并不是说没有隐私，区块链是匿名的，意味着你不需要绑定实际生活中的身份。</p>
<p>3.速度和效率(Speed&amp;Efficiency)</p>
<p>跨国交易，金融世界的清结算等都是立即发生(instantly),让人与人之间的协作更有效率。</p>
<p>4.安全性和不可更改性(Security&amp;Immutability)</p>
<p>不可更改意味着一旦智能合约被部署，它就不能被改变了，不管代码是什么样的，它就永远是这样了，这意味着更容易做到安全，它是去中心化的，想要攻击区块链，你必须控制一半以上的节点。</p>
<p>数据存储在你的以及其他所有的去中心化节点上,假如说你的节点坏了或者说成百上千的节点坏了也没关系,只要一个节点还有这个链的数据，你就是安全的。攻击一个区块链是几乎不可能的，比攻击一个中心化服务器困难多了。</p>
<p>不仅如此，区块链也让资金更加安全，只需要私钥，就可以获取自己所有的证明、信息和资产(私钥本质上就是你所有信息的密码)。</p>
<p>5.交易对手风险消除(Counterparty Risk Removal)</p>
<p>避免了交易对手风险，移除了中心化中介，移除了我们在Web2中需要信任的准入机制(当我们与其他人协作和交互时，我们的利益通常不是他们最关心的，农场主只关心韭菜的长势)。</p>
<p>6.信任最小化协议/不可违背的承诺(Trust minimized agreements)</p>
<p>我们从以品牌为基础的协议转变到了以数学为基础的协议，任何基于智能合约和去中心化混合型智能合约的操作都是基于规则的。</p>
<p>我们可以按照自己喜欢的方式来协作和交互，我们不用害怕别人会把事情搞砸，让协作变得更好。</p>
</blockquote>
<h4 id="-web2">对比Web2</h4>
<blockquote>
<p>在Web2世界中，我们一直被各种项目和协议的信息轰炸，这些信息引导我们做一些操作，然后它们从中获利。而在智能合约领域，我们可以看到所有事情，因为他们都是透明的，我们可以参与，交互，如果想拥有某种协议，那某种程度上，就可以成为协议拥有者。</p>
</blockquote>
<hr>
<h3 id="-">智能合约行业应用</h3>
<h4 id="-">智能合约落地了哪些项目,哪些行业是因为智能合约平台的存在而出现的？</h4>
<blockquote>
<p>1.<strong>DeFi</strong>(Decentralized Finance)：代表去中心化金融，它让用户可以参与到金融市场而不需要经过中心化中介(比如说中心化交易程序Robinhood，你不需要再信任Robinhood会持续给你提供服务让你接入市场),你可以直接查看智能合约从而接入市场，你在区块链上看到的一切东西都是透明的，你可以简单、安全和高效地参与很多事情。(如何开发DeFi协议并且与之交互)</p>
<p>2.<strong>DAOs</strong>:代表去中心化自治组织,DAO是完全被去中心化管理的组织,他们被区块链上的一组指令或者一个智能合约管理，这样的管理方式很有优势，参与更加容易，规则黑白分明，并且你可以直接在链上看到所有的事情，投票和治理，使用的是完全去中心化的技术，区块链能够成为我们推动治理能力进步的重要技术之一，它让治理更加的高效，公平和合理。(怎样开发一个DAO,它是怎样运作的)</p>
<p>3.<strong>NFTs</strong>:NFT代表”非同质化代币“，它在某种程度上是一种电子艺术品或者一个独一无二的资产。很多其他的组织和行业正是因为这项技术的出现(无聊猿,加密朋克等)(如何创建NFT，并且与之交互)</p>
</blockquote>
<hr>
<h3 id="-">链上的第一笔交易</h3>
<h4 id="-">交易细节</h4>
<blockquote>
<p>在区块链上发送交易之前，我们需要先设置好一个钱包，这里使用MetaMask(最流行,最好用的钱包之一)，注意记好自己的秘密恢复词(助记词)，<strong>绝对不要共享它</strong>。同一个助记词能够让我们创建多个账户，它能让我们进入自己MetaMask中所有的账户，账户的地址是我们公开的身份，但是不同的账户也有独一无二的私有身份，也就是账户的私钥。助记词可以让你进入多个账户，私钥只能让你进入这些账户中的一个。可以把私钥认为是账户的密码，它可以让你创建交易。         </p>
</blockquote>
<table>
<thead>
<tr>
<th>Concept(概念)</th>
<th>Can Access(可以进入)</th>
<th>Private or Public(保密还是公开)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mnemonic(助记词)</td>
<td>All of your accounts(你所有的账户)</td>
<td>Keep Private!(严格保密)</td>
</tr>
<tr>
<td>Private Key(私钥)</td>
<td>1 of your accounts(私钥对应的账户)</td>
<td>Keep Private!(严格保密)</td>
</tr>
<tr>
<td>Public Address(公共地址)</td>
<td>Nothing(什么都没有)</td>
<td>It&#39;s public(完全公开)</td>
</tr>
</tbody>
</table>
<h4 id="-">测试网梗概</h4>
<blockquote>
<p>网络表单:我们可以接入的所有网络。</p>
<p>以太坊主网,可以发送交易来使用真正的钱</p>
<p>测试网:用来测试我们的代码，与代码交互，看看它们是否正常运行。</p>
<p>我们将使用测试网和本地环境测试我们的代码，测试智能合约。</p>
<p>因为测试网不是商业服务，服务不会太稳定，所以要记得查看GithHub代码仓库看看目前推荐的测试网是哪一个。</p>
<p>选好后去Goerli的测试网(Goerli ether scan)</p>
<p>Goerli采用POA机制，不能通过挖矿的方式获取测试币，只能通过水龙头领取，GitHub仓库里会告诉我们哪里有最新的水龙头，以获取测试币。</p>
<p>连接到水龙头网站，这意味着让网站可以和我们的钱包交互。</p>
<p>测试网水龙头就是在测试网上获取测试币的地方。</p>
</blockquote>
<p><strong>总结</strong>:测试网是免费的，主网会有费用，部署后就被认为是上线了，测试网是不盈利的，所以不要滥用它，我们只用它来学习，不要在这些测试网上无限发送交易。</p>
<h4 id="-">交易信息</h4>
<p><img src="img/1.png" alt="1"></p>
<p>点击交易哈希就可以看到这个交易的细节，<strong>理解交易中发生了什么，是成为智能合约工程师必备的，也有助于了解整个生态</strong>。</p>
<blockquote>
<p>交易哈希是在这个区块链上这笔交易的唯一ID,这个交易哈希标识了发送了0.1以太币到我们的地址的操作</p>
<p>gas价格越高,被写到区块里的可能性越高</p>
</blockquote>
<p>唯一地址是唯一可以确认我们身份的东西。</p>
<p>区块链浏览器EtherScan，可以用它来查看不同的交易，地址和其他在区块链上发生的事情，我们可以通过EtherScan在以太坊主网上查看刚创建的地址。</p>
<h3 id="gas">Gas</h3>
<p>当你创建一个交易时,就会有一个节点,或者叫矿工(miners)和验证者(validators),某个运行区块链软件的人,他们会被支付一小部分以太坊,Polygon或者其他区块链的原生代币,这些收入会激励人们运行节点,他们的收入是由Gas使用量决定的。</p>
<p>Gas是一个计算量的单位,要使用更多的计算资源,就需要支付更多的Gas。(对于发送以太币这样简单的交易,Gas比较便宜,对于像是铸造NFT,向某个Defi存钱这种复杂的交易,因为用到更多的计算,可能就会花费更多的Gas)</p>
<p>Gas价格乘以使用的Gas数量是交易手续费。每一个区块链都有不同的方式来计算Gas费用</p>
<p><strong>Any transaction on the blockchain comes with paying gas(任何区块链上的交易,都需要支付交易手续费)</strong></p>
<p>区块链越繁忙,你要付越多的Gas,如果很多人同时在发送交易那么就没有足够的资源处理所有的交易。</p>
<p><img src="img/3.png" alt="3"></p>
<p>可能需要等待一分钟才能看到交易完成</p>
<p><strong>怎么与区块链交互,怎么与协议交互,基于这些知识就可以与以太坊和协议交互。</strong></p>
<h3 id="-">区块链运作机制(哈希,区块,签名)</h3>
<h4 id="sha256-hash-sha256-">SHA256 Hash(SHA256 哈希)</h4>
<p><strong>哈希是一个独一无二的固定长度的字符串,用来代表一段数据,它是通过将数据传入&quot;哈希函数&quot;来生成的。</strong></p>
<p>数据被SHA256哈希算法计算,然后哈希算法输出一个独一无二的哈希值。</p>
<p>这个哈希值是独一无二的,固定长度的字符串,这个字符串可以认证和代表传入的数据。</p>
<p><strong>我们几乎可以传入任意长度的数据,虽然也会有一个数据上限,但实际上几乎可以在这里输入任何长度的数据。</strong></p>
<p>哈希算法是一个函数,它可以计算一段数据,生成一个独一无二的哈希值。</p>
<p><strong>BTC使用的是SHA256哈希算法</strong></p>
<p><strong>以太坊使用的是Keccak256哈希算法</strong></p>
<p><img src="img/4.png" alt="4"></p>
<h4 id="block-">Block(区块)</h4>
<p><img src="img/5.png" alt="5"></p>
<p><strong>把块高(Block),随机数(Nonce),数据(Data)组合起来,输入到哈希算法中。</strong></p>
<p>点击挖矿后</p>
<p>Nonce改变了,哈希值现在开头有4个0</p>
<blockquote>
<p><strong>在本例当中</strong>矿工需要找到一个Nonce,找到的Nonce需要和块高 1 以及Data一起进行哈希运算,结果必须要以4个0开始,矿工要解决的问题,就是找到8和3开头的哈希值,他们唯一的解决方法就是一个一个试。</p>
</blockquote>
<p><img src="img/6.png" alt="6"></p>
<p>Nonce是答案,它是一个数字来解决这个&quot;难题&quot;。</p>
<p>这就是区块链矿工挖矿的过程,就是通过不断计算试错的过程来找到Nonce,而这个Nonce可以解决对应的&quot;难题&quot;</p>
<p><strong>挖矿是找到区块链&quot;难题&quot;的&quot;答案&quot;的过程,节点通过挖矿来获得收入,同时不同区块链要解决的&quot;难题&quot;也不同。</strong></p>
<h4 id="blockchain-">Blockchain(区块链)</h4>
<p><img src="img/7.png" alt="7"></p>
<p><strong>把块高(Block),随机数(Nonce),数据(Data),前指针(Prev)组合起来,输入到哈希算法中。</strong></p>
<blockquote>
<p>前指针hash of previous block header(Prev):指向前一个区块的指针,它会指向前一个区块的哈希值(和前一个区块的哈希值一致),Prev全是0的区块,称为创世区块,创世区块的Prev会指向一个并不存在的区块。</p>
<p>(创世区块)Genesis Block:The first block in a blockchain(区块链中的第一个区块)</p>
</blockquote>
<p>当我们谈到区块链时,会提到无法篡改,这就是它实现无法篡改的方式,因为当我们到前面的区块,去改变任何一个数据,其后面的区块链都会变得无效,因为没有一个区块里的Nonce能够生成正确的哈希值,解决难题。</p>
<p>区块链的历史数据几乎不可能被篡改,所以如果我们想要修改,那必须重新挖矿,计算量很大。</p>
<p>区块链中的区块由块高,Nonce,数据，前一个区块哈希值和本区块的哈希值组成。这个区块的<strong>唯一哈希</strong>，可以通过这些数据创建出来，由于区块链的实现方式不同，这里可能有不同的信息，但都是以这些为基础。</p>
<h4 id="distributed-blockchain-">Distributed Blockchain(分布式的区块链)</h4>
<p><img src="img/8-1668442167868-8.png" alt="8"></p>
<p>很多人提到的P2P交易,就是指这里Peer(节点)的概念</p>
<p>运行在区块链上的每一个节点,它们的权重相同。</p>
<p>区块链上的每一个节点或者是运营主体都有着相同的权力。</p>
<p>决定哪条链是正确的链的方法非常简单,就是查看最后一个区块的哈希值,通过它来确定整个区块链的信息。最后一个区块的哈希值包含了前面所有的区块的信息。</p>
<p>区块链是由节点中的大多数控制着的,它们会彼此检查和对比,哪些是诚实节点,哪些是恶意节点没有独裁者,也没有一言堂，区块链的状态,是被大多数节点决定的。<strong>Nonce是用来得到这个哈希值的数字，它还用于定义帐户/地址的交易编号。</strong></p>
<h4 id="token-">Token(代币)</h4>
<p><img src="img/9.png" alt="9"></p>
<p>把块高(Block),随机数(Nonce),交易(Tx),前指针(Prev)组合起来,输入到哈希算法中。</p>
<p>区块链实际上是通过Solidity代码运行的,而非在这里将随机值放在Data区域,Solidity代码(智能合约)定义了链上不同区块和协议交互方式,</p>
<h3 id="-signing-transactions-">签名交易(Signing Transactions)</h3>
<p>Private Key(私钥):只有密钥持有者知道,它用于签署交易。就像它名字一样,需要像密码一样保存,你会把它当成密码一样,对你所有的交易使用。</p>
<p>私钥是由随机数生成器生成的。</p>
<p>ECDSA算法:是DSA(电子签名算法)的一种,它可以根据私钥创建出公钥;ETH和BTC都使用这个算法。</p>
<p><img src="img/1-1668442179444-11.png" alt="1"></p>
<hr>
<p>仍旧是使用ECDSA签名算法去创建<strong>信息的签名</strong>。</p>
<p>这个签名算法的强大之处是,你可以使用私钥创建信息签名,但是别人不能从信息签名中得到你的私钥。</p>
<p><img src="img/2.png" alt="2"></p>
<hr>
<p>通过ECDSA和私钥创建出的公钥,任何人都可以验证这是你的签名。</p>
<p><img src="img/3-1668442185260-14.png" alt="3"></p>
<p>你的私钥用来对信息签名,公钥让别人来验证签名是你的,别人没办法伪造你的私钥。</p>
<hr>
<p>综上所述,我们可以在交易中使用签名算法,通过私钥,我可以对这个交易签名。</p>
<p><img src="img/4-1668442187799-16.png" alt="4"></p>
<hr>
<hr>
<p>世界上任何人都可以验证这个交易。</p>
<p><img src="img/5-1668442191852-18.png" alt="5"></p>
<hr>
<p>在MetaMask中,助记词加上账户序号,我们就可以获得私钥。</p>
<p>我们的以太坊地址,实际上是公钥的一部分,为了获得以太坊地址,只需要用我们私钥创建的公钥,进行以太坊上的哈希运算,然后取<strong>20个字节(在以太坊中,账户地址为160位,表示为40个16进制数,在使用时要在开头加一个0x)</strong>,这就是获得地址的方法,获取地址的具体方法不一样,因为每个区块链可能都不一样,但是我们要知道地址是怎么样获得的,它是公钥衍生出来的。</p>
<p>以上的方法创建和签名了一个可以发送的交易。</p>
<p>公钥:派生自您的私钥。任何人都可以看到它，并使用它来验证交易是否来自您,是通过对私钥使用签名算法得到的。</p>
<p>私钥(Private key) ||| -&gt;公钥(Public key)-&gt;地址(Address)</p>
<h3 id="-eip1559">区块奖励&amp;EIP1559</h3>
<p>重点理解:一个链用的人越多,发送交易就越贵。</p>
<p><strong>在Eherscan上,可以看到:总费用=(区块基础费+最大优先费)*Gas使用数量</strong></p>
<p>区块基础费:Base Fee,最大优先费:Priority Fee.</p>
<p>在MetaMusk中,我们可以设置Gas limit。</p>
<p><img src="img/6-1668442195550-20.png" alt="6"></p>
<h4 id="gas-price-">Gas Price是如何计算的？</h4>
<blockquote>
<p>根据EIP-1559协议,现在在以太坊上,每一笔交易都有Base fee,这是能够设置的最低的Gas fee,它是以Gwei计价的；这里的Max fee是指我们最多愿意为这个交易付多少Gas fee，从数值上看maxFee &gt;= baseFee + maxPriorityFee；这里的Max Priority fee是指由用户设置的每笔交易最大可支付的优先交易费用(Priority fee:小费)</p>
<p><strong>实际交易中</strong></p>
<p>basefee不用设置（钱包也不管），是以太坊通过算法，自动根据上一个block的大小和上一个basefee计算出来的。</p>
<p>为了让用户更好地控制自己的钱，实际交易中，设置的是maxfee（愿意给出的最大gasprice）和maxpriorityfee(愿意给出的最大Tip)。</p>
<p>maxfee必须要大于basefee，然后，矿工会按如下的算法收取小费：</p>
<pre><code>Tip = min(maxpriorityfee,maxfee-basefee)
</code></pre><p>如果maxfee &gt; basefee + Tip，多余的费用就会被矿工退回交易发送者。</p>
</blockquote>
<p><strong>maxFee 和 maxPriorityFee 都支持用户自行设置，baseFee 则由算法根据上一个区块的利用率自动给出</strong></p>
<p><strong>Gas Price = basefee + maxpriorityfee。</strong></p>
<h4 id="-">矿工到底拿到了多少钱？</h4>
<p><strong>目前在以太坊上,这个Base fee会被烧掉,Burnt可以看出有多少被烧掉了(Base fee×Gas的使用数量就是这里Burnt的数值)。</strong></p>
<p><strong>这意味着,每次你转账的时候,一部分以太币会永远不再流通,因为被烧掉了。</strong></p>
<p>现在在以太坊上,你交易手续费的一部分被烧掉了,另一部分直接给了矿工，交易手续费不完全由矿工收取。(也就是说这个交易当中付给矿工的以太币数量=Transaction Fee-Burnt)<strong>用户先给钱,以太坊再烧,烧完再给矿工</strong></p>
<p>也就是说基础费用在交易完后被烧掉了,<strong>矿工只拿到了小费</strong>。</p>
<p><img src="img/10.png" alt="10"></p>
<p>Txn Tyep:EIP-1559:代表这个交易的版本是EIP-1559</p>
<p><img src="img/7-1668442221045-23.png" alt="7"></p>
<p><img src="Day11;2022.10.23/8.png" alt="8"></p>
<h4 id="base-fee-">Base Fee是怎么被算法调节的？</h4>
<p>baseFee 会根据上一区块的空间利用率自动调整，如果利用率超过 50%，则提升当前区块的 baseFee；反之降低。</p>
<p>按照 baseFee 计算公式，相邻区块间的 baseFee 变化幅度在 ±12.5% 之间：</p>
<ul>
<li>如果上一区块空间利用率为 100%，则当前区块 baseFee 将自动提升 12.5%</li>
<li>如果上一区块空间利用率为 0%，则当前区块 baseFee 将自动降低 12.5%</li>
</ul>
<h4 id="-">总结</h4>
<blockquote>
<p>每个区块链都有不同的手续费燃烧和Gas机制设置,它们都不尽相同,但总结起来。在区块链中,区块能存储交易的空间有限,为了让你的交易被写在某个区块中,你需要支付手续费,这个手续费会根据需求变化,以太坊的Base Gas费用会上下调节,调节依据是有多少人正在发送交易(想把交易写入这个区块中),如果有很多人想将交易写入区块,那就有大量的Gas被烧掉。</p>
</blockquote>
<blockquote>
<p>总的来说,以太坊的这个交易费=(基础汽油单价+汽油单价小费)*汽油的升数。</p>
<p>Base Fee是基础汽油单价，Max Priorivy是汽油单价小费，这俩加起来算出来的才是Gas Price(每个汽油的的单位价格)</p>
<p>然后再乘以Usage by Txn(实际上在交易当中使用的Gas数量也就是汽油升数),这样算出来的才叫做交易费。</p>
<p>注意一点：上面说的maxfee、basefee、Tip，都是针对per gas的，计算真正费用的时候，还需要乘上gas数。</p>
<p>你在不同场合看到的这些符号，有些是带per gas的，有些不带，注意要区分一下，一般指的都是带per gas的。</p>
</blockquote>
<h4 id="eip1559-">EIP1559详谈</h4>
<p>EIP：即以太坊发展提案，是请求更改以太坊网络的常见方式(源于比特币的发展提案:bip),eip是一份涵盖技术规范和协议变更的设计文件，在其背后所运作的大多数eip专注于改进以太坊的技术细节。</p>
<p>在以太坊核心开发者社区之外，eip并没有被广泛讨论，但是EIP1559是例外，该提案对于ETH货币政策有重大影响，比如一些客户端钱包，EIP1559提出了以太坊费用模型的更改。</p>
<p>为什么需要这个提案呢？</p>
<p>以太坊<strong>之前</strong>的费用模型是基于简单的拍卖机制/最高价拍卖，用户如果想让矿工处理他们的交易，必须出价购买区块内的空间，这是通过他们愿意为交易所支付的Gas来实现的，进而按最高Gas对交易进行排序，激励矿工处理交易，并且最有利润的交易优先，这将非常低效，这导致用户会在交易中支付过多的Gas。这个模型问题还在于对于钱包Metamask，用户手动指定Gas费用在慢，中，快的交易速度中选择，没有经验的用户经常在Gas费用飙升之前提交了默认费用的交易，最终可能会等待交易确认很长一段时间，这对于用户体验是很不理想的。</p>
<p><strong>上述的问题也是EIP-1559的用处所在，这个提案正用于解决以上问题，并旨在达成如下目标</strong></p>
<ul>
<li>使交易费用可预测性更高</li>
<li>减少交易确认的延迟</li>
<li>通过自动化竞标系统提升用户体验</li>
<li>在网络活动和ETH支持中提供正循环</li>
</ul>
<p>提案改变的是什么?</p>
<p>EIP1559在基础费用中引入了一个新概念BaseFee，BaseFee就是交易进入区块的最小支付费用，BaseFee是按区块设置，并且按照链上的拥挤程度来调整费用的高低，EIP1559的第二个重要特性是它可以在每个区块通过改变最大Gas限制从而提升网络性能(例如使12.5million的Gas限制提升到25million),大体上让区块大小翻倍。</p>
<p>基于BaseFee和提升的区块性能，EIP1559在如下逻辑运作:当网络利用率超过50%,BaseFee就会增加,当网络利用率低于50%,BaseFee就会减少,这大体意味着依照网络利用情况旨在通过调成费用达成50容量的平衡。</p>
<p>EIP1559还引入了一种小额小费，它可以直接支付给矿工以激励他们优先处理交易，这与之前的机制是非常相似的(指eip-1559前)，矿工可以被更高的gas所奖励，这一特点对于交易是非常重要的，对于快速确认交易是非常有优势的，比如套利交易，让我们举一个简单的例子：当网络占用过高时，比起之前的收费模型，eip-1559模型是如何发挥优势的？</p>
<p>之前链上最低的gas是50gwei，目前的网络状况如果保持不变，用户提交50gwei以进行交易从而能够上链。与此同时一个备受期待的代币被推出了，导致想要购买它的用户，争先恐后的提高他们的竞价，从而能够在下一区块交易，而最小的交易费用是100gwei，如果网络状况一直如此，多个后续的区块一直保持高占用的情况，那些已经支付50gwei的用户的交易想要被确认，将等待非常久的时间；在这一状况下,区块规模上限为12.5M gas，此时进入区块的方式是比其他用户提出更高的价格</p>
<p>让我们使用EIP1559来应对上述情况, 在第一个区块50 gwei 是BASEFEE，网络利用率只有50%， 大多数区块使用12.5M的gas，是最大gas限制的一半，新代币发布产生的网络高占用导致用户使用更高的矿工小费，鉴于对区块空间的高需求以及许多含有矿工小费的交易，矿工们就会生产一个25M gas的大区块，这能够让更多的交易被包含在区块里，与此同时BASEFEE会在接下来的区块攀升，而<strong>当前区块</strong>是被填满的，如果接下来的网络活动对区块空间的需求依然很高矿工们就会继续生产完整的区块(25Mgas的区块)，并且在后来的区块增加BASEFEE，在某个节点的费用足够高后就会赶走一些用户，而网络利用率就会回到50%利用的水平并且在随后的区块降低费用，每个区块费用最多可以增加或减少12.5%，因此在五分钟内,gas价格达到10倍需要20个区块，达到100倍需要40个区块，这个例子论证了eip1559的实施使得在网络高峰期交易费用可以被熨平；</p>
<p>也就是说可以认为EIP1559模型是在用区块的波动性换取价格的波动性，由于价格的增量和减量受到约束，BASEFEE在不同区块可以被轻松计算，这允许钱包基于目前区块的信息自动化设置BASEFEE。同时为了避免矿工为了自身利益出现联合抬高BASEFEE的情况<strong>因此所有BASEFEE会被烧掉</strong>，所有的矿工小费归于矿工所有，一个更重要的新概念被称为费用上限,用户可以这么做，他们可以限制他们愿意为交易所支付的最大gas而不仅仅支付目前最大的BASEFEE。</p>
<p>使用了eip1559的钱包需要进行更改，钱包不需要再估算gas费用，它们可以根据先前区块信息自动化设置BASEFEE，这将简化钱包用户的界面。</p>
<p>对于eth的支持，BASEFEE的焚烧也发挥着重要作用，被焚烧的gas造成了一个有趣的反馈回路，过高的网络活动,即更多的eth被焚烧,即矿工持有的eth在市场上会越来越少，使得现存的eth会越来越有价值，焚烧的BASEFEE大体上奖励了网络中的用户，使得他们的eth更加稀有。</p>
<h3 id="-">区块链概念性知识</h3>
<h4 id="-">区块链和去中心化</h4>
<p>区块链是被多个节点运行(运行在一个网络上,这个网络是被多个独立节点运行的),传统应用是被一个中心化机构运营的(尽管可能有多个不同的服务器,但是所有的服务器都是被同个中心化集团所控制)。</p>
<p>每个人都可以加入和参与网络,这就是真正的去中心化。</p>
<p>区块链具有弹性,如果一个节点或者一个运行了多个节点的主体关闭了,并不会出什么事,因为还有很多别人运行的节点,只要有一个节点在运行,整个区块链就会运行下去。</p>
<p>每一个节点都保存着链上发生的所有交易记录,如果节点作恶,所有的哈希值就会出现问题,与别人不匹配,别人就不会在它后面接上新的区块，这让区块链有了不可篡改的属性,任何数据都不能被篡改。</p>
<p>实际上,我们可以把区块链当成一个去中心化数据库,而以太坊还有一个特性,就是可以通过去中心化的方式做一些运算。</p>
<h4 id="-">攻击</h4>
<h5 id="sybil-attack-">Sybil Attack(女巫攻击)</h5>
<p>在攻击中,用户会创建很多匿名帐户,来影响区块链,在比特币和以太坊中,这个攻击非常困难,因为用户在工作量证明中需要很多计算量,在权益证明中有很多质押物。</p>
<h5 id="51-attack-51-">51% Attack(51% 攻击)</h5>
<p>作为共识协议的一部分,最长的链会被选择为正确的链,同时要满足和网络的51%相一致,这意味着你有最长的链和51%的网络,那么就可以分叉区块链,让整个网络使用你的链。</p>
<p><strong>总结:</strong>一个区块链越大,去中心化程度越高,越安全。</p>
<h4 id="-consensus-">共识(Consensus)</h4>
<p>共识的定义是一个机制,通过这个机制,区块链可以在状态和数值上达成一致。</p>
<p>在比特币和以太坊1.0中,它们用的共识叫中本聪共识(Nakamoto Consensus)</p>
<p><strong>中本聪公式包括了工作量证明和最长链法则</strong></p>
<p><strong>1.Sybil Resistance(抗女巫攻击机制)</strong></p>
<p>抗女巫机制是指一种区块链的能力,来防止用户使用大量的假身份,在整个系统中来获取超出应有比例的权益和影响力。</p>
<p><strong>2.Chain Selection(链的选择算法)</strong></p>
<p>我们怎样确定哪个区块链是正确的链？</p>
<p>去中心化网络规定,哪条链最长,有最多的区块,就用哪条链,因为一个链落后的区块越多,就需要越多的计算量来赶上其他链。</p>
<p>确认区块(Block Confirmations)的数量是,在我们的交易写入区块后,新挖出的区块数量。如果看到确认区块是2,就表示在最长的链中,我们交易后面有两个区块。</p>
<h5 id="-pow-">工作量证明(POW)</h5>
<p>工作量证明算法是一种抗女巫机制,因为它定义一种方法,来找到是谁挖出了区块,哪一个节点,才是做了运算,然后挖出区块的节点,别的所有节点都可以准确验证它。</p>
<p>不管一个用户有多少个账户,每个账户都需要经过这个需要大量计算量的过程,来找到工作量证明中&quot;难题&quot;的答案</p>
<p>工作量证明是共识协议的一部分。</p>
<p>交易手续费在工作量证明中是<strong>矿工</strong>得到的。</p>
<p><strong>缺点:</strong>工作量证明消耗了很多电力</p>
<h5 id="-pos-">权益证明(POS)</h5>
<p>交易手续费在权益证明中是<strong>验证者</strong>得到的。</p>
<p>这也是一个抗女巫攻击机制,与解决&quot;难题&quot;的方式不同,权益证明需要放置一些抵押物以保证不作恶,也叫做质押(stake通常也翻译为质押)</p>
<p>这里的矿工被称作验证者,因为他们不再挖矿了,他们只验证其他节点,在权益证明中,节点会被直接选举出来,然后提出一个区块,别的节点会验证这个被提出的区块是否有效(去检查一个提议或交易是否有效是非常简单的),故获得新的区块所需的计算量大大降低(绿色环保),不同于工作量证明中所有节点都去竞争记账权,权益证明中只需要一个节点来做,其他节点只需要验证。</p>
<p>区块链是一个确定性系统,无法产生随机数,那么我们怎么在系统中选取随机验证者呢?</p>
<blockquote>
<p>每个区块链选择节点的方式都不同,但是以太坊2.0使用了RANDAO</p>
<p>RANDO是一个去中心化自治组织,他们共同选择随机数,共同选择下一个生成随机数的节点。</p>
</blockquote>
<p><strong>缺点:</strong>权益证明的网络,被认为有一些不够去中心化,因为有质押的花费,这是参与权益证明的花费</p>
<h4 id="-scalability-">可扩展性(Scalability)</h4>
<p>因为区块的存储空间有限,节点存储的交易也有限,所以当很多人想要使用区块链的时候,gas price就会暴涨,这样的话扩展性就不足,因为我们想要让更多的人进入区块链,这就会导致使用区块链的花费越来越高,因为人们想要将交易写入区块,这就意味着,使用系统的用户有一个上限,当Gas Price持续上涨的时候,经济上就会出现限制。</p>
<p>ETH2.0将工作量证明变成权益证明,除了因为环保原因以外,还使用了一个新的方法论,名字叫分片(Sharding),分片就是可扩展性问题的一种解决方案。</p>
<p>区块链的分片是指多个区块链的区块链,有一些主链会协调一些不同的链,将他们连接在一起,这意味着,人们可以在多个链上发动交易,有效地提高了区块数量存在的空间,分片可以极大的增加在<strong>layer1</strong>上发送的交易数量。</p>
<p><strong>Layer1:区块链实现的基础层。</strong></p>
<p>BTC,ETH都是Layer1,这些是区块链基础层的解决方案。</p>
<p><strong>Layer2:加载Layer1和区块链上的任何应用。</strong></p>
<p>比如Chainlink就是layer2；Arbitrum和Optimism作为Layer2,也是要解决扩展性问题,它们两个也是汇总(Rollups),把自己的交易集中起来,然后写入ETH这样的layer1中，这种Rollups有点像一个分片的链,它继承了以太坊这样的基础链也就是layer1的安全性,它们解决了一些扩展性问题,解决方式是作为一条链,人们在它上面发送交易就相当于在以太坊上发送交易。</p>
<p><strong>Layer2和侧链不同,侧链的安全性来自于自身协议,而Layer2的安全性来自于基础层,例如Arbitrum和Optimism跟以太坊一样是安全的。</strong></p>
<p>侧链(sidechains):遵守侧链协议的所有区块链。侧链协议是一种实现双向锚定(Two-way Peg)的协议，通过侧链协议实现<strong>资产在主链 和其它链之间</strong>互相转换，或是以独立的、隔离系统的形式，降低核心区块链上发生交易 的次数。</p>
<h4 id="-">回顾</h4>
<p>BTC是工作量证明,使用的是中本聪共识,ETH是权益证明和分片。</p>
<p>工作量证明和权益证明杜绝了女巫攻击。</p>
<p>区块链越大,51%攻击越困难。</p>
<p>共识是区块链确定当前状态的机制</p>
<p>分片和Rollup是Layer1的可扩展性问题的解决方案。</p>
<p>Layer1是基础层的实现,像是比特币和以太坊。</p>
<p>可扩展性问题,是因为区块空间不足导致写入的交易有限,这会导致很高的Gas Price</p>
<h2 id="2-solidity-">2.Solidity基础(已)</h2>
<p>Solidity是一门面向合约的，为实现智能合约而创建的高级编程语言，在EVM虚拟机上运行，语法整体类似于JavaScript，是目前最流行的智能合约语言，也是入门区块链与Web3所必须掌握的语言。</p>
<p>Solidity智能合约的开发往往无法直接通过一个IDE或本地环境进行方便的调试，而是需要与一个链上节点进行交互。</p>
<p><img src="img/1-1668442450160-25.png" alt="1"></p>
<h3 id="remix-">Remix介绍</h3>
<p>Welcome to Remix.</p>
<p><img src="img/image-20221121164135278.png" alt="image-20221121164135278"></p>
<h3 id="-">第一个智能合约</h3>
<p>Solidity是一个更新频率很高的语言,和别的语言相比,它总会有新版本,我们需要告诉代码,要用哪个版本,我们通过&quot;pragma solidity&quot;加上要用的版本号,来约定版本号。记得在我们开发的时候,根据我们的需求加上注释。在代码中留下注释,这样在回顾的时候可以最快了解当时的想法。</p>
<pre><code class="lang-solidity">//这样写表示只使用0.8.7这个版本
pragma solidity 0.8.7;//最新版0.8.17,0.8.7被认为是一个稳定的版本


//这样写也可以使用比0.8.7更新的版本
//&lt;- This means that this section is a comment!
pragma solidity ^0.8.7;//这样表示任何比0.8.7更新的版本都适用这段代码

//这样写可以使用某个范围内的版本
pragma solidity &gt;=0.8.7 &lt;0.9.0;//这样表示版本大于等于0.8.7,但是要小于0.9.0
</code></pre>
<p>在代码的最上方,我们可以加入SPDX-License-Identifier,尽管这个是可选的,但是没有的话,有些编译器会出现警告,这段代码会定义license(软件许可证)和代码分享规则。<strong>添加一个SPDX许可证标识符。</strong></p>
<p>软件许可是创建和提供应用程序、基础源代码或相关产品的实体与其最终用户之间的合同。该许可证是一个文本文档，旨在保护软件开发人员的知识产权，并限制因使用该许可证而可能产生的针对他们的任何索赔。</p>
<p>软件许可证还为软件的分发和使用提供了具有法律约束力的定义。最终用户的权利，如安装、保证和责任，也经常在软件许可中明确说明，包括对开发者知识产权的保护。</p>
<pre><code class="lang-solidity">//SPDX-License-Identifier:MIT//MIT是限制最少的License之一,我们会在大多数的代码中使用MIT协议
</code></pre>
<p>接着输入”contract“,开始定义智能合约,这会告诉Solidity,接下来的会是智能合约。可以把它看作Java里面类似&quot;class&quot;的关键字。</p>
<pre><code class="lang-solidity">//SPDX-License-Identifier:MIT
pragma solidity ^0.8.8;

contract SimpleStorage {

}
</code></pre>
<h3 id="solidity-">Solidity基础数据类型</h3>
<blockquote>
<p>bytes:byte[]的缩写，分为固定大小数组和可变数组，通过byte1 a = 0xb5;来定义</p>
<p>变量通常是&quot;0x&quot;开头然后有一些随机的数字和字母</p>
<p>bytes32是最大的(32byte是bytes型变量被允许的分配的最多空间)。</p>
</blockquote>
<blockquote>
<p>boolean:布尔类型有true和false两种类型，可以通过bool public boo = true;来定义，默认值为false。</p>
</blockquote>
<blockquote>
<p>uint:定义无符号整数,表示这个数字只能是正数,uint比较特殊,我们可以决定给它分配的空间(其实就是有多少存储分配给了这个数字)</p>
<p>可以指定uint8，uint16，uint256，默认为uint256，通过uint8 public u8 = 1;来定义，默认值为0。</p>
<p>bits(位)和bytes(字节)是衡量计算机数据的单位,它是最小的数据形式,它基本上就像一个开关,它可以是0或1。16位=2个字节</p>
<p>uint8,就是分配了8个bit;这个数字可以一直分配到uint256,如果你不知道被赋值的数字多大,默认就是uint256,最小设置uint8(因为8bit是一个byte,我们按照byte为单位步长来增加空间)</p>
<p><strong>通常把分配空间显式的写出来是一个好习惯。</strong></p>
</blockquote>
<blockquote>
<p>int:整数类型，可以指定int8到int256，默认为int256，通过int public int = 0;来定义，默认值为0，还可以通过type(int).min和type(int).max来查看类型最小和最大值。</p>
</blockquote>
<blockquote>
<p>address:地址类型，可以通过address public addr = 0xCA35b7d915458EF540aDe2F44E8fa733c;来定义，默认值为0x000000000000000000。</p>
<p>表示地址,就像在MetaMask中看到的一样</p>
</blockquote>
<blockquote>
<p>string:代表一个词,可以通过双引号表达它们,它可以是一个词,一个短语或者任何其他组合。</p>
<p>string其实是一种bytes,但是只能存储文本</p>
</blockquote>
<blockquote>
<p>Enum是枚举类型，可以通过以下语法来定义</p>
<pre><code class="lang-solidity">enum Status {
    UnKnown,
    Start,
    End,
    Pause
}
</code></pre>
<p>并通过以下语法来进行更新与初始化</p>
<pre><code class="lang-solidity">//实例化枚举类型
Status public status;

//更新枚举值
function pause() {
    status = Status.Pause;
}

//初始化枚举值
function reset() public{
    delete status;
}
</code></pre>
</blockquote>
<pre><code class="lang-solidity">//SPDX-License-Identifier:MIT
pragma solidity ^0.8.8;

contract SimpleStorage {
    bool hasFavoriteNumber = true;
    uint256 favoriteNumber = 5;
    string favoriteNumberInText = &quot;Five&quot;;
    int256 favoriteInt = -5;
    address myAddress = 0x3563c97491114E4F87389446E7f48d77c9220789;
    bytes32 favoriteBytes = &quot;cat&quot;;//cat是一个string,但是可以自动转化为bytes
}
</code></pre>
<p><strong>在Solidity中,如果我不给变量赋值,它会有一个默认值</strong>,默认值是null的值,在Solidity中是0,所以声明一个uint256变量但不赋值,就相当于声明变量然后赋值为0,因为它初始化的时候就是0.</p>
<p>我们通过这些基础数据类型定义不同的变量,变量是用来存储不同的数值的</p>
<h3 id="solidity-">Solidity基础函数</h3>
<p>&quot;函数&quot;或者&quot;方法&quot;指的是独立模块,在我们调用的时候会执行某些指令,Solidity的函数性质和Java一样,函数通过&quot;function&quot;关键字表示。</p>
<p>为了查看一个函数的实际运行结果,我们需要把合约部署在一个测试环境上,把它部署在本地网络,或者叫javascript VM(现在称其为Remix VM),在部署之前,我们需要看看它有没有正确编译。</p>
<p>Remix VM表示合约将被部署到本地的Remix虚拟机上,Remix VM是本地测试用的区块链,在上面可以快速模拟交易,不需要等待测试网的流程。</p>
<p>运行Remix VM的时候,我们有很多账户可以部署,每个账户中都有100个以太币,这些账户和Metamask中的账户类似,区别是,这些是在Remix VM中的测试以太币。</p>
<p>在部署合约的交易中,可以设置Gas limit,同时可以选择要部署的合约。</p>
<p><img src="img/12.png" alt="12"></p>
<p>在测试环境中,合约也有一个地址,每个合约都有一个地址,就像每个钱包账户都有地址一样。</p>
<p>合约的地址在Remix里面是大写字母,怎么复制后就变小写了？</p>
<p><img src="img/13.png" alt="13"></p>
<p>部署一个合约其实就是发送一个交易(任何时候你改变链上的任何东西，包括制定一个新的合约，它都会发生在一个交易中)，部署一个合约就修改了区块链,让链上拥有这个合约。</p>
<p><img src="img/14.png" alt="14"></p>
<p>参数的访问级别如果没有特别指定的话默认是internal.</p>
<p>将参数的访问级别设置为public后的合约:</p>
<p>favoriteNumbre按钮,类似一个函数,显示变量的值。</p>
<p>这些按钮都是被因代码语句而被Solidity自动赋予的视图功能。</p>
<p><img src="img/15.png" alt="15"></p>
<p><img src="img/19.png" alt="19"></p>
<p><strong>权限声明:</strong></p>
<p>函数分为不同的可见性，用户使用不同的关键字进行声明:</p>
<blockquote>
<p>public:在外部和内部都可见,任何与合约交互的人,都可以看到favoriteNumber中存的值(public会创建storage(存储)和state(状态)变量的getter函数)给favoriteNumber加上public,实际上就是给favoriteNumber创建了getter函数,我们其实创建了一个函数,返回favoriteNumber的值,上图中的蓝色按钮就是一个返回favoriteNumber值的函数。</p>
<p>带有public的变量favoriteNumber,可以看作是一个返回uint256的view函数</p>
</blockquote>
<blockquote>
<p>private:表示只有这个合约可以调用这个函数。private表示这个合约是唯一可以调用favoriteNumber函数的合约。private表示只对合约内部可见。</p>
</blockquote>
<blockquote>
<p>external:表示只对合约外部可见,表示合约外的账户可以调用这个函数。</p>
</blockquote>
<blockquote>
<p>internal:表示只有这个合约或者继承它的合约可以调用。</p>
</blockquote>
<p>智能合约的函数越复杂,消耗的计算量就越多,我们花掉的Gas费就越多(The more &quot;stuff&quot; in your function the more gas it costs)</p>
<p>查询数据的合约函数也有不同的声明方式:</p>
<ul>
<li>view可以读取变量，但不能修改</li>
<li>pure不可以读也不可以修改</li>
</ul>
<p>Scope(作用域)</p>
<p>favoriteNumber是在Global scope(全局作用域)中,表示所有在花括号中的任何函数都可以获取它。</p>
<p>当你创建一个变量的时候,它只有在这个作用域(花括号)才可见</p>
<p>因为something函数不在store函数中,所以something函数无法获取testVar变量。</p>
<p>这就是作用域的原理,看变量是否在这个花括号中被创建,然后判断是否可以被别的函数获取</p>
<p><img src="img/16.png" alt="16"></p>
<p>标识函数的调用不需要消耗Gas,Solidity中有两个可以把普通函数转换为标识函数的关键字,这两个关键字是view和pure</p>
<p>如果一个函数是view函数,意味着我们只会读取这个合约的状态</p>
<p>例如:retrive函数只读取favoriteNumber的值</p>
<p>view函数和pure函数不允许修改任何状态,但是pure函数也不允许读取区块链数据(所以我们也不能读取favoriteNumber的值)</p>
<p><img src="img/17.png" alt="17"></p>
<p>通过pure函数,你想做的事情可能是这样的,在pure函数中,返回1+1的结果(类似于这样的东西,可能是常用的方法,或者某个不需要读取数据的算法)。</p>
<p><img src="img/18.png" alt="18"></p>
<p><strong>为什么我们调用view或者pure函数,是不需要支付Gas的？</strong></p>
<p>因为只是读区块链数据,记住,只有更改状态的时候才支付Gas。</p>
<p><strong>但是如果一个要改变区块链状态的函数调用了类似retrive这种view或者pure函数才会消耗Gas</strong></p>
<p><strong>假设:store不是view函数,它在某处调用了retrive,那它就要支付retrive的Gas。</strong></p>
<p>关键字returns表示,我们调用函数后会得到什么类型的数据。</p>
<h3 id="-">数组和结构体</h3>
<p>数组是一种存储同类元素的有序集合，通过uint[] public arr;来进行定义，在定义时可以预先指定数组大小，如uint[10] public myFixedSizeArr;。</p>
<p>需要注意的是，我们可以在内存中创建数组，但是必须固定大小，如uint[] memory a = new uint<a href="5"></a></p>
<p>数组类型有一些基本操作方法，如下:</p>
<blockquote>
<pre><code class="lang-solidity">//定义数组类型
uint[7] public arr;

//添加数据
arr.push(7);

//删除最后一个数据
arr.pop();

//删除某个索引值数据
delete arr[1];

//获取数组长度
uint len = arr.length;
</code></pre>
</blockquote>
<p>示例:</p>
<pre><code class="lang-solidity">//SPDX-License-Identifier:MIT
pragma solidity ^0.8.8;

contract SimpleStorage {

    uint256 public favoriteNumber;


    function store(uint256 _favoriteNumber) public {
        favoriteNumber = _favoriteNumber;
        uint256 testVar = 5;
    }

    //创建一个函数来返回favoriteNumber,模拟被自动创建的getter函数
    //view,pure
    function retrieve() public view returns(uint256){
        return favoriteNumber;
    }

    function add() public pure returns(uint256){
        return(1+1);
    }

}
</code></pre>
<p>之前我们的合约允许我们存储一个喜欢的号码,但是如果我们想存储一系列最喜欢的数字,或者我们想存储一大群不同的人,每个人都有不同的所喜欢的数字,该如何去存储呢?</p>
<p>方法引入:</p>
<p><img src="img/20.png" alt="20"></p>
<p><img src="img/21.png" alt="21"></p>
<p>每当你有一个变量列表在一个对象内部时,在Solidity中,它们会自动编入索引。</p>
<p>创建列表的更好方法是使用结构类型,称为Struct,Struct是一种存储列表或一系列对象的方式</p>
<p><strong>Struct</strong></p>
<p>struct是结构类型，对于复杂业务，我们经常需要定义自己的结构，将关联的数据组合起来，可以在合约内进行定义。</p>
<p>各类操作:</p>
<pre><code class="lang-solidity">contract Struct {
    struct Data {
        string id;
        string hash;
    }

    Data public data;

    //添加数据
    function create(string calldata _id) public {
        data = Data{id: _id, hash:&quot;111222&quot;};
    }

    //更新数据
    function updata(string _id) public {
        //查询数据
        string id = data.id;

        //更新
        data.hash = &quot;222333&quot;
    }
}
</code></pre>
<p>也可以分离出一个文件定义所有需要的结构类型，由合约按需导入</p>
<pre><code class="lang-solidity">// &#39;StructDeclaration.sol&#39;
struct Data {
        string id;
        string hash;
}
</code></pre>
<pre><code class="lang-solidity">// &#39;Struct.sol&#39;

import &quot;./StructDeclaration.sol&quot;
contract Struct {
        Data public data;
}
</code></pre>
<p>示例代码：</p>
<pre><code class="lang-solidity">    //创建一种新的类型
    //有点像uint256/boolean/string
    struct People {
        uint256 favoriteNumber;
        string name;
    }

    // uint256[] public favoriteNumberList;
    //People[3] public people;//静态数组(指定数组大小,该数组中只能放下三个人)
    People[] public people;//动态数组(数组的大小没有给出,我们不给它一个尺寸,这意味着它可以是任何尺寸,并且数组的大小可以随着我们加减人而增长和缩小)
    //0: 2,Patrick | 1: 7,Jon | 

    function addPerson(string memory _name, uint256 _favoriteNumber) public{
        People memory newPerson = People({favoriteNumber: _favoriteNumber, name: _name});
        people.push(newPerson);
        //上面那两句的效果相当于下面这一句
       //people.push(People(_favoriteNumber, _name));
    }
</code></pre>
<p><img src="img/22.png" alt="22"></p>
<p><img src="img/23.png" alt="23"></p>
<h3 id="-">错误和警告</h3>
<p><strong>错误(红色)</strong></p>
<p>预期得到&quot;;&quot;但是实际得到了&quot;}&quot;意味着你的代码没有编译。<strong>这些错误意味着你的代码没有编译,它不像预期的那样工作</strong></p>
<p><img src="img/24.png" alt="24"></p>
<p><strong>警告(黄色)</strong></p>
<p>警告不会阻止您的代码工作，但检查它们通常是个好主意，因为它们通常会给出很有见地的信息。</p>
<p>SPDX 许可证未提供标识符</p>
<p><img src="img/25.png" alt="25"></p>
<h3 id="-immutable">变量/常量/Immutable</h3>
<p>变量是Solidity中可改变值的一种数据结构，分为以下三种:</p>
<ul>
<li>local变量</li>
<li>state变量</li>
<li>global变量</li>
</ul>
<p>其中，local变量定义在函数中，而不会存储在链上，如string var = &quot;Hello&quot;;</p>
<p>state变量在函数之外定义，会存储在链上，通过string public var;定义变量，写入值时会发送交易，而读取值则不会;</p>
<p>global变量则是提供了链信息的全局变量，如当前区块时间戳变量，uint timestamp = block.timestamp;</p>
<p>合约调用者地址变量，address sender = msg.sender;等。</p>
<p>变量可以通过不同关键字进行声明，表示不同的存储位置。</p>
<ul>
<li>storage，会存储在链上</li>
<li>memory，在内存中，只有方法被调用的时候才存在</li>
<li>calldata，作为调用方法传入参数时存在</li>
</ul>
<p>而常量是一种不可以改变值的变量，使用常量可以节约Gas费用，我们可以通过string public constant MY_CONSTANT = &quot;0707&quot;;来进行定义。immutable则是一种特殊的类型，它的值可以在constructor中初始化，但不可以再次改变。灵活使用这几种类型可以有效节省Gas费并保障数据安全。</p>
<h3 id="memory-storagecalldata-">Memory,Storage&amp;Calldata(介绍)</h3>
<p><img src="img/26.png" alt="26"></p>
<p>有六个地方,可以存储数据.</p>
<p>但是我们不能说变量是storage,code或logs,只能说变量是memory,storage或calldata</p>
<pre><code class="lang-solidity">   uint256 favoriteNumber;

   function addPerson(string memory _name, uint256 _favoriteNumber) public{
        People memory newPerson = People({favoriteNumber: _favoriteNumber, name: _name});
        people.push(newPerson);

        //上面那两句的效果相当于下面这一句
       //people.push(People(_favoriteNumber, _name));
    }
</code></pre>
<p>数据存储和存储器:</p>
<p>calldata:意味着变量只会暂时存在函数内,   是可以修改的临时变量</p>
<p>memory:意味着变量只会暂时存在函数内，是可以修改的临时变量所以上述那个_name变量在交易期间只是暂时存在,调用这个addPerson函数</p>
<p>storage:意味着变量不仅会存储在函数内甚至会存储在函数之外,是可以修改的永久变量，如上述的uint256 fovoriteNumber,如果没有特别指定的话,默认是自动转化为storage变量</p>
<p>为什么上述的函数中,只有_name需要指定memory,而 _favoriteNumber不需要呢?</p>
<p>因为<strong>我们只能给数组、结构体或映射指定数据位置</strong>。考虑数组,结构和映射被认为是Solidity里特殊的类型,Solidity自动知道在uint256中的位置,Solidity知道uint256类型的变量是一个临时变量。</p>
<p>但是不确定string类型的变量是什么,string其实是一个字节数组,因为string是一个数组,所以我们需要添加memory给数组指定数据位置,但是我们无法在_name前面添加storage关键字,Solidity也知道,这是一个函数,这个 _name变量实际上并没有存储在任何地方,故这个 _name变量只接受memory和calldata。</p>
<p>总结:当我们将数组,结构和映射作为参数添加到不同的函数时,需要给出memory或calldata关键字。</p>
<h3 id="mapping-">Mapping(映射)</h3>
<p>映射是另一种存储列表的数据结构,访问数据更快更便捷(映射是一种数据结构，其中键被“映射”到单个值)。</p>
<p>映射就像一本字典或者一串钥匙,每个键返回与该键关联的某个值。</p>
<p>映射使用mapping(keyType =&gt; valueType)来定义，其中键需要是内置类型，如bytes，int，string或合约类型，而值可以是任何类型，如嵌套mapping类型。需要注意的是，mapping类型是不能被迭代遍历的，需要遍历则需要自行实现对应索引。</p>
<p><strong>基本操作</strong></p>
<blockquote>
<pre><code class="lang-solidity">//定义嵌套mapping类型
mapping(string =&gt; mapping(string =&gt; string)) nestedMap;

//设置值
nestedMap[id][key] = &quot;0707&quot;;

//读取值
string value = nestedMap[id][key];

//删除值
delete nestedMap[id][key];
</code></pre>
</blockquote>
<p><strong>创建一个映射变量</strong></p>
<pre><code class="lang-solidity">    //字符串类型映射到uint类型
    //映射名为nameToFavoriteNumber,从名字映射到特定号码
    mapping(string =&gt; uint256) public nameToFavoriteNumber; 
</code></pre>
<p>然后将映射添加进数组里.</p>
<pre><code class="lang-solidity">    function addPerson(string memory _name, uint256  _favoriteNumber) public{
       people.push(People(_favoriteNumber, _name));
       nameToFavoriteNumber[_name] = _favoriteNumber;//string =&gt; uint256
    }
</code></pre>
<p>创建映射时将所有内容初始化为其空值,字符串的初始值为0.</p>
<p><img src="img/27.png" alt="27"></p>
<h3 id="-">部署第一个合约</h3>
<p>部署合约后:</p>
<p>橙色按钮是写入</p>
<p>蓝绿色按钮是读取</p>
<p>红色按钮用于标记</p>
<p>假设我们真的很喜欢我们的合约并且我们准备好了把它发送给一个测试网,让其他人与之互动</p>
<p>inject Web3:注入Web3(部署到链上)</p>
<p><img src="img/28.png" alt="28"></p>
<p>合约成功部署于Goerli测试网当中,一项由合约创建的交易。</p>
<p><img src="img/1-1668442553078-45.png" alt="1"></p>
<p>当我们向合约存储数据时,相当于我们要修改区块链状态,此时钱包会弹出新的交易确认并要求我们签署该交易。</p>
<p><img src="img/2-1668442559236-47.png" alt="2"></p>
<h3 id="evm-">EVM&amp;第二课回顾</h3>
<p>EVM:以太坊虚拟机</p>
<p>EVM使用智能合约的标准,可以将Solity部署到与EVM兼容的区块链,例如Avalanche(雪崩),Fantom(幻影)和Polygon(多边形)</p>
<p><strong>回顾:</strong></p>
<p>你需要在智能合约当中做的第一件事是讲述你将使用什么版本的Solidity,另外需要添加一个SPDX许可证标识符。</p>
<p>然后必须创建自己的合约对象并命名自己的合约Solidity中的contract类似于其他编程语言当中的class。</p>
<p>Solidity有许多不同的类型,例如uint256,boolean,string,bytes32。</p>
<p>我们还可以创建结构体数组(struct)</p>
<p>可以创建动态数组和静态数组</p>
<p>还可以创建映射(mapping)</p>
<p>可以在Solidity中创建函数来修改区块链的状态</p>
<p>还可以创建只读的函数来查看区块链的状态(view和pure)</p>
<p>还可以指定函数中不同数据的存储位置(calldata,memory,storage)</p>
<p>函数的参数不能是storage类型的,因为这些参数只能存在于函数运行期间。</p>
<p>当我们点击编译,Solidity代码实际上编译成EVM规格的合约字节码然后部署的时候部署到以太坊链上。</p>
<h2 id="3-storage-factory-">3.Storage Factory 合约(已)</h2>
<h3 id="-">将合约导入其他合约</h3>
<p>复杂业务中,我们往往需要多个合约之间进行配合,这时候可以使用import关键字来导入合约,分为本地导入和外部导入</p>
<p>相互影响的合约是Solidity程序必不可少的一部分，不同合约的能力彼此无缝交互,智能合约是可以组合的,因为它们可以轻松互动,这就相当于金融产品之间相互交流一样。</p>
<p>一个Solidity文件可以持有多个不同的合约对象</p>
<p><img src="img/3-1668442564093-49.png" alt="3"></p>
<p>StorageFactory合约要导入在SimpleStorage.</p>
<p>在函数中创建SimpleStorage合约对象</p>
<p>代码:</p>
<pre><code class="lang-solidity">contract StorageFactory {
    SimpleStorage public simpleStorage;//合约名 可见度标识符 变量名

    function createSimpleStorageContract() public {
            simpleStorage = new SimpleStorage();//我们要部署一个新的SimpleStorage合约对象
    }
}
</code></pre>
<p><img src="img/4-1668442567987-51.png" alt="4"></p>
<p>调用function,在StorageFactory合约中创建并部署SimpleStorage合约对象</p>
<p><img src="img/5-1668442573245-53.png" alt="5"></p>
<p>我们可以看到我们的StorageFactory合约有两个按钮,一个是创建并部署SimpleStorage合约对象,另一个是(view)阅读SimpleStorage合约。</p>
<p>最初是把SimpleStorage合约的代码放在了StorageFactory中,非常不方便,故平时使用<strong>impot</strong></p>
<p>新代码:</p>
<p><img src="img/6-1668442580849-55.png" alt="6"></p>
<p>如果我们将合约放在两个单独的文件中,我们实际上有可能在使用不同版本的Solidity,故我们的StorageFactory合约的Solidity版本设置一定是包含其他合约规定的Solidity版本的，这时候再使用StorageFactory合约取创建部署其他合约变量,Remix会自动把编译器设置到两者都兼容的版本,如果编译时报错,要及时调整Solidity版本。</p>
<p><strong>不能让我们创建的合约对象成为一个单一的对象,我们将使他成为一个简单的存储数组或列表</strong></p>
<pre><code class="lang-solidity">  SimpleStorage[] public simpleStorageArray;
</code></pre>
<p>转为数组后,每当我们创建一个新的simpleStorage合约对象时,不能像原来那样保存它,我们要添加这个对象到我们的SimpleStorage数组中。</p>
<pre><code class="lang-solidity">  function createSimpleStorageContract() public {
           SimpleStorage simpleStorage = new SimpleStorage();//我们要部署一个新的SimpleStorage合约对象
           simpleStorageArray.push(simpleStorage);
    }
</code></pre>
<p><img src="img/7-1668442584482-57.png" alt="7"></p>
<h3 id="-">与其他合约交互</h3>
<p><strong>其实就是导入其他合约,创建其他合约的对象,然后通过对象调用其他合约的函数。</strong></p>
<p><strong>唯一值得注意的是,这里是将其他合约对象创建为一个简单的存储数组或列表。</strong></p>
<p><strong>转为数组后,每当我们创建一个新的simpleStorage合约对象时,不能像原来那样保存它,我们要添加这个对象到我们的SimpleStorage数组中。</strong></p>
<p>建立顺序:</p>
<p>首先是我们的StorageFactory合约允许我们创建SimpleStorage合约对象,然后将其保存到我们的SimpleStorage数组中,然后我们可以调用不同的函数,我们可以在StorageFactory合约中存储值,我们可以从StorageFactory合约中读取值,为了我们创建并部署的SimpleStorage合约对象。</p>
<pre><code class="lang-solidity">//SPDX-License-Identifier:MIT
pragma solidity ^0.8.0;

import &quot;./SimpleStorage.sol&quot;;

contract StorageFactory {

    //不要让它成为一个单一的变量,我们将使它成为一个简单的存储数组或列表
    SimpleStorage[] public simpleStorageArray;

    function createSimpleStorageContract() public {
           SimpleStorage simpleStorage = new SimpleStorage();//我们要部署一个新的SimpleStorage合约对象
           simpleStorageArray.push(simpleStorage);
    }

    function sfStore(uint256 _simpleStorageIndex,uint256 _simpleStorageNumber) public {
        // Address
        // ABI - Application Binary Interface(应用二进制接口)会准确地告诉我们的代码它是如何做到与合约交互。
        //当我们编译SimpleStorage文件时,它与ABI预包装.
        // Address和ABI都是我们通过import得到的。
        // 所以要在我们的一份合约上调用store函数,我们首先需要得到那个合约对象,
        //SimpleStorage simpleStorage = SimpleStorage(simpleStorageArray[_simpleStorageIndex]);//如果合约上方的定义是address[] public simpleStorageArray,我们将不得不包装。
        //调用的合约名     变量名    =  合约名(合约数组索引作为地址来返回值)       
          SimpleStorage simpleStorage = simpleStorageArray[_simpleStorageIndex];
        //调用的合约名     变量名      =    合约数组索引后的值

        //相当于上方返回了一个对象,下方使用这个对象的方法。

        //调用我们的store函数
        simpleStorage.store(_simpleStorageNumber);
    }

    //公共视图函数,因为我们只是要读取我们的SimpleStorage合约
    function sfGet(uint256 _simpleStorageIndex) public view returns(uint256){
        SimpleStorage simpleStorage = simpleStorageArray[_simpleStorageIndex];
      //调用的合约名      变量名     =   合约数组索引后的值  

      //相当于上方返回了一个对象,下方使用这个对象的方法。

        return simpleStorage.retrieve();//获取我们刚刚存储在这里的那个号码
    }

}
</code></pre>
<p><img src="img/8-1668442590210-59.png" alt="8"></p>
<h3 id="-">继承和重写</h3>
<p>Solidity合约支持继承,且可以同时继承多个,使用is关键字。</p>
<p>函数可以重写,需要被继承的合约函数需要提前在本合约中提前声明为virual,重写函数需要在重写的合约中使用override关键字</p>
<p>示例:</p>
<pre><code class="lang-solidity">//定义父合约A
contract A {
        function foo() public pure virual returns (string memory) {
                return &quot;A&quot;;
        }
}

//B合约继承A合约并重写函数
contract B is A {
        function foo() public pure virual override returns (string memory) {
                return &quot;B&quot;;
        }
}

//调用不同合约中多次定义的函数时，父合约将从右到左，以深度优先的方式搜索。
//系统会首先偏向于调用最右边的父合约函数，所以super.foo()会在A.foo()和B.foo()之间进行选择并选择了后者，所以以下代码会返回B：
//C合约继承A,B合约并重写函数
contract C is A,B {
        function foo() public pure override(A,B) returns (string memory) {
                return super.foo()
        }
}
</code></pre>
<p>Java的继承使用的是extends关键字,Solidity的<strong>继承</strong>是使用is关键字。</p>
<p><img src="img/9-1668442593415-61.png" alt="9"></p>
<p>我们部署了ExtraStorage合约具有SimpleStorage合约的所有函数。</p>
<p>如果我们对继承对象的某些函数不喜欢,我们可以进行<strong>重写</strong>。</p>
<pre><code class="lang-solidity">//SPDX-License-Identifier:MIT

pragma solidity ^0.8.0;

import &quot;./SimpleStorage.sol&quot;;


contract ExtraStorage is SimpleStorage {
    // 希望我们在给他的任何数字上+5
    // 使用override函数
    // virtual override
    // 为了使函数可重写,需要在父合约的函数中添加virtual关键字
    function store(uint256 _favoriteNumber) public override {
        favoriteNumber = _favoriteNumber + 5;
    }
}
</code></pre>
<p><img src="img/10-1668442597196-63.png" alt="10"></p>
<h3 id="-">回顾</h3>
<p>我们了解到了我们实际上可以部署使用新的其他合同的关键词；可以使用import关键字导入其他合约进入我们的合同和代码,并且import关键字和复制一样粘贴该文件到import语句所在位置；可以使用ABI与其他合约交互；如果我们想创建一个子合约并继承一些其他合约的功能,我们可以使用一种叫继承的东西,该功能使用is关键字,但是如果我们想改变从父合约继承过来的函数,我们必须重写那个函数,并且我们必须在父合约中设置我们想要重写的函数(添加virtual关键字),在子合约的重写函数中添加override关键字。 </p>
<p><strong>SimpleStorage.sol</strong></p>
<pre><code class="lang-solidity">//SPDX-License-Identifier:MIT
pragma solidity ^0.8.8;

contract SimpleStorage {

    uint256  favoriteNumber;

    //字符串类型映射到uint类型
    //映射名为nameToFavoriteNumber,从名字映射到特定号码
    mapping(string =&gt; uint256) public nameToFavoriteNumber; 

    //创建一种新的类型
    //有点像uint256/boolean/string
    struct People {
        uint256 favoriteNumber;
        string name;

    }

    function store(uint256 _favoriteNumber) public virtual{
        favoriteNumber = _favoriteNumber;
    }

    //创建一个函数来返回favoriteNumber,模拟被自动创建的getter函数
    //view,pure
    function retrieve() public view returns(uint256){
        return favoriteNumber;
    }

     // uint256[] public favoriteNumberList;
    //People[3] public people;//静态数组(指定数组大小,该数组中只能放下三个人)
    People[] public people;//动态数组(数组的大小没有给出,我们不给它一个尺寸,这意味着它可以是任何尺寸,并且数组的大小可以随着我们加减人而增长和缩小)
    //0: 2,Patrick | 1: 7,Jon | 

    //calldata,memory,storage
    function addPerson(string memory _name, uint256  _favoriteNumber) public{
       people.push(People(_favoriteNumber, _name));
       nameToFavoriteNumber[_name] = _favoriteNumber;
    }
}
</code></pre>
<p><strong>StorageFactory.sol</strong></p>
<pre><code class="lang-solidity">//SPDX-License-Identifier:MIT
pragma solidity ^0.8.0;

import &quot;./SimpleStorage.sol&quot;;//导入其他合约到该地点

contract StorageFactory {
    //不要让它成为一个单一的变量,我们将使它成为一个简单的存储数组或列表
    SimpleStorage[] public simpleStorageArray;

    function createSimpleStorageContract() public {
           SimpleStorage simpleStorage = new SimpleStorage();//我们要部署一个新的SimpleStorage合约
           simpleStorageArray.push(simpleStorage);//使用其他合约的关键词
    }
    function sfStore(uint256 _simpleStorageIndex,uint256 _simpleStorageNumber) public {
        // Address
        // ABI - Application Binary Interface(应用二进制接口)会准确地告诉我们的代码它是如何做到与合约交互。
        //当我们编译SimpleStorage文件时,它与API预包装.
        // Address和ABI都是我们通过import得到的。
        // 所以要在我们的一份合约上调用store函数,我们首先需要得到那个合约对象,
        //SimpleStorage simpleStorage = SimpleStorage(simpleStorageArray[_simpleStorageIndex]);//如果合约上方的定义是address[] public simpleStorageArray,我们将不得不包装。
        //调用的合约名     变量名    =  合约名(合约数组索引作为地址来返回值)       
          SimpleStorage simpleStorage = simpleStorageArray[_simpleStorageIndex];
        //调用的合约名     变量名      =    合约数组索引后的值

        //相当于上方返回了一个对象,下方使用这个对象的方法。

        //调用我们的store函数
        simpleStorage.store(_simpleStorageNumber);
    }
    //公共视图函数,因为我们只是要读取我们的SimpleStorage合约
    function sfGet(uint256 _simpleStorageIndex) public view returns(uint256){
        SimpleStorage simpleStorage = simpleStorageArray[_simpleStorageIndex];
      //调用的合约名      变量名     =   合约数组索引后的值  

      //相当于上方返回了一个对象,下方使用这个对象的方法。

        return simpleStorage.retrieve();//获取我们刚刚存储在这里的那个号码
    }
}
</code></pre>
<p><strong>ExtraStorage.sol</strong></p>
<pre><code class="lang-solidity">//SPDX-License-Identifier:MIT

pragma solidity ^0.8.0;

import &quot;./SimpleStorage.sol&quot;;


contract ExtraStorage is SimpleStorage {
    // 希望我们在给他的任何数字上+5
    // 使用override函数
    // virtual override
    // 为了使函数可重写,需要在父合约的函数中添加virtual关键字
    function store(uint256 _favoriteNumber) public override {
        favoriteNumber = _favoriteNumber + 5;
    }
}
</code></pre>
<h2 id="4-fundme-">4.FundMe合约(已)</h2>
<p>我们将处理两个合约,一个是FundMe.sol,另一个是PriceConverter.sol。</p>
<p>FundMe.sol将是一份允许人们实际资助一个集体性组织的合约,所以人们可以发送以太币/多边形/雪崩/幻影/任何区块链原生代币进入本合约,然后合约的一些所有者可以提取这些资金并为所欲为。</p>
<p>FundMe.sol里面有两个主要的函数,fund函数(允许用户向合约存款)和withdraw函数(允许用户取回资金)</p>
<h3 id="-">通过一个函数发送以太坊并还原</h3>
<p><img src="img/11-1668442604784-65.png" alt="11"></p>
<p>事实上,我们发送的每一笔交易,会有这些字段。</p>
<p><img src="img/12-1668442608302-67.png" alt="12"></p>
<p>v,r,s是组件,被称为加密魔法,它发生在签署交易时,用于发送value。例如Gas Limit填充到2100,数据将为空,接着这些组件会成为交易的加法器</p>
<p>智能合约可以像我们的钱包那样存放资金,合约地址也可以折叠资金,因为每次部署合约,他们得到一个合约地址,它几乎与钱包地址完全相同,所以钱包和合约都可以持有像以太坊这样的原生区块链代币</p>
<pre><code class="lang-solidity">//希望从用户那里获得资金
//用户可以取回自己的钱
//把计量货币的单位换成美元

//SPDX-License-Identifier:MIT
pragma solidity ^0.8.8;


contract FundMe {
    uint256 public number;

    function fund() public payable{
        //想要把计量货币的单位换成美元
        //1.我们怎么把以太坊发给这个合约
        number = 5;
        //通过使用全局关键字之一(msg.value)得到某人发送了多少value
        //假设我们希望人们在每个交易中至少发送一个完整的以太,我们会像下面这样设置它
        //这个require关键字是一个检查器,如果msg.value &lt;= 1e18，它会发送错误消息并还原
        //还原的意思是说当它撤销之前发生的任何操作后,并将剩余的汽油费送回
        require(msg.value &gt; 1e18,&quot;Didn&#39;t send enough&quot;);//1e18 == 1 * 10^18 ==(1 * 10^18 Wei == 1 ETH) &quot;&quot;引号里面不能填写汉字
    }
   // function withdraw(){}
}
</code></pre>
<h3 id="chainlinkoracles-chainlink-">Chainlink&amp;Oracles(Chainlink预言机)</h3>
<p>我们如何将以太币转换为美元,Chainlink预言机即将到来发挥以太坊的美元价值;</p>
<p>所以为了获取区块链之外的美元的值,我们必须使用去中心化的预言机网络,以美元计算一个以太币的价格;</p>
<p>了解这些去中心化的预言机网络和他们拥有的不同解决方案,这样我们就可以以最先进的方式创建这个基金合约.</p>
<p>区块链是确定性系统,这意味着它们自己实际上无法与现实世界交互数据,它们不知道以太坊的价格是什么,它们不知道什么是随机数,什么是天气,什么是推特.它们不知道任何这些信息;同时区块链也不能做任何外部计算</p>
<p><img src="img/13-1668442614633-69.png" alt="13"></p>
<p>区块链在设计上是确定性的,这是为了让所有节点都能达成共识,如果你开始添加可变数据或随机数据,或者从API调用返回的值,不同的节点可能会获得不同的结果,它们永远无法达成共识。</p>
<p><img src="img/14-1668442618109-71.png" alt="14"></p>
<p>上述问题被称为智能合约连接问题(预言机问题),但是我们希望智能合约是可以替代传统协议,传统协议需要数据,它们需要与现实世界互动,这就是Chainlink和区块链预言机的用武之地。区块链预言机将成为任意设备与链下世界互动,提供外部数据或到智能合约中去计算的途径。如果我们使用中心化预言机,相当于我们正在重新引入一个故障点,我们已经在区块链上完成了所有的工作,使我们的逻辑层去中心化,但是如果我们通过一个中心化的节点或者中心化API获取我们的数据,破坏了我们建立智能合约的整个目的。</p>
<p><img src="img/15-1668442624000-73.png" alt="15"></p>
<p>Chainlink是中心化预言机的解决方案,Chainlink是一个去中心化的预言机网络,用于带着外部数据和外部计算进入我们的智能合约,这衍生出了混合型智能合约,使得链上和链下的功能都很丰富。Chainlink同时也是模块化的,可以定制以提供任何数据或做任何你喜欢的外部计算。在合约交易中,这个节点网络将返回数据给我们的智能合约。</p>
<p><img src="img/16-1668442627202-75.png" alt="16"></p>
<p>现在Chainlink网络可以完全定制,带来任何数据和任何外部计算,但是进行定制可能需要一些额外的工作。现在有一个开箱即用的Chainlink功能箱,完全去中心化,即插即用,进入您的智能合约应用服务程序。</p>
<p><img src="img/17-1668442630128-77.png" alt="17"></p>
<p>功能箱里的功能都有哪些呢?</p>
<p>第一个是Chainlink数据喂价。</p>
<p>下图中就是我们实际要使用的Chainlink功能</p>
<p>这里有四个应用(在去中心化交易的世界中Chainlink数据喂价已经超过500亿美金)</p>
<p><img src="img/18-1668442633786-79.png" alt="18"></p>
<p>它们的工作方式是Chainlink节点的网络从不同的交易所和数据提供者那里获取数据,并带着这些数据通过去中心化的Chainlink节点网络,Chainlink节点使用媒介来计算资产的实际价格是多少,然后在单个事务中交付到参考合约/喂价合约/链上数据合约中,其他智能合约可以使用,然后那些智能合约使用该定价信息为他们的Defi应用程序提供动力。</p>
<p><img src="img/19-1668442636771-81.png" alt="19"></p>
<p>在ETH/USD上,我们可以看到整个网络独立的Chainlink节点运营商。</p>
<p>和Transaction Gas类似,每当节点运营商传递数据给智能合约时,它们会获得报酬(Chainlink代币中的一点预言机Gas费)</p>
<p><img src="img/20-1668442645090-83.png" alt="20"></p>
<p>在链上这是一个关于目前型号类型的插图,这些数据喂价看起来像Chainlink节点的网络,每个人都伸出手来获取关于资产的信息然后签署数据,在单个交易中使用自己的私钥,然后一个节点将传递带有所有不同签名的所有数据给合约。如果该节点不提供数据,另一个节点将取代他,故在节点网络中运营商的声誉很重要,如果你忘记数据更新,忘记发送交易,可能会很快被踢出这些网络并且在未来也无法加入。</p>
<p><img src="img/21-1668442648421-85.png" alt="21"></p>
<p>这些数据喂价被该领域的一些最大协议使用</p>
<p><img src="img/22-1668442654640-87.png" alt="22"></p>
<p>例子:Chainlink和EVM合约一起工作.</p>
<p>使用和读取这些引导喂价</p>
<pre><code class="lang-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import &quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&quot;;

contract PriceConsumerV3 {

    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Goerli
     * Aggregator: ETH/USD
     * Address: 0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e
     */
     //从Goerli的价格信息中读取,我们实际上要使用测试网的原因是为了看到这项工作是不是建立在Chainlink节点监控测试网络,并向你准确展示这是如何工作的
    constructor() {
        priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);
    }

    /**
     * Returns the latest price
     */
    function getLatestPrice() public view returns (int) {
        (
            /*uint80 roundID*/,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}
</code></pre>
<p>没有Chainlink节点网络运行在Facke Remix VM环境中,有一个Chainklink节点网络运行在测试网环境中。</p>
<p>向我们展示了以太坊以美元计的最新价格</p>
<p>小数实际上不能很好地工作在Solidity,有一个小数标志与此喂价地址相关联,告诉我们要这个价格包含多少位小数.</p>
<p>这里实际上应该是1341.74330455</p>
<p><img src="img/1-1668442663855-89.png" alt="1"></p>
<p>喂价是开箱即用的最强大功能之一,有着去中心化特征,可以使用我们的智能合约来升级他们,特别是去中心化金融领域.</p>
<p>如果你正在寻找不同喂价的不同地址,你可以查看文档的合约地址部分(Contract Addresses)选择我们想要的网络,这里有不同种类喂价的地址。</p>
<p><img src="img/2-1668442668030-91.png" alt="2"></p>
<p>下一个开箱即用的去中心化功能是Chaink VRF(Chainlink verifiable random function)可验证的随机数</p>
<p><img src="img/3-1668442671845-93.png" alt="3"></p>
<p>在做彩票实例的时候,将讨论如何在区块链中操纵随机性,<strong>区块链是确定性系统,根据定义,意味着他们不能有随机性</strong>,但是如果我们能确定什么是随机数,它就不再是随机的了,所以我们需要一种方法来获得一个批准的随机数通过查看区块链之外的信息并和预言机完美定位。</p>
<p>Chainlink VRF是一种获得<strong>可证明的随机数</strong>进入我们的智能合约的方法目的是为了保证公平和申请的随机性。</p>
<p>有许多协议使用Chainlink VRF进行彩票,游戏中的随机化NFTs等等。</p>
<p><img src="img/4-1668442680577-95.png" alt="4"></p>
<p><img src="img/5-1669031555991-1.png" alt="5"></p>
<p>下一个开箱即用的去中心化功能是是Chainlink Keepers(饲养员),这是分散的事件驱动执行</p>
<p><img src="img/6-1668442686297-97.png" alt="6"></p>
<p>为了启动某种类型的交易,有的人需要花费Gas,有的人需要坐下来按下开始按钮/交易按钮,这显然是一个集中向量,如果你有一个去中心化的应用程序需要在特定时间/特定事件触发之后运行,Chainlink Keepers 是解决此问题的方法。Chainlink Keepers是Chainlink节点用来登记合同的功能，对于你指定要触发的不同事件(比如每10分钟喝一次水或当BTC的价格突破10万美金的时候把它给卖掉),无论编写什么事件都可以,Chainlink节点不断监听,让这些触发器发生,并检查这些触发器的不同合约,一旦触发器返回true,然后Chainlink节点将执行设定的操作。</p>
<p><img src="img/7-1668442689478-99.png" alt="7"></p>
<p>Chainlink的最后一个开箱即用的去中心化功能是End-to-end Reliability Is The Promise of Smart Contracts(端到端可靠性是智能合约的承诺),它是可定制性最好的,但也是最难纠正的。</p>
<p><img src="img/8-1668442693633-101.png" alt="8"></p>
<p>我们的希望并且需要我们的智能合约能够做任何事情,能够接受任何输入并得到任何输出。</p>
<p>制作http获取http发布请求,是自定义Chainlink节点的简单方法以便能够做任何事情。</p>
<p>例如:进行API调用.区块链节点本身无法做到这一点，Chainlink也做不到,Chainlink节点可以直接向任何API发出你指定的请求,但是必须选择Chainlink节点和URL削减数据来发送请求,这样比较麻烦,因为必须创建Chainlink网络从许多不同的Chainlink节点和数据提供者中获取数据。</p>
<p>代码：</p>
<pre><code class="lang-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import &#39;@chainlink/contracts/src/v0.8/ChainlinkClient.sol&#39;;
import &#39;@chainlink/contracts/src/v0.8/ConfirmedOwner.sol&#39;;

/**
 * Request testnet LINK and ETH here: https://faucets.chain.link/
 * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
 */

/**
 * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
 * THIS EXAMPLE USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract APIConsumer is ChainlinkClient, ConfirmedOwner {
    using Chainlink for Chainlink.Request;

    uint256 public volume;
    bytes32 private jobId;
    uint256 private fee;

    event RequestVolume(bytes32 indexed requestId, uint256 volume);

    /**
     * @notice Initialize the link token and target oracle
     *
     * Goerli Testnet details:
     * Link Token: 0x326C977E6efc84E512bB9C30f76E30c160eD06FB
     * Oracle: 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7 (Chainlink DevRel)
     * jobId: ca98366cc7314957b8c012c72f05aeeb
     *
     */
    constructor() ConfirmedOwner(msg.sender) {
        setChainlinkToken(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
        setChainlinkOracle(0xCC79157eb46F5624204f47AB42b3906cAA40eaB7);
        jobId = &#39;ca98366cc7314957b8c012c72f05aeeb&#39;;
        fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
    }

    /**
     * Create a Chainlink request to retrieve API response, find the target
     * data, then multiply by 1000000000000000000 (to remove decimal places from data).
     */
    function requestVolumeData() public returns (bytes32 requestId) {
        Chainlink.Request memory req = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);

        // Set the URL to perform the GET request on
        req.add(&#39;get&#39;, &#39;https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&amp;tsyms=USD&#39;);

        // Set the path to find the desired data in the API response, where the response format is:
        // {&quot;RAW&quot;:
        //   {&quot;ETH&quot;:
        //    {&quot;USD&quot;:
        //     {
        //      &quot;VOLUME24HOUR&quot;: xxx.xxx,
        //     }
        //    }
        //   }
        //  }
        // request.add(&quot;path&quot;, &quot;RAW.ETH.USD.VOLUME24HOUR&quot;); // Chainlink nodes prior to 1.0.0 support this format
        req.add(&#39;path&#39;, &#39;RAW,ETH,USD,VOLUME24HOUR&#39;); // Chainlink nodes 1.0.0 and later support this format

        // Multiply the result by 1000000000000000000 to remove decimals
        int256 timesAmount = 10**18;
        req.addInt(&#39;times&#39;, timesAmount);

        // Sends the request
        return sendChainlinkRequest(req, fee);
    }

    /**
     * Receive the response in the form of uint256
     */
    function fulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId) {
        emit RequestVolume(_requestId, _volume);
        volume = _volume;
    }

    /**
     * Allow withdraw of Link tokens from the contract
     */
    function withdrawLink() public onlyOwner {
        LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
        require(link.transfer(msg.sender, link.balanceOf(address(this))), &#39;Unable to transfer&#39;);
    }
}
</code></pre>
<p>如果我们想把API加入到合约中,会创建一个代理,对这个API进行get调用</p>
<h3 id="-eth-chainlink">回顾发送ETH的函数和使用Chainlink</h3>
<p>为了用一个函数发送以太坊或者任何原生区块链代币,我们需要将其标记为&quot;payable&quot;;如果我们想让合约上的事务发生错误后回滚,我们可以使用require语句获取以太坊或其他原生区块链代币,可以使用全局变量msg.value获取发送的代币价值。</p>
<p>Chainlink是一项在去中心化环境中为我们的智能合约获取外部数据,进行外部计算的技术。</p>
<p>对我们来说Chainlink数据喂价是读取来自现实世界的定价信息或其他数据的方式</p>
<p>Chainlink VRF是一种指定来自真实世界的随机数字进入我们的智能合约的方式</p>
<p>Chainlink keepers(饲养员)是一种去中心化的方式,事件驱动的计算,我们可以设置触发点,定制化等等,Chainlink的任何API是Chainlink节点的终极定制并且允许我们连接这个星球上的任何东西。</p>
<h3 id="-">接口和喂价</h3>
<p><img src="img/9-1668442706437-103.png" alt="9"></p>
<pre><code class="lang-solidity">//希望从用户那里获得资金
//用户可以取回自己的钱
//把计量货币最小值换成美元

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;

interface AggregatorV3Interface {
  function decimals() external view returns (uint8);

  function description() external view returns (string memory);

  function version() external view returns (uint256);

  function getRoundData(uint80 _roundId)
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );

  function latestRoundData()
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );
}

contract FundMe {

    uint256 public minimumUsd = 50;

    function fund() public payable{
        //0.想要把计量货币最小值换成美元
        //1.我们怎么把以太坊发给这个合约
        //通过使用全局关键字之一(msg.value)得到某人发送了多少value
        //假设我们希望人们在每个交易中至少发送一个完整的以太,我们会像下面这样设置它
        //这个require关键字是一个检查器,如果msg.value &lt;= 1e18，它会发送错误消息并还原
        //还原的意思是说当它撤销之前发生的任何操作后,并将剩余的汽油费送回
        require(msg.value &gt;= minimumUsd,&quot;Didn&#39;t send enough&quot;);//1e18 == 1 * 10^18 ==(1 * 10^18 Wei == 1 ETH) &quot;&quot;引号里面不能填写汉字     
    }

    //用该函数来计算以美元为单位时,代币的理论价格
    //为了获取价格一定要使用Chainlink喂价来获取定价信息
    function getPrice() public {
        //引入项目外合约里的价格函数
        //因为这是我们在与项目之外的合约进行交互,所以我们需要两样东西(之前的交互都是使用import)
        //1.合约的ABI 通过编译聚合器V3接口合约,我们能得到ABI
        //2.合约的地址address     ETH/USD:0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e
    }

    //在本合约中调用version函数获得喂价的版本
    function getVersion() public view returns (uint256) {
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);
        return priceFeed.version();
    }

    //用该函数来获取汇率
    function getConversionRate() public {}

    // function withdraw(){}
}
</code></pre>
<h3 id="-github-npm-">从GitHub和NPM引入合约</h3>
<p>从GitHub中引入合约</p>
<pre><code class="lang-solidity">import &quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&quot;;
</code></pre>
<p>从NPM(Chainlink的NPM包)中引入合约</p>
<p>NPM(Node Package Manager):node.js 的包管理器，用于node插件管理（包括安装、卸载、管理依赖等） ，NPM 是随同 node.js 一起安装的包管理工具，能解决 node.js 代码部署上的很多问题，常见的使用场景有以下几种：</p>
<ul>
<li>允许用户从 NPM 服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从 NPM 服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到 NPM 服务器供别人使用。</li>
</ul>
<p><img src="img/10-1668442717040-105.png" alt="10"></p>
<p>代码:</p>
<pre><code class="lang-solidity">//希望从用户那里获得资金
//用户可以取回自己的钱
//把计量货币最小值换成美元

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;

import &quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&quot;;

contract FundMe {

    uint256 public minimumUsd = 50;

    function fund() public payable{
        //0.想要把计量货币最小值换成美元
        //1.我们怎么把以太坊发给这个合约
        //通过使用全局关键字之一(msg.value)得到某人发送了多少value
        //假设我们希望人们在每个交易中至少发送一个完整的以太,我们会像下面这样设置它
        //这个require关键字是一个检查器,如果msg.value &lt;= 1e18，它会发送错误消息并还原
        //还原的意思是说当它撤销之前发生的任何操作后,并将剩余的汽油费送回
        require(msg.value &gt;= minimumUsd,&quot;Didn&#39;t send enough&quot;);//1e18 == 1 * 10^18 ==(1 * 10^18 Wei == 1 ETH) &quot;&quot;引号里面不能填写汉字     
    }

    //用该函数来计算以美元为单位时,代币的理论价格
    //为了获取价格一定要使用Chainlink喂价来获取定价信息
    function getPrice() public {
        //引入项目外合约里的价格函数
        //因为这是我们在与项目之外的合约进行交互,所以我们需要两样东西(之前的交互都是使用import)
        //1.合约的ABI 通过编译聚合器V3接口合约,我们能得到ABI
        //2.合约的地址address     ETH/USD:0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e
    }

    //在本合约中调用version函数获得喂价的版本
    function getVersion() public view returns (uint256) {
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);
        return priceFeed.version();
    }

    //用该函数来获取汇率
    function getConversionRate() public {}

    // function withdraw(){}
}
</code></pre>
<h3 id="solidity-">Solidity中的浮点数</h3>
<pre><code class="lang-solidity">//希望从用户那里获得资金
//用户可以取回自己的钱
//把计量货币最小值换成美元

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;

import &quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&quot;;

contract FundMe {

    uint256 public minimumUsd = 50 * 1e18;// 1 * 10^18

    function fund() public payable{
        //0.想要把计量货币最小值换成美元
        //1.我们怎么把以太坊发给这个合约
        //通过使用全局关键字之一(msg.value)得到某人发送了多少value
        //假设我们希望人们在每个交易中至少发送一个完整的以太,我们会像下面这样设置它
        //这个require关键字是一个检查器,如果msg.value &lt;= 1e18，它会发送错误消息并还原
        //还原的意思是说当它撤销之前发生的任何操作后,并将剩余的汽油费送回
        require(getConversionRate(msg.value) &gt;= minimumUsd,&quot;Didn&#39;t send enough&quot;);//1e18 == 1 * 10^18 ==(1 * 10^18 Wei == 1 ETH) &quot;&quot;引号里面不能填写汉字     
        //msg.value有18位小数位
    }

    //用该函数来计算以美元为单位时,代币的理论价格
    //为了获取价格一定要使用Chainlink喂价来获取定价信息
    function getPrice() public view returns(uint256){
        //引入项目外合约里的价格函数
        //因为这是我们在与项目之外的合约进行交互,所以我们需要两样东西(之前的交互都是使用import)
        //1.合约的ABI 通过编译聚合器V3接口合约,我们能得到ABI
        //2.合约的地址address     ETH/USD:0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e
        //创建一个聚合器对象,命名为喂价,这个合约地址的对象拥有聚合器接口的全部函数
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);
        //调用函数,获取最新一轮的价格,由于这个函数返回一大堆不同的变量,故需要设置返回值,但是这些变量里我们只关注价格,把其他变量去掉只留下逗号
        (,int256 price,,,) = priceFeed.latestRoundData();//相当于返回最新一轮数据的价格
        //上述函数返回的是按美元计算的ETH的价格
        //AggregatorV3Interface合约有一个小数(decimals)函数,它会告诉你在喂价中有多少个小数位.
        //解决小数点问题
        return uint256(price * 1e10);//1 * 10^10 == 10000000000//因为msg.value是uint256类型的,获取的定价也应是uint256类型的
        //18-10=8位小数?


        //(uint80 roundId,int price,uint startedAt,uint timeStamp,uint80 answeredInRound) = priceFeed.latestRoundData();

    }

    //在本合约中调用version函数获得喂价的版本
    function getVersion() public view returns (uint256) {
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);
        return priceFeed.version();
    }

    //用该函数来获取转换率
    function getConversionRate(uint256 ethAmount) public view returns (uint256) {
        //调用新创建的getPrice函数来为自变量赋值
        uint256 ethPrice  = getPrice();

        //3000_000000000000000000 = ETH/USD 

        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18;  
        return ethAmountInUsd;
    }

    // function withdraw(){}
}
</code></pre>
<h3 id="solidity-ii">Solidity基础-数组和结构体II</h3>
<pre><code class="lang-solidity">//希望从用户那里获得资金
//用户可以取回自己的钱
//把计量货币最小值换成美元

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;

import &quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&quot;;

contract FundMe {

    uint256 public minimumUsd = 50 * 1e18;// 1 * 10^18

    //当有人把钱寄到这个合约上时,我们想要追踪所有寄给我们的钱
    //让我们创建一个名为资助者的地址数组
    address[] public funders;

    //地址到uint256的映射
    //资助者地址到资助金额的映射
    mapping(address =&gt; uint256) public addressToAmountFunded;


    function fund() public payable{
        //0.想要把计量货币最小值换成美元
        //1.我们怎么把以太坊发给这个合约
        //通过使用全局关键字之一(msg.value)得到某人发送了多少value
        //假设我们希望人们在每个交易中至少发送一个完整的以太,我们会像下面这样设置它
        //这个require关键字是一个检查器,如果msg.value &lt;= 1e18，它会发送错误消息并还原
        //还原的意思是说当它撤销之前发生的任何操作后,并将剩余的汽油费送回
        require(getConversionRate(msg.value) &gt;= minimumUsd,&quot;Didn&#39;t send enough&quot;);//1e18 == 1 * 10^18 ==(1 * 10^18 Wei == 1 ETH) &quot;&quot;引号里面不能填写汉字     
        //msg.value有18位小数位,代表多少以太坊/发送了多少原生区块链代币
        //只要有人给我们寄钱,并且满足检查器要求时,我们会把资助者加到数组里
        funders.push(msg.sender);//msg.sender是一个始终可用的全局关键字,代表调用fund函数的人的地址,把地址加到资助者数组里
        //当有人资助我们的合约时,地址=&gt;资助金额
        addressToAmountFunded[msg.sender] = msg.value;

    }

    //用该函数来计算以美元为单位时,代币的理论价格
    //为了获取价格一定要使用Chainlink喂价来获取定价信息
    function getPrice() public view returns(uint256){
        //引入项目外合约里的价格函数
        //因为这是我们在与项目之外的合约进行交互,所以我们需要两样东西(之前的交互都是使用import)
        //1.合约的ABI 通过编译聚合器V3接口合约,我们能得到ABI
        //2.合约的地址address     ETH/USD:0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e
        //创建一个聚合器对象,命名为喂价,这个合约地址的对象是否拥有聚合器接口的全部功能?
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);
        //调用函数,获取最新一轮的价格,由于这个函数返回一大堆不同的变量,故需要设置返回值,但是这些变量里我们只关注价格,把其他变量去掉只留下逗号
        (,int256 price,,,) = priceFeed.latestRoundData();//相当于返回最新一轮数据的价格
        //上述函数返回的是按美元计算的ETH的价格
        //AggregatorV3Interface合约有一个小数(decimals)函数,它会告诉你在喂价中有多少个小数位.
        //解决小数点问题
        return uint256(price * 1e10);//1 * 10^10 == 10000000000//因为msg.value是uint256类型的,获取的定价也应是uint256类型的
        //18-10=8位小数?


        //(uint80 roundId,int price,uint startedAt,uint timeStamp,uint80 answeredInRound) = priceFeed.latestRoundData();

    }

    //在本合约中调用version函数获得喂价的版本
    function getVersion() public view returns (uint256) {
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);
        return priceFeed.version();
    }

    //用该函数来获取转换率
    function getConversionRate(uint256 ethAmount) public view returns (uint256) {
        //调用新创建的getPrice函数来为自变量赋值
        uint256 ethPrice  = getPrice();

        //3000_000000000000000000 = ETH/USD 

        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18;  
        return ethAmountInUsd;
    }

    // function withdraw(){}
}
</code></pre>
<h3 id="-solidity-github-">回顾:在 Solidity 中查看接口、GitHub 导入,数据计算</h3>
<p>每当我们使用项目外的合约的时候,我们总是需要ABI和接口编译时的地址,给了我们极简的ABI之后我们能够与项目之外的合约互动,当你在这些编译后的接口中写入一个地址并建立对象,我们可以在本合约中调用接口的函数。</p>
<p>Chainlink 数据喂价用去中心化的方式获取关于现实世界的信息,在这种情况下,我们参考来自去中心化Chainlink节点的数据信息后用美元来计算以太坊的价格,但是在处理小数的时候,它不起作用(在Solidity中不管做任何类型的数据计算,要确保各个数据有正确的单位)。</p>
<p>msg.sender，msg.value是全局可用的变量。</p>
<p>msg.sender表示消息调用者 (当前调用)</p>
<p>msg.value表示与消息一起发送的以太币(以Wei为单位)</p>
<h3 id="libraries-">Libraries(库)</h3>
<p>外部库和合约类似,但不能声明状态变量,也不能发送资产,也不能继承或被继承,也不可以被销毁。如果库的所有方法都是internal的话会被嵌入合约,如果非internal,需要提前部署库并连接起来。</p>
<p><strong>PriceConverter.sol</strong></p>
<pre><code class="lang-solidity">//SPDX-License-Identifier:MIT

pragma solidity ^0.8.0;

import &quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&quot;;

library PriceConverter {

     //用该函数来计算以美元为单位时,代币的理论价格
    //为了获取价格一定要使用Chainlink喂价来获取定价信息
    function getPrice() internal view returns(uint256){
        //引入项目外合约里的价格函数
        //因为这是我们在与项目之外的合约进行交互,所以我们需要两样东西(之前的交互都是使用import)
        //1.合约的ABI 通过编译聚合器V3接口合约,我们能得到ABI
        //2.合约的地址address     ETH/USD:0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e
        //创建一个聚合器对象,命名为喂价,这个合约地址的对象是否拥有聚合器接口的全部功能?
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);
        //调用函数,获取最新一轮的价格,由于这个函数返回一大堆不同的变量,故需要设置返回值,但是这些变量里我们只关注价格,把其他变量去掉只留下逗号
        (,int256 price,,,) = priceFeed.latestRoundData();//相当于返回最新一轮数据的价格
        //上述函数返回的是按美元计算的ETH的价格
        //AggregatorV3Interface合约有一个小数(decimals)函数,它会告诉你在喂价中有多少个小数位.
        //解决小数点问题
        return uint256(price * 1e10);//1 * 10^10 == 10000000000//因为msg.value是uint256类型的,获取的定价也应是uint256类型的
        //18-10=8位小数?


        //(uint80 roundId,int price,uint startedAt,uint timeStamp,uint80 answeredInRound) = priceFeed.latestRoundData();

    }

    //在本合约中调用version函数获得喂价的版本
    function getVersion() internal view returns (uint256) {
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);
        return priceFeed.version();
    }

    //用该函数来获取转换率
    function getConversionRate(uint256 ethAmount) internal view returns (uint256) {
        //调用新创建的getPrice函数来为自变量赋值
        uint256 ethPrice  = getPrice();

        //3000_000000000000000000 = ETH/USD 

        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18;  
        return ethAmountInUsd;
    }

}
</code></pre>
<p><strong>FundMe.sol</strong></p>
<pre><code class="lang-solidity">//希望从用户那里获得资金
//用户可以取回自己的钱
//把计量货币最小值换成美元

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;

import &quot;./PriceConverter.sol&quot;;

contract FundMe {
    //using A for B;
    //可用于附加库函数（从库 A）到任何类型（B）。添加完指令后，库A中的函数会自动添加为B类型变量的成员，可以直接调用。
    using PriceConverter for uint256;

    uint256 public minimumUsd = 50 * 1e18;// 1 * 10^18

    //当有人把钱寄到这个合约上时,我们想要追踪所有寄给我们的钱
    //让我们创建一个名为资助者的地址数组
    address[] public funders;

    //地址到uint256的映射
    //资助者地址到资助金额的映射
    mapping(address =&gt; uint256) public addressToAmountFunded;


    function fund() public payable{
        //0.想要把计量货币最小值换成美元
        //1.我们怎么把以太坊发给这个合约
        //通过使用全局关键字之一(msg.value)得到某人发送了多少value
        //假设我们希望人们在每个交易中至少发送一个完整的以太,我们会像下面这样设置它
        //这个require关键字是一个检查器,如果msg.value &lt;= 1e18，它会发送错误消息并还原
        //还原的意思是说当它撤销之前发生的任何操作后,并将剩余的汽油费送回

        //msg.value被认为是这些库函数的第一个参数变量
        require(msg.value.getConversionRate() &gt;= minimumUsd,&quot;Didn&#39;t send enough&quot;);//1e18 == 1 * 10^18 ==(1 * 10^18 Wei == 1 ETH) &quot;&quot;引号里面不能填写汉字     

        //msg.value有18位小数位,代表多少以太坊/发送了多少原生区块链代币
        //只要有人给我们寄钱,并且满足检查器要求时,我们会把资助者加到数组里
        funders.push(msg.sender);//msg.sender是一个始终可用的全局关键字,代表调用fund函数的人的地址,把地址加到资助者数组里
        //当有人资助我们的合约时,地址=&gt;资助金额
        addressToAmountFunded[msg.sender] = msg.value;
    }


    // function withdraw(){}
}
</code></pre>
<h3 id="safemath-overflow-checking-unchecked-">SafeMath、Overflow checking和“unchecked”关键字</h3>
<p>SafeMath曾经是最常用的库</p>
<p><strong>SafeMathTester.sol</strong></p>
<pre><code class="lang-solidity">//SPDX-License-Identifier:MIT
pragma solidity ^0.6.0;

contract SafeMathTester{
    //上限是256
    uint8 public bigNumber = 255;//uint 和 int有一个unchecked的概念,也就是说如果你超过了上限,它只会绕过来然后重新开始
    //在新版本(0.8以上)的Solidity中,,如果你要去对变量执行所谓的溢出或下溢操作,它会自动检查(checked)以确保内存不会溢出
    //可以在函数中这样写unchecked {bigNumber = bigNumber + 1};unchecked关键字会让代码更节省Gas费


    function add() public {
        bigNumber = bigNumber + 1;
    }

}
</code></pre>
<h3 id="solidity-for-">Solidity基础-for循环</h3>
<pre><code> for(/*starting index, ending index, step amount */)
</code></pre><pre><code class="lang-solidity">//资助者通过这个函数从合约中撤回所有资金
    function withdraw() public {
        //继续循环投资者数组然后更新映射对象
        /*starting index, ending index, step amount */
        //重置映射
        for(uint256 funderIndex = 0; funderIndex &lt; funders.length; funderIndex++){

            address funder = funders[funderIndex];//这个会返回一个供我们使用的地址,一个资助者地址可以看作一个资质者
            addressToAmountFunded[funder] = 0;//当我们从合同中把钱取走时,要把映射重置为0,新的key-value对的key是funder

        }

        //重置数组
        //提取资金
    }
</code></pre>
<h3 id="solidity-">Solidity基础-重置数组</h3>
<pre><code> //重置数组
funders = address[](0);//funders变量现在等于一个全新的里面没有对象的地址数组
</code></pre><h3 id="-eth">从合约发送ETH</h3>
<p>您可以通过以下方式将以太币发送到其他合约</p>
<ul>
<li><code>transfer</code>（2300 Gas，失败会抛出错误）</li>
<li><code>send</code>（2300 Gas，失败会返回布尔值）</li>
<li><code>call</code>（支付所有Gas或设置气体，失败会返回布尔值）--这样就不会有Gas费上限</li>
</ul>
<p>实际当中一般推荐call进行发送</p>
<pre><code class="lang-solidity">
        //1.transfer
        //this指的是整个合约,address(this).balance我们可以得到原生代币或者以太坊代币余额
        //然后需要进行类型转换,从地址类型到payable地址类型
        payable(msg.sender).transfer(address(this).balance);//如果这一行失败,它将释放并恢复交易
        //msg.sender = address
        //payable(msg.sender) = payable address



        //2.send

        bool sendSuccess = payable(msg.sender).send(address(this).balance);//如果这一行失败,合约不会使交易恢复原状,我们就再也拿不到钱了,设置了返回值和下方的检查器
        require(sendSuccess,&quot;Send failed&quot;);


        //3.call
        //call是Solidity中的一个底层命令,这个调用函数实际上非常强大,我们可以用它来调用以太坊中几乎所有的功能(甚至不需要ABI)
        (bool callSuccess, bytes memory dataReturned) = payable(msg.sender).call{value: address(this).balance}(&quot;&quot;);//&quot;&quot;号里可以填任何函数信息,或者想在其他合约中调用的函数的信息;如果不想调用函数的话就可以什么都不填
        //call允许我们调用不同的函数,如果该函数返回一些数据或值,我们会把它保存在dataReturned变量中,因为bytes对象是数组,返回的数据需要在内存中,故用memory修饰。
        require(callSuccess,&quot;Call failed&quot;);
</code></pre>
<p><img src="img/11-1668442739976-107.png" alt="11"></p>
<p>Balance是余额的意思</p>
<h3 id="solidity-">Solidity基础-构造函数</h3>
<p>Solidity 的constructor可以在创建合约时使执行，主要用来初始化。</p>
<pre><code class="lang-solidity">    //设置一些参数,以便只有合约的所有者可以调用withdraw函数
    address public owner;
    //构造函数,在同一个交易中立即调用。
    constructor(){
       owner = msg.sender;
    }
</code></pre>
<p>如果合约之间存在继承关系,constructor也会按照继承顺序。</p>
<h3 id="solidity-modifier-">Solidity基础-修改器(modifier)</h3>
<p>modifier函数修饰符可以在函数运行前/后被调用,主要用来进行权限控制、对输入参数进行校验以及防止重入攻击等。这三种功能修饰符可以通过以下语法定义:</p>
<pre><code>//进行权限控制
modifier onlyOwner(){
    require(msg.sender == owner,&quot;Not Owner&quot;)
    _;
}

//对输入参数进行校验
modifier validAddress(address _addr){
    //address(0)是变量的初始值address
    require(_addr != address(0), &quot;Not valid address&quot;);
    _;
}

//防止重入攻击
modifier noReentrancy() {
    //locked是假,则往下执行;locked是真则恢复    
    require(!locked,&quot;No reentrancy&quot;);
    locked = true;
    _;
    locked = false;
}
</code></pre><p><strong>使用modifier需要在函数声明时添加对应修饰符,如下代码所示</strong></p>
<pre><code>//资助者通过这个函数从合约中撤回所有资金
    function withdraw() public onlyOwner {

        //继续循环投资者数组然后更新映射对象
        /*starting index, ending index, step amount */
        //重置映射
        for(uint256 funderIndex = 0; funderIndex &lt; funders.length; funderIndex++){

            address funder = funders[funderIndex];//这个会返回一个供我们使用的地址,一个资助者地址可以看作一个资质者
            addressToAmountFunded[funder] = 0;//当我们从合同中把钱取走时,要把映射重置为0,新的key-value对的key是funder
        }
        //重置数组
        funders = new address[](0);//funders变量现在等于一个全新的里面没有对象的地址数组
        //提取资金
        //call是Solidity中的一个低级命令,这个调用函数实际上非常强大,我们可以用它来调用以太坊中几乎所有的功能(甚至不需要ABI)
        (bool callSuccess,) = payable(msg.sender).call{value: address(this).balance}(&quot;&quot;);//&quot;&quot;号里可以填任何函数信息,或者想在其他合约中调用的函数的信息;如果不想调用函数的话就可以什么都不填
        //call允许我们调用不同的函数,如果该函数返回一些数据或值,我们会把它保存在dataReturned变量中,因为bytes对象是数组,返回的数据需要在内存中,故用memory修饰。
        require(callSuccess,&quot;Call failed&quot;);
    }

    //修饰器将是一个我们可以添加在函数声明中用来修改函数功能的关键字
    modifier onlyOwner {
        //必须是合约所有者才能真正地调用取钱函数
        require(msg.sender == owner,&quot;Sender is not owner!&quot;);
        _;//在函数声明中,对于取款函数,在阅读其他代码之前,先过来阅读onlyOwner修改器代码,先执行检查器代码,然后做下划线上的事,这个下划线表示执行剩下的代码。
    }

</code></pre><h3 id="-">测试网演示</h3>
<p>首先,我们来资助这个合约,融资前我们要做一点数据计算(50/1000 USD/ETH),融资结束后我们往下看数组和映射,把合约执行者地址粘入映射视图中,然后按照索引在数组中寻找投资人地址(我们可以在未来合约中做的一个优化就是检查看看如果一个地址已经在投资人数组里的话,就不再添加单独索引给该地址了,直接把投资金额归到之前的Key-value对中)，最后切换账户取钱,发现不是合约所有者取不了钱</p>
<p><img src="img/12-1668442748321-109.png" alt="12"></p>
<p><img src="img/13-1668442751553-111.png" alt="13"></p>
<p>使用合约所有者取钱后</p>
<p><img src="img/14-1668442754633-113.png" alt="14"></p>
<h3 id="solidity-immutableconstant">Solidity进阶-Immutable&amp;Constant</h3>
<p>一些降低Gas费的工具和技巧</p>
<p>immutable(不可变量):值在部署时确定，也就是说它的值可以在constructor中初始化,但不可以再次改变。也可以节约Gas费用。</p>
<p>常量是一种不可以改变值的变量,使用常量可以节约gas费用。</p>
<p>constant(常量):值在编译时确定</p>
<p>添加了constant关键字后,MINIMUM_USD不再占用一个存储点</p>
<pre><code> uint256 public constant MINIMUM_USD = 50 * 1e18;// 1 * 10^18
</code></pre><p><strong>常量的命名方式潜规则MINIMUM_USD(全部大写,单词隔断处加下划线)</strong></p>
<p><strong>在定义变量时添加这两个关键字是很好的习惯.</strong></p>
<pre><code> address public immutable i_owner;
</code></pre><p><strong>不可变量的命名方式潜规则i_owner(在变量名前面加上i_ )</strong></p>
<p><strong>这两个关键字节省Gas费的原因是:它们不再存储这些变量在storage区域内,而是把他们存储起来后直接进入合约的二进制代码中</strong></p>
<h3 id="solidity-custom-error">Solidity进阶-Custom Error</h3>
<p>检查器当中的语句如果执行失败的话,会发送错误日志并还原,而这个错误日志原来是一个字符串数组,错误日志中的每一个字符需要单独存储然后发出,这个错误日志比custom error(自定义错误)所占的存储大得多,消耗的Gas费也很多。</p>
<pre><code class="lang-solidity">//这个require关键字是一个检查器,如果msg.value &lt;= 1e18，它会发送错误日志并还原

//还原的意思是说当它撤销之前发生的任何操作后,并将剩余的汽油费送回

require(msg.value.getConversionRate() &gt;= MINIMUM_USD,&quot;Didn&#39;t send enough&quot;);
</code></pre>
<p>我们在顶部声明custom error(自定义错误),然后使用if而不是require,接着添加我们的revert语句。这样就可以在与上述语句达到相同效果的同时也能节省很多Gas费,因为我们在执行的时候只是调用error代码而不是与错误日志整个关联的字符串。</p>
<pre><code class="lang-solidity">error NotOwner();

if(msg.sender != i_owner) { revert NotOwner(); }

require(msg.sender == i_owner,&quot;NotOwner()&quot;);//这种写法也可以
</code></pre>
<h3 id="solidity-receivefallback">Solidity进阶-Receive&amp;Fallback</h3>
<p>如果有人在没有调用fund函数的情况下发送 ETH 给这个合约(也就是直接在钱包里给资产所有者转账)会发生什么?</p>
<p>receive函数只有当CALLDATA为空时才会触发。</p>
<p>receive函数:一个合约最多有一个 <code>receive</code> 函数, 声明函数为： <code>receive() external payable { ... }</code></p>
<p>不需要 <code>function</code> 关键字，也没有参数和返回值并且必须是　<code>external</code>　可见性和　<code>payable</code> 修饰． 它可以是 <code>virtual</code> 的，可以被重载也可以有 修改器modifier 。</p>
<p><img src="img/2-1668442760471-115.png" alt="2"></p>
<p>由此可知,当我们调用这些函数的时候,实际上是在填充CALLDATA。</p>
<p>fallback函数可以看作是备用的。</p>
<p>fallback函数:合约可以最多有一个回退函数。函数声明为： <code>fallback () external [payable]</code> 或 <code>fallback (bytes calldata input) external [payable] returns (bytes memory output)</code></p>
<p>没有　<code>function</code>　关键字。　必须是　<code>external</code>　可见性，它可以是 <code>virtual</code> 的，可以被重载也可以有 修改器modifier 。</p>
<p>如果在一个对合约调用中，没有其他函数与给定的函数标识符匹配时,fallback会被调用或者在没有receive函数时，而没有提供附加数据对合约调用，那么fallback 函数会被执行。</p>
<p><img src="img/3-1668442763706-117.png" alt="3"></p>
<pre><code class="lang-solidity">//                       is msg.data empty?
//                           /    \
//                         yes     no
//                         /         \ 
//           is receive() exists?    fallback()
//                 /         \
//               yes          no
//               /              \
//            receive()        fallback()            
</code></pre>
<p>最后转到fallback()函数时,如果合约没有定义fallback()函数就会出错。</p>
<p>我们能够添加一个receive函数帮助那些不小心调用了错误的函数的人正确调用fund函数，不然的话它们就算是转了钱也没有一个投资人的身份.</p>
<p><img src="img/4-1668442771610-119.png" alt="4"></p>
<h3 id="-">回顾</h3>
<p>receive(),fallback(),constructor()这些特殊函数不需要function关键字</p>
<p>有几个关键字从长远来看可以帮我们节省Gas费</p>
<p>constant关键字和Immutable关键字,这两个关键字修饰的变量只能在声明时更新一次，之后便不可以再修改</p>
<p>将要讲的</p>
<pre><code class="lang-solidity">//1.Enums 枚举
//2.Events 事件
//3.Try/Catch
//4.Function Selectors 函数选择器
//5.adi.encode/decode
//6.Hashing
//7.Yul/Assumbly
</code></pre>
<h2 id="5-ether-js-simple-storage-">5.Ether.js介绍(Simple Storage示例)(已)</h2>
<h3 id="how-to-debug-">How to Debug?</h3>
<p>在遇到程序报错时</p>
<ul>
<li><p>第一步是根据错误提示语句的判断,试着自己修正并找出错误原因(记得花在寻找和修正错误上面的时间不要超过20分钟,如果尝试完所有选择还没有成功的话切换到第二步);</p>
</li>
<li><p>第二步谷歌正确的错误,从其他人的案例中吸取教训,如果还无法解决的话切换到第三步;</p>
</li>
<li><p>第三步在论坛发起询问,stackoverflow更多用于一般情况的编程问题,stack exchange Ethereum用于以太坊/EVM/Solidity问题</p>
</li>
</ul>
<p><strong>在GitHub讨论区提问的格式(记得只能使用Markdown源码进行操作)在各个stack上也是这样提问</strong></p>
<p><img src="img/5-1668442776995-121.png" alt="5"></p>
<p><img src="img/6-1668442785142-123.png" alt="6"></p>
<ul>
<li><p>先贴代码</p>
</li>
<li><p>再说问题</p>
</li>
<li><p>贴上Error信息</p>
</li>
<li><p>最后说需求</p>
</li>
</ul>
<p><strong>开源互助是计算机科学人必备且最重要的素质</strong></p>
<h3 id="-">软件安全&amp;环境准备</h3>
<ul>
<li>Visual Studio Code</li>
<li>NodeJS</li>
<li>wsl</li>
</ul>
<p><img src="img/7-1668442789776-125.png" alt="7"></p>
<p><img src="img/8-1668442794030-127.png" alt="8"></p>
<p><img src="img/9-1668442798039-129.png" alt="9"></p>
<p><strong>Hardhat:智能合约开发框架(基于javascript的开发环境)</strong></p>
<p><img src="img/10-1668442802305-131.png" alt="10"></p>
<h3 id="windows-">Windows安装</h3>
<h4 id="nodejs">NodeJS</h4>
<p>Node.js是一个JavaScript运行环境,让JavaScript运行在服务端的开发平台。</p>
<p>Node.js允许我们在后端编写JavaScript代码,而不是在前端编写。</p>
<p>所以说语法上和JavaScript会有些不同</p>
<p>typescript是静态版本的JavaScript</p>
<p><strong>成功安装Node.js</strong></p>
<p><img src="img/11-1668442806446-133.png" alt="11"></p>
<h4 id="wsl">wsl</h4>
<p>我们要让我们的Windows环境更像是linux，因为linux是大多数开发的标准环境。</p>
<p>wsl代表linux的Windows子系统,它允许 linux 程序在我们的 windows 环境中本地运行.</p>
<p><strong>成功安装Ubuntu</strong></p>
<p><img src="img/12-1668442810339-135.png" alt="12"></p>
<p>成功设置用户名和密码</p>
<p><img src="img/13-1668442814606-137.png" alt="13"></p>
<p>在linux环境中编写Visual Studio代码的方式:</p>
<p>ctrl+shift+p</p>
<p><img src="img/1-1668442817704-139.png" alt="1"></p>
<p><img src="img/2-1668442820070-141.png" alt="2"></p>
<p>接着在wsl中安装nvm(包管理器)</p>
<pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash
</code></pre><p>如果显示该错误的话需要执行一行命令让该终端的命令都翻墙</p>
<pre><code>curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused
</code></pre><p>该命令是</p>
<pre><code>export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:10480
</code></pre><p>然后在wsl中安装node.js</p>
<pre><code>node --version
</code></pre><p>Gitpod:云开发环境,有点类似于Remix</p>
<h3 id="-">本地开发环境介绍</h3>
<p><strong>常用命令</strong></p>
<p>清屏函数</p>
<pre><code>clear
</code></pre><p>隐藏终端</p>
<p>ctrl+`</p>
<p>创建一个文件夹,把所有的项目都放进去。</p>
<p>hh-fcc的全称:hard hat-free code camp</p>
<pre><code>mkdir hh-fcc
</code></pre><p>切换到该文件夹下</p>
<pre><code>cd hh-fcc
</code></pre><p><img src="img/3-1668442826304-143.png" alt="3"></p>
<p><img src="img/4-1668442828698-145.png" alt="4"></p>
<p>此时打开新的终端,你将看到工作区的主目录是:</p>
<p><img src="img/5-1668442832284-147.png" alt="5"></p>
<p>提供代码高亮的插件</p>
<p><img src="img/6-1668442836396-149.png" alt="6"></p>
<p><strong>如何打开open settings？</strong></p>
<p>在设置中搜索emmet:Preferences</p>
<p>然后在settings.json中申请Solidity在VScode中的一些设置</p>
<p>我们的默认格式化程序是NomicFoundation.hardhat-solidity,这意味着任何时候我们去格式化我们的代码它将使用hardhat-solidity插件作为其默认格式化程序。</p>
<pre><code class="lang-json">   &quot;[solidity]&quot;: {
        &quot;editor.defaultFormatter&quot;: &quot;NomicFoundation.hardhat-solidity&quot;
    }
</code></pre>
<p><strong>下图对user settings进行修改,Formate On Save意味着每次我们保存时,VScode会尝试为我们格式化代码。</strong></p>
<p><img src="img/7-1668442840305-151.png" alt="7"></p>
<p>同时在下载prettier插件后也要在settings.json中申请对JavaScript的格式设置</p>
<pre><code class="lang-json">  &quot;[javascript]&quot;: {
        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
    }
</code></pre>
<h3 id="javascript-">JavaScript知识补充</h3>
<p>首先学习如何用JavaScript和node.js来运行脚本</p>
<p>我们要使用node.js来运行JavaScript代码</p>
<p><img src="img/1-1668442845213-153.png" alt="1"></p>
<p><strong>node deploy.js可以等价为 javac deploy.java</strong></p>
<pre><code class="lang-javascript">function main() {
  console.log(&quot;hi&quot;);
  let variable = 5; //等价于Solidity里面uint256 variable = 5;
  console.log(variable);
}
main();
</code></pre>
<p><strong>当我们写hardhat时要进行异步编程async</strong></p>
<h3 id="javascript-asynchronous-">JavaScript中的异步编程(asynchronous)</h3>
<p>目前为止我们做的编程都是同步的，一行接一行，每一行新的代码都是建立在前面代码的基础之上的，我们所有的Solidity编程都是同步的(只有在使用预言机时有部分异步编程)。</p>
<p><strong>异步编程可以使我们的程序在执行一个可能长期运行的任务的同时继续对其他事件做出反应而不必等待任务完成，JavaScript允许我们进行异步编程。</strong></p>
<p>函数状态是否在等待期是基于promise的(等待/实现/拒绝).pedding/fuilfile/rejected</p>
<p><strong>异步函数就是指返回值为Promise对象的函数</strong></p>
<p>在异步函数中我们可以调用其他的异步函数,使用await即可。</p>
<p><strong>异步语法</strong></p>
<p>async和await使Promise更容易编写</p>
<p>async使函数返回一个Promise</p>
<p>await使函数等待Promise,await关键字只能在async函数内部使用</p>
<p><strong>Promise是异步编程的基础,是一个由异步函数返回的可以向我们指示当前操作所处的状态的对象。</strong></p>
<p>在Promise返回给调用者的时候,操作往往还没有完成,但Promise对象可以让我们操作最终完成时对其进行处理(无论成功还是失败)。</p>
<p><strong>函数前面的关键字async使函数返回一个promise</strong></p>
<pre><code class="lang-javascript">async function myFunction(){
    return &quot;Hello&quot;;
}
------------------------------------------------------------------------------------------
//上下两个写法是等价的
------------------------------------------------------------------------------------------
function myFunction() {
    return Promise.resolve(&quot;Hello&quot;);
}
</code></pre>
<p><strong>Promise用法</strong></p>
<p><strong>调用Promise对象的then()方法并传递回调函数,如果请求成功完成,回调函数会被调起,请求的结果也会以参数的形式传递进来</strong></p>
<p>这里的() =&gt; {}是箭头表达式,相当于函数定义的简化写法。</p>
<pre><code class="lang-javascript">fetch(&quot;www.google.com&quot;).then( (response) =&gt; {} );
</code></pre>
<p>Promise可以用一种<strong>链式结构</strong>将多个异步操作串联起来,比如这里的response.json()方法也会返回一个Promise,它代表在未来的某个时刻将返回的数据转换成JSON格式,如果我们想要等这个方法完成之后再执行其他的操作,我们可以在后面追加一个then。</p>
<p>catch方法用来捕获错误,如果之前任意一个阶段发生了错误,catch将会被触发,而错误地方后面的then将不会被执行</p>
<p>finally方法在Promise链结束之后调用,无论失败与否,我们可以在这里做一些清理工作。</p>
<pre><code>fetch(&quot;www.google.com&quot;).then((response) =&gt; response.json())
                       .then((json) =&gt; console.log(json))
                       .catch((error) =&gt; {
                            console.error(error);
                            process.exit(1);
                              })
                          .finally(() =&gt; {
                              //清理工作
                          });
</code></pre><p>process.exit(1)：失败退出</p>
<p>process.exit(0)：成功退出</p>
<p><strong>await用法</strong></p>
<pre><code>let value = await promise;
</code></pre><p>await虽然看上去会暂停函数的执行,但在等待的过程中,javascript同样可以处理其他的任务,比如更新页面,运行其他的代码等等,这是因为await底层是基于Promise和事件循环机制实现的。</p>
<p>await似乎是在这异步的环境当中注入了一丝同步的血液,保证重要的函数一定能够执行。</p>
<p><strong>总结</strong></p>
<p>简而言之， async用于申明一个function是异步的；
而await则可以认为是 async await的简写形式，是等待一个异步方法执行完成的。</p>
<p>大多数我们要合作的函数都是异步的</p>
<p><strong><code>async</code>函数返回值是一个<code>Promise</code>对象，可以使用<code>.then</code>接受一个回调函数，和<code>Promise</code>的所有操作</strong></p>
<pre><code>main()
  .then(() =&gt; process.exit(0))
  .catch((error) =&gt; {
    console.error(error);
    process.exit(1);
  });
</code></pre><h3 id="-solidity">编译我们的Solidity</h3>
<h4 id="solc-js-yarn">solc.js和yarn</h4>
<p>编译Solidity还需要用到solc.js</p>
<p>因为solc.js有一种编译合约的方法,通过相对路径导入其他合约,</p>
<p>以前通过npm(npm被称为包管理器)安装</p>
<p>我们使用yarn(新的包管理器)安装</p>
<pre><code class="lang-javascript">coreapack enable//安装yarn
yarn add solc//使用yarn安装solc
yarn solcjs --help//查看solc.js允许的不同命令
</code></pre>
<p><img src="img/2-1668442859975-155.png" alt="2"></p>
<p>安装后会发现在我们的工作文件夹中添加了好几个文件</p>
<p>package.json,它告诉我们很多关于我们项目的信息和dependencies</p>
<p>yarn.lock告诉我们项目中所有不同的包确切的版本</p>
<p>node_modules文件夹是它们把刚才的代码安装在了哪里</p>
<p>接着可以尝试安装0.8.7版本Solidity对应的solc.js</p>
<pre><code>yarn add solc@0.8.7-fixed
</code></pre><h4 id="compile">compile</h4>
<p>实际编译时的编译命令</p>
<pre><code>yarn solcjs --bin --abi --include-path node_modules/ --base-path . -o . SimpleStorage.sol
//我们想要二进制文件/也想要abi/因为我们想在我们的node_modules中包含所有文件合同，所以我们没有在这个项目中使用任何文件，但是在功能中，你需要包含这个/这意味着基本路径将是这个文件夹/我们编译后的二进制和abi输出到这个文件夹中/最后是我们想要编译的合约
</code></pre><p><img src="img/3-1668442869382-157.png" alt="3"></p>
<p>scripts是一种非常有用的方法,省去了我们编译时大部分的麻烦(运行长命令变得很容易)</p>
<p><img src="img/4-1668442872537-159.png" alt="4"></p>
<h3 id="ganache-">Ganache以及网络介绍</h3>
<p>Ganache类似Remix中的虚拟机,这是一个我们可以在本地运行的假区块链用来实际测试部署和运行代码,这也是一个查看区块链中正在发生的事情的方式。</p>
<p>启动这个假区块链在本地,它带有一大堆假账户(和Remix的假帐户一样)。</p>
<p><strong>rpc代表远程过程调用,url是统一资源定位器,测试网网络中的rpc url代表与区块链节点的连接,这个url连接我们以进行api调用与区块链节点交互。区块链节点与软件一起运行,其中一些节点公布了api调用。(如果我们想运行自己真正的区块链节点而不是使用MetaMask或者任何其他供应商的话,我们可以通过第三方软件来运行url或者通过Geth搭建一条私链)</strong></p>
<p>接着我们要做的第一件事就是连接到区块链上。(Remix在连接Web3钱包或者Remix VM的时候就已经通过rpc url在幕后连接这些区块链了)</p>
<p><img src="img/5-1668442876983-161.png" alt="5"></p>
<p><strong>要注意Ethereum JSON-RPC调用的规范</strong></p>
<h3 id="ethers-js-">Ethers.js介绍</h3>
<p>ethers.js是JavaScript的一个开源库,可以与以太坊网络进行交互,其Github地址为ethers.io/ethers.js，可以访问其官方文档进行使用。</p>
<p>Ethers.js是最流行的一种基于JavaScript的工具包,这使我们能够与不同区块进行交互</p>
<p>另一个非常受欢迎的工具包是Web3.js。</p>
<p>我们使用Ether.js的原因是Ethers是为核心环境提供动力的工具。</p>
<p>安装Ethers.js</p>
<pre><code>yarn add ethers
</code></pre><p>安装fs-extra</p>
<pre><code>yarn add fs-extra
</code></pre><p><strong>deploy.js</strong></p>
<p>代码演示</p>
<pre><code class="lang-javascript">const ethers = require(&quot;ethers&quot;); //const使得ethers不能被改变,equire使我们导入ethers包的功能
const fs = require(&quot;fs-extra&quot;); //读取abi文件和二进制文件需要导入fs-extra这个包

async function main() {
  //http://127.0.0.1:7545(Ganache节点现在的端点)
  //.操作符,链式表达式
  //下面两行提供了与智能合约交互的条件
  const provider = new ethers.providers.JsonRpcProvider(
    &quot;http://127.0.0.1:7545&quot;
  ); //RPC端点我们将在这里连接到这个网址(将我们的脚本连接到区块链)
  const wallet = new ethers.Wallet(
    &quot;3f2e9c5eb37ef982f88ce1a53e2790542fd76c96bff3a7b55df0e2b46b2eb995&quot;,
    provider
  ); //提供了带私钥的钱包,可以让我们签署不同的交易
  //为了部署我们的合约,我们需要abi,编译的二进制文件,合约代码
  const abi = fs.readFileSync(&quot;./SimpleStorage_sol_SimpleStorage.abi&quot;, &quot;utf8&quot;); //这意味着我们将同步从此文件中读取abi
  const binary = fs.readFileSync(
    &quot;./SimpleStorage_sol_SimpleStorage.bin&quot;,
    &quot;utf-8&quot;
  ); //这意味着我们将同步从此文件中读取二进制编码
  const contractFactory = new ethers.ContractFactory(abi, binary, wallet); //合约工厂对象
  //通过abi我们的代码就知道如何与合约交互,二进制是我们钱包里的主要编译代码,wallet对象给了我们一个可以签名的私钥部署此合约。
  console.log(&quot;Deploying,please wait...&quot;);
  //我们实际上可以使用ethers部署这个合约
  const contract = await contractFactory.deploy(); //Stop here!Wait for contract to deploy!
  console.log(contract);
}

//调用Promise对象的then()方法并传递回调函数,如果请求成功完成,回调函数会被调起,请求的结果也会以参数的形式传递进来,process.exit(0)成功退出
//catch方法用来捕获错误,如果之前任意一个阶段发生了错误,catch将会被触发，输出错误,process.exit(1)失败退出
main()
  .then(() =&gt; process.exit(0))
  .catch((error) =&gt; {
    console.error(error);
    process.exit(1);
  });
</code></pre>
<h3 id="await-">await关键字</h3>
<pre><code>const contract = await contractFactory.deploy(); //Stop here!Wait for contract to deploy!
</code></pre><p>如果不加await的话,没有检查此部署功能是否完成,有可能整个程序都已经跑完了,我们的合约还没有部署,合约工厂自己部署的话只是返回一个promise,但是如果加上await的话,它返回一个promise然后解决合约,我们会等待它完成对合约对象部署。</p>
<h3 id="-">添加交易重写</h3>
<pre><code>//如果我们想等待合约工厂部署但有一定的Gas价格,我们可以在部署函数中重写
  const contract = await contractFactory.deploy({gasPrice: 1000000}); //Stop here!Wait for contract to deploy!
</code></pre><h3 id="-">交易收据</h3>
<pre><code class="lang-javascript"> //我们已经部署了一个合约,但是我们想等待一个区块后确定我们部署的合约在不在区块链上
  const transactionReceipt = await contract.deployTransaction.wait(1);
  console.log(&quot;Here is the deployment transaction:&quot;);
  console.log(contract.deployTransaction);
  console.log(&quot;Here is the transaction receipt:&quot;);
</code></pre>
<h3 id="-ehter-js-">通过ehter.js发送一笔“原生”交易</h3>
<p>使用纯JavaScript和纯ethers发送一笔交易</p>
<p>每次我们改变区块链的状态,data将成为差异化因素</p>
<p>签署交易代码</p>
<pre><code>  console.log(&quot;let&#39;s deploy with only transaction data&quot;);
  //这将是我们实际的部署方式,使用纯粹的交易数据发送交易
  const tx = {
    nonce: 6,
    gasPrice: 20000000000, //使用的数据都是Ganache提供的
    gasLimit: 1000000,
    to: null,
    value: 0,
    //每次发送交易我们都用二进制文件填充我们的数据对象,告诉我们的区块链如何部署我们的智能合约
    data: &quot;0x608060405234801561001057600080fd5b50610771806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80632e64cec11461005c5780636057361d1461007a5780636f760f41146100965780638bab8dd5146100b25780639e7a13ad146100e2575b600080fd5b610064610113565b604051610071919061052a565b60405180910390f35b610094600480360381019061008f919061046d565b61011c565b005b6100b060048036038101906100ab9190610411565b610126565b005b6100cc60048036038101906100c791906103c8565b6101b6565b6040516100d9919061052a565b60405180910390f35b6100fc60048036038101906100f7919061046d565b6101e4565b60405161010a929190610545565b60405180910390f35b60008054905090565b8060008190555050565b6001604051806040016040528083815260200184815250908060018154018082558091505060019003906000526020600020906002020160009091909190915060008201518160000155602082015181600101908051906020019061018c9291906102a0565b505050806002836040516101a09190610513565b9081526020016040518091039020819055505050565b6002818051602081018201805184825260208301602085012081835280955050505050506000915090505481565b600181815481106101f457600080fd5b906000526020600020906002020160009150905080600001549080600101805461021d9061063e565b80601f01602080910402602001604051908101604052809291908181526020018280546102499061063e565b80156102965780601f1061026b57610100808354040283529160200191610296565b820191906000526020600020905b81548152906001019060200180831161027957829003601f168201915b5050505050905082565b8280546102ac9061063e565b90600052602060002090601f0160209004810192826102ce5760008555610315565b82601f106102e757805160ff1916838001178555610315565b82800160010185558215610315579182015b828111156103145782518255916020019190600101906102f9565b5b5090506103229190610326565b5090565b5b8082111561033f576000816000905550600101610327565b5090565b60006103566103518461059a565b610575565b90508281526020810184848401111561037257610371610704565b5b61037d8482856105fc565b509392505050565b600082601f83011261039a576103996106ff565b5b81356103aa848260208601610343565b91505092915050565b6000813590506103c281610724565b92915050565b6000602082840312156103de576103dd61070e565b5b600082013567ffffffffffffffff8111156103fc576103fb610709565b5b61040884828501610385565b91505092915050565b600080604083850312156104285761042761070e565b5b600083013567ffffffffffffffff81111561044657610445610709565b5b61045285828601610385565b9250506020610463858286016103b3565b9150509250929050565b6000602082840312156104835761048261070e565b5b6000610491848285016103b3565b91505092915050565b60006104a5826105cb565b6104af81856105d6565b93506104bf81856020860161060b565b6104c881610713565b840191505092915050565b60006104de826105cb565b6104e881856105e7565b93506104f881856020860161060b565b80840191505092915050565b61050d816105f2565b82525050565b600061051f82846104d3565b915081905092915050565b600060208201905061053f6000830184610504565b92915050565b600060408201905061055a6000830185610504565b818103602083015261056c818461049a565b90509392505050565b600061057f610590565b905061058b8282610670565b919050565b6000604051905090565b600067ffffffffffffffff8211156105b5576105b46106d0565b5b6105be82610713565b9050602081019050919050565b600081519050919050565b600082825260208201905092915050565b600081905092915050565b6000819050919050565b82818337600083830152505050565b60005b8381101561062957808201518184015260208101905061060e565b83811115610638576000848401525b50505050565b6000600282049050600182168061065657607f821691505b6020821081141561066a576106696106a1565b5b50919050565b61067982610713565b810181811067ffffffffffffffff82111715610698576106976106d0565b5b80604052505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b61072d816105f2565b811461073857600080fd5b5056fea264697066735822122005f4761e428b272cff3be71d18d77c255fd57b725a8cec4f019c4e1beb4ada8164736f6c63430008070033&quot;,
    chainId: 31337,//注意chainId和NetworkId有可能不一致
  };
  const signedTxResponse = await wallet.signTransaction(tx); //只是签署这个交易,并没有发送
  console.log(signedTxResponse);
}
</code></pre><p>发送交易代码(首先签名,然后与合约提供者一起发送)</p>
<pre><code class="lang-javascript">  console.log(&quot;let&#39;s deploy with only transaction data&quot;);
  const nonce = await wallet.getTransactionCount(); //永远得到正确的nonce
  //这将是我们实际的部署方式,使用纯粹的交易数据发送交易
  const tx = {
    nonce: nonce, //永远得到正确的nonce
    gasPrice: 20000000000, //使用的数据都是Ganache提供的
    gasLimit: 1000000,
    to: null,
    value: 0,
    //每次发送交易我们都用二进制文件填充我们的数据对象,告诉我们的区块链如何部署我们的智能合约
    data: &quot;0x608060405234801561001057600080fd5b50610771806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80632e64cec11461005c5780636057361d1461007a5780636f760f41146100965780638bab8dd5146100b25780639e7a13ad146100e2575b600080fd5b610064610113565b604051610071919061052a565b60405180910390f35b610094600480360381019061008f919061046d565b61011c565b005b6100b060048036038101906100ab9190610411565b610126565b005b6100cc60048036038101906100c791906103c8565b6101b6565b6040516100d9919061052a565b60405180910390f35b6100fc60048036038101906100f7919061046d565b6101e4565b60405161010a929190610545565b60405180910390f35b60008054905090565b8060008190555050565b6001604051806040016040528083815260200184815250908060018154018082558091505060019003906000526020600020906002020160009091909190915060008201518160000155602082015181600101908051906020019061018c9291906102a0565b505050806002836040516101a09190610513565b9081526020016040518091039020819055505050565b6002818051602081018201805184825260208301602085012081835280955050505050506000915090505481565b600181815481106101f457600080fd5b906000526020600020906002020160009150905080600001549080600101805461021d9061063e565b80601f01602080910402602001604051908101604052809291908181526020018280546102499061063e565b80156102965780601f1061026b57610100808354040283529160200191610296565b820191906000526020600020905b81548152906001019060200180831161027957829003601f168201915b5050505050905082565b8280546102ac9061063e565b90600052602060002090601f0160209004810192826102ce5760008555610315565b82601f106102e757805160ff1916838001178555610315565b82800160010185558215610315579182015b828111156103145782518255916020019190600101906102f9565b5b5090506103229190610326565b5090565b5b8082111561033f576000816000905550600101610327565b5090565b60006103566103518461059a565b610575565b90508281526020810184848401111561037257610371610704565b5b61037d8482856105fc565b509392505050565b600082601f83011261039a576103996106ff565b5b81356103aa848260208601610343565b91505092915050565b6000813590506103c281610724565b92915050565b6000602082840312156103de576103dd61070e565b5b600082013567ffffffffffffffff8111156103fc576103fb610709565b5b61040884828501610385565b91505092915050565b600080604083850312156104285761042761070e565b5b600083013567ffffffffffffffff81111561044657610445610709565b5b61045285828601610385565b9250506020610463858286016103b3565b9150509250929050565b6000602082840312156104835761048261070e565b5b6000610491848285016103b3565b91505092915050565b60006104a5826105cb565b6104af81856105d6565b93506104bf81856020860161060b565b6104c881610713565b840191505092915050565b60006104de826105cb565b6104e881856105e7565b93506104f881856020860161060b565b80840191505092915050565b61050d816105f2565b82525050565b600061051f82846104d3565b915081905092915050565b600060208201905061053f6000830184610504565b92915050565b600060408201905061055a6000830185610504565b818103602083015261056c818461049a565b90509392505050565b600061057f610590565b905061058b8282610670565b919050565b6000604051905090565b600067ffffffffffffffff8211156105b5576105b46106d0565b5b6105be82610713565b9050602081019050919050565b600081519050919050565b600082825260208201905092915050565b600081905092915050565b6000819050919050565b82818337600083830152505050565b60005b8381101561062957808201518184015260208101905061060e565b83811115610638576000848401525b50505050565b6000600282049050600182168061065657607f821691505b6020821081141561066a576106696106a1565b5b50919050565b61067982610713565b810181811067ffffffffffffffff82111715610698576106976106d0565b5b80604052505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b61072d816105f2565b811461073857600080fd5b5056fea264697066735822122005f4761e428b272cff3be71d18d77c255fd57b725a8cec4f019c4e1beb4ada8164736f6c63430008070033&quot;,
    chainId: 1337, //注意chainId和NetworkId有可能不一致
  };
  const sentTxResponse = await wallet.sendTransaction(tx); //发送交易
  await sentTxResponse.wait(1); //等一个确认区块以确保这个交易实际通过
  console.log(sentTxResponse);
}
</code></pre>
<h3 id="-ether-js-">通过ether.js与合约交互</h3>
<p>我们将连接我们的Ganache区块链,我们要连接一个钱包,从Ganache中得到私钥,我们要抓取abi和我们合约的二进制文件,并将它们和那个钱包一起连接到一个新的合约工厂对象,这样钱包将成为实际部署的钱包,我们将使用contract部署合约,我们将等待一个区块让交易完成,但实际上我们不会使用返回的交易收据,然后我们会<strong>调用contract.retrieve()返回我们当前最喜欢的号码</strong>(这是一个视图函数,这个合约的调用不会花费我们任何汽油)。</p>
<p>部署后我们得到了BigNumber响应</p>
<pre><code>const currentFavoriteNumber = await contract.retrieve(); //contract对象是合约工厂函数返回的,contract对象将附带我们abi中描述的所有功能
console.log(currentFavoriteNumber);
</code></pre><p><img src="img/1-1668442894190-163.png" alt="1"></p>
<p>BigNumber是Ethers的应用自带的库函数,这有助于我们处理数字</p>
<p>以太坊中的许多操作都对超出JavaScript安全值范围的数字进行操作。</p>
<p>BigNumber是一个对象，<strong>它</strong>可以安全地允许对任何数量级的数字进行数学运算。</p>
<p>大多数需要返回值的操作将返回<strong>BigNumber</strong>，而接受值的参数通常会接受它们。</p>
<p>还可以使用toString方法将数字转换成字符串后再返回</p>
<pre><code> console.log(currentFavoriteNumber.toString());
</code></pre><p><img src="img/2-1668442897589-165.png" alt="2"></p>
<p>字符串插值,修饰控制台日志,用变量修饰字符串,在JavaScript中处理字符串通常用双引号,但是如果想将变量与字符串拼接,可以使用<strong>单向引号</strong>。</p>
<p>${}可以看出这是一个变量</p>
<pre><code> console.log(`Current Favorite Number:${currentFavoriteNumber.toString()}`);
</code></pre><p><img src="img/3-1668442901155-167.png" alt="3"></p>
<p>我们正在部署合约,我们得到初始值,我们将通过store来更新我们的合约(这将花费汽油),我们将获得交易响应,然后我们将获得交易收据,我们不会对交易收据做任何事情,接着我们将得到更新后的代码,然后把它打印出来。</p>
<pre><code>  //Get number
  const currentFavoriteNumber = await contract.retrieve(); //contract对象是合约工厂函数返回的,contract对象将附带我们abi中描述的所有功能
  console.log(`Current Favorite Number:${currentFavoriteNumber.toString()}`);

  const transactionResponse = await contract.store(&quot;7&quot;); //最好的方法是传递变量时把数字换成字符串
  await transactionResponse.wait(1); //等待一个区块
  const updatedFavoriteNumber = await contract.retrieve(); //返回更新后的数字
  console.log(`Update favorite number is: ${updatedFavoriteNumber}`);
</code></pre><p><img src="img/4-1668442908360-169.png" alt="4"></p>
<h3 id="-">环境变量</h3>
<p>区块链网络,私钥这些信息如果直接放在代码里的话容易暴露隐私,我们可以利用环境变量来解决这个问题</p>
<p>创建一个.env文件来储存这些敏感信息</p>
<p>这个env文件将粘贴我们选择的变量进入我们代码的环境</p>
<p>.env文件内部</p>
<p><img src="img/6-1668442912095-171.png" alt="6"></p>
<p>在我们的deploy.js中把环境变量粘贴进去</p>
<p>先安装一个dotenv让这些变得简单</p>
<pre><code>yarn add dotenv
</code></pre><p>Dotenv 是一个零依赖模块，它将环境变量从<code>.env</code>文件加载到<code>process.env</code>,这将引入我们所有的环境变量</p>
<pre><code class="lang-js">require(&quot;dotenv&quot;).config;
</code></pre>
<p>修改后的钱包</p>
<pre><code class="lang-javascript">const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider); //提供了带私钥的钱包,可以让我们签署不同的交易
</code></pre>
<p>修改后的区块链URL</p>
<pre><code>  const provider = new ethers.providers.JsonRpcProvider(process.env.RPC_URL); //RPC端点我们将在这里连接到这个网址(将我们的脚本连接到区块链)
</code></pre><p>每当我们有一个项目时,我们都会创建一个.gitignore文件,在这里我们要放置.env,node_mdoules。</p>
<p>这意味着我们不会将这些文件推送到Github中,在推送的时候只会推送一些示例文件。</p>
<p><img src="img/5-1668442917386-173.png" alt="5"></p>
<h3 id="-">加强私钥保密管理</h3>
<p>如果说把私钥放在.env文件当中还是不放心的话,可以在终端部署时把私钥和url作为环境变量临时输入进去</p>
<p><img src="img/7-1668442921062-175.png" alt="7"></p>
<p>如何加强私钥的管理呢?
首先,我们将创建一个名为encrytptKey.js的新文件。</p>
<p>这里面将是我们实际用于加密密钥的代码,并将密钥存储在本地而不是我们的纯文本密钥。</p>
<pre><code class="lang-javascript">const ethers = require(&quot;ethers&quot;);
const fs = require(&quot;fs-extra&quot;);
require(&quot;dotenv&quot;).config();

async function main() {
  const wallet = new ethers.Wallet(process.env.PRIVATE_KEY); //创建钱包
  const encryptedJsonKey = await wallet.encrypt(
    process.env.PRIVATE_KEY_PASSWORD,
    process.env.PRIVATE_KEY
  ); //返回值可以在本地存储,而且我们只能用密码解密,这个函数需要两个参数,私钥密码和私钥。

  console.log(encryptedJsonKey);
  fs.writeFileSync(&quot;./.encryptedKey.json&quot;, encryptedJsonKey); //保存这个加密后的私钥到一个名为encryptedKey.json的新文件中

}

main()
  .then(() =&gt; process.exit(0))
  .catch((error) =&gt; {
    console.error(error);
    process.exit(1);
  });
</code></pre>
<p><img src="img/8-1668442925990-177.png" alt="8"></p>
<p>crypto是这个密钥的加密版本;如果有黑客进入我们的帐户然后看到了这个crypto,他们必须知道密码用来解密这个私钥,</p>
<p>然后将保存加密私钥的文件也写入.gitignore里面</p>
<p>然后就可以在.env文件中删除我们的私钥和私钥密码了，因为加密后的密钥都存储在了新生成的encryptedKey.json这个文件中</p>
<p>然后重新编写我们的deploy.js</p>
<pre><code class="lang-javascript">const ethers = require(&quot;ethers&quot;); //const使得ethers不能被改变,equire使我们导入ethers包的功能
const fs = require(&quot;fs-extra&quot;); //读取abi文件和二进制文件需要导入fs-extra这个包
require(&quot;dotenv&quot;).config(); //现在我们可以在JavaScript中访问环境变量

async function main() {
  //http://127.0.0.1:7545(Ganache节点现在的端点)
  //.操作符,链式表达式
  //下面两行提供了与智能合约交互的条件
  const provider = new ethers.providers.JsonRpcProvider(process.env.RPC_URL); //RPC端点我们将在这里连接到这个网址(将我们的脚本连接到区块链)
  // const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider); //提供了带私钥的钱包,可以让我们签署不同的交易
  const encryptedJson = fs.readFileSync(&quot;./.encryptedKey.json&quot;, &quot;utf8&quot;); //同步从此文件中读取私钥
  let wallet = new ethers.Wallet.fromEncryptedJsonSync(
    encryptedJson,
    process.env.PRIVATE_KEY_PASSWORD
  ); //创建钱包,并将钱包和私钥连接
  wallet = await wallet.connect(provider);//将钱包和provider连接

  //为了部署我们的合约,我们需要abi,编译的二进制文件,合约代码
  const abi = fs.readFileSync(&quot;./SimpleStorage_sol_SimpleStorage.abi&quot;, &quot;utf8&quot;); //这意味着我们将同步从此文件中读取abi
  const binary = fs.readFileSync(
    &quot;./SimpleStorage_sol_SimpleStorage.bin&quot;,
    &quot;utf-8&quot;
  ); //这意味着我们将同步从此文件中读取二进制编码
  const contractFactory = new ethers.ContractFactory(abi, binary, wallet); //合约工厂对象
  //通过abi我们的代码就知道如何与合约交互,二进制是我们钱包里的主要编译代码,wallet对象给了我们一个可以签名的私钥部署此合约。
  console.log(&quot;Deploying,please wait...&quot;);
  //我们实际上可以使用ethers部署这个合约
  const contract = await contractFactory.deploy(); //Stop here!Wait for contract to deploy!
  //我们已经部署了一个合约,但是我们想等待一个区块后确定我们部署的合约在不在区块链上
  await contract.deployTransaction.wait(1);
  //Get number
  const currentFavoriteNumber = await contract.retrieve(); //contract对象是合约工厂函数返回的,contract对象将附带我们abi中描述的所有功能
  console.log(`Current Favorite Number:${currentFavoriteNumber.toString()}`);

  const transactionResponse = await contract.store(&quot;7&quot;); //最好的方法是传递变量时把数字换成字符串
  await transactionResponse.wait(1); //等待一个区块
  const updatedFavoriteNumber = await contract.retrieve(); //返回更新后的数字
  console.log(`Update favorite number is: ${updatedFavoriteNumber}`);
}

//调用Promise对象的then()方法并传递回调函数,如果请求成功完成,回调函数会被调起,请求的结果也会以参数的形式传递进来,process.exit(0)成功退出
//catch方法用来捕获错误,如果之前任意一个阶段发生了错误,catch将会被触发，输出错误,process.exit(1)失败退出
main()
  .then(() =&gt; process.exit(0))
  .catch((error) =&gt; {
    console.error(error);
    process.exit(1);
  });
</code></pre>
<p><strong>接着再部署合约的时候就只需要输入密码就可以了</strong></p>
<pre><code class="lang-javascript">PRIVATE_KEY_PASSWORD=password node deply.js 
</code></pre>
<p>此时哪怕黑客没有密码也无法使用你的账户了,但是有一点需要注意的是端口处由我们的调用历史,可以查到我们的密码,需要把调用历史删掉后才算是万无一失。</p>
<pre><code>history
</code></pre><p><img src="img/9-1668442935979-179.png" alt="9"></p>
<pre><code>history -c //清除调用历史
</code></pre><p><strong>总结</strong></p>
<p>上述的方法实际上只是最低限度的一些用于加密和保存你的私钥的方式</p>
<h3 id="-">代码格式</h3>
<p>我们的VScode代码格式是由于部署了插件,如果我们把代码发给别人,但是他们没有部署和我们相同的插件该怎么办？</p>
<p>将Prettier插件安装在我们的项目文件夹内就可以了.</p>
<pre><code>yarn add prettier prettier-plugin-solidity
</code></pre><p>在项目文件中建立.prettierrc脚本文件</p>
<p>该格式文件的优先级要高于默认格式文件</p>
<p>prettrier的配置参考</p>
<p><img src="img/10-1668442940704-181.png" alt="10"></p>
<p>然后就是我们所有的开源仓库都需要写一个README.md作为大纲。</p>
<p><img src="img/11-1668442944126-183.png" alt="11"></p>
<p>Ctrl+shift+v可以预览整个Markdown文档。</p>
<p><img src="img/12-1668442950966-185.png" alt="12"></p>
<h3 id="-">在测试网和主网上部署合约</h3>
<p>我们可能需要一个测试网url和测试网私钥</p>
<p>我们将使用第三方rpc和url</p>
<p>alchemy有一个节点允许我们连接到任何它们支持的区块链(QuickNode/Moralis/Ethereum也都有这样的服务),我们在这里使用alcemy。</p>
<p><img src="img/13-1668442954524-187.png" alt="13"></p>
<p>接着使用复制来的Goerli测试网的http链接去替换.env环境配置文件中的URL；Goerli测试网的私钥从MetaMusk中导出后也到.env文件当中去进行替换</p>
<pre><code>PRIVATE_KEY=86e9942743b459aad40008f3b98ed284bc1275bfd85ad84bbb9f10294bb65cba
RPC_URL=https://eth-goerli.g.alchemy.com/v2/lAj5SUwXbY6jQlIl9FWy2fheSYmdCIDL
</code></pre><p>在部署时我们会发现比以前的耗时更长,因为测试网和主网需要等待区块传播,打包交易等</p>
<p><img src="img/14-1668442957832-189.png" alt="14"></p>
<p>在终端当中如果一些命令正在执行的时候你想要中断它，你需要Ctrl+c。</p>
<p>在区块链浏览器中可以通过address查询到两笔交易,一笔交易是合约的创建,另一笔交易是调用了store函数。</p>
<p><img src="img/15-1668442961081-191.png" alt="15"></p>
<p>rpc_url就像马路,私钥就像汽车</p>
<p>如果想在主网部署的话,方法是一样的。</p>
<h3 id="-">通过浏览器验证和发布合约</h3>
<p><img src="img/16-1668442964325-193.png" alt="16"></p>
<p>浏览器基本上只适用一些很简单明了的代码</p>
<p>如何直接通过代码编辑器来验证我们所有的代码,这个过程很容易部署到evm链上,在alchemy中,我们可以轻松地创建一个新的应用程序并改变它的网络(如果我们想切换链我们只需要切换rpc_url并切换私钥)。</p>
<h3 id="alchemy-">Alchemy控制面板和交易池</h3>
<p>当我们使用Alchemy提交交易的时候,幕后发生了什么？</p>
<p>Alchemy可以为正在发生的交易提供可视化窗口,以便我们调试</p>
<p><img src="img/17-1668442972017-195.png" alt="17"></p>
<p>内存池就像机场的候机室一样,内存池中的交易有着不同的状态,MINED是成功的交易,DROPPED&amp;REPLACED是被丢弃和替换的交易，PENDING是待定的交易。</p>
<p>区块链是由节点网络运行的,每个节点和每台运行该节点的计算机维护区块链的副本,作为开发人员我们必须使用这些向区块链发出请求的节点(Alchemy这样的rpc提供程序)，每个节点除了拥有整个副本,区块链状态也有一个本地交易的内存(这就是所谓的内存池)</p>
<p><img src="img/18-1668442975606-197.png" alt="18"></p>
<h3 id="-">回顾</h3>
<p>首先我们学习了如何创建新项目(node deploy.js）,我们已经了解了node关键字的作用以及应该如何使用node关键字在我们的本地开发环境中运行JavaScript,我们知道我们可以添加不同的外部依赖通过yarn或者npm打包到我们的本地包中(package.json),这些依赖文件安装在node_mulder文件夹中,我们还可以在package.json中创建一个script部分来最小化我们需要运行的长命令(例如compile关键字)--yarn compile；</p>
<p>然后我们学习了JavaScript脚本的基本设置,我们在顶部导入我们的包,我们在底部有一些主要的执行器功能(相当于try-catch) ，在中间有我们的主要功能，我们使用async关键字以便我们的函数可以使用异步编程，我们可以使用await关键字(这基本意味着等待这个承诺完成它的事情)，使用RPC_URL连接到任何我们想要的区块链中之后我们就可以连接我们的provider到钱包或者私钥(这些都是ethers.js包里的方法)，ehers包可以让我们更容易地在JavaScript中与区块链交互。
我们还了解到我们可以加密我们的私钥,这样即使我们的电脑被黑了,我们的私钥不是以纯文本形式存在的，我们已经学会了如何从我们的加密密钥运行脚本，我们还学会了如何获得abi或应用程序二进制接口，在我们代码的二进制文件中部署到区块链。</p>
<p>我们已经学会了如何部署我们的合约,以编程方式连接到区块链。然后我们学会了如何以编程方式与我们的合约交互(store,retrieve)。</p>
<p>我们还学会了如何在settings.json中添加默认格式编辑器，我们也学会了如何覆盖这些设置(.prettierrc)，这样我们就可以自动格式化我们的代码让它看起来更好看并且更容易阅读</p>
<p>最后我们学习了如何部署这些合约到真实的测试网或者真实的网络,学会了手动方式去验证和发布我们的合约源代码。</p>
<p>我们学到了很多捷径和方法让这一切变得容易一点。</p>
<h3 id="typescript">Typescript</h3>
<p>Typescript是JavaScript类型的超集,它可以编译成纯JavaScript。</p>
<p>安装typescript(搭建node端typescript开发环境)</p>
<pre><code>yarn add typescript ts-node
</code></pre><p>然后我们就可以尝试 ts-node deploy.ts</p>
<p>添加模块fs-extra的声明文件,我们需要添加它们的types版本</p>
<pre><code>yarn add @types/fs-extra
</code></pre><p>把导包修改后这时候再去部署这两个文件可以得到与之前完全相同的拟合配置</p>
<p><img src="img/19-1668442981306-199.png" alt="19"></p>
<p><img src="img/20-1668442985064-201.png" alt="20"></p>
<p><strong>deploy.js</strong></p>
<pre><code class="lang-javascript">const ethers = require(&quot;ethers&quot;) //const使得ethers不能被改变,equire使我们导入ethers包的功能
const fs = require(&quot;fs-extra&quot;) //读取abi文件和二进制文件需要导入fs-extra这个包
require(&quot;dotenv&quot;).config() //现在我们可以在JavaScript中访问环境变量

async function main() {
    //http://127.0.0.1:7545(Ganache节点现在的端点)
    //.操作符,链式表达式
    //下面两行提供了与智能合约交互的条件
    const provider = new ethers.providers.JsonRpcProvider(process.env.RPC_URL) //RPC端点我们将在这里连接到这个网址(将我们的脚本连接到区块链)
    const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider) //提供了带私钥的钱包,可以让我们签署不同的交易
    //为了部署我们的合约,我们需要abi,编译的二进制文件,合约代码
    const abi = fs.readFileSync(&quot;./SimpleStorage_sol_SimpleStorage.abi&quot;, &quot;utf8&quot;) //这意味着我们将同步从此文件中读取abi
    const binary = fs.readFileSync(
        &quot;./SimpleStorage_sol_SimpleStorage.bin&quot;,
        &quot;utf-8&quot;
    ) //这意味着我们将同步从此文件中读取二进制编码
    const contractFactory = new ethers.ContractFactory(abi, binary, wallet) //合约工厂对象
    //通过abi我们的代码就知道如何与合约交互,二进制是我们钱包里的主要编译代码,wallet对象给了我们一个可以签名的私钥部署此合约。
    console.log(&quot;Deploying,please wait...&quot;)
    //我们实际上可以使用ethers部署这个合约
    const contract = await contractFactory.deploy() //Stop here!Wait for contract to deploy!
    //我们已经部署了一个合约,但是我们想等待一个区块后确定我们部署的合约在不在区块链上
    await contract.deployTransaction.wait(1)
    console.log(`Contract Address:${contract.address}`)
    //Get number
    const currentFavoriteNumber = await contract.retrieve() //contract对象是合约工厂函数返回的,contract对象将附带我们abi中描述的所有功能
    console.log(`Current Favorite Number:${currentFavoriteNumber.toString()}`)

    const transactionResponse = await contract.store(&quot;7&quot;) //最好的方法是传递变量时把数字换成字符串
    await transactionResponse.wait(1) //等待一个区块
    const updatedFavoriteNumber = await contract.retrieve() //返回更新后的数字
    console.log(`Update favorite number is: ${updatedFavoriteNumber}`)
}

//调用Promise对象的then()方法并传递回调函数,如果请求成功完成,回调函数会被调起,请求的结果也会以参数的形式传递进来,process.exit(0)成功退出
//catch方法用来捕获错误,如果之前任意一个阶段发生了错误,catch将会被触发，输出错误,process.exit(1)失败退出
main()
    .then(() =&gt; process.exit(0))
    .catch((error) =&gt; {
        console.error(error)
        process.exit(1)
    })
</code></pre>
<p><strong>encryptKey.js</strong></p>
<pre><code class="lang-javascript">const ethers = require(&quot;ethers&quot;)
const fs = require(&quot;fs-extra&quot;)
require(&quot;dotenv&quot;).config()

async function main() {
    const wallet = new ethers.Wallet(process.env.PRIVATE_KEY) //创建钱包
    const encryptedJsonKey = await wallet.encrypt(
        process.env.PRIVATE_KEY_PASSWORD,
        process.env.PRIVATE_KEY
    ) //返回值可以在本地存储,而且我们只能用密码解密,这个函数需要两个参数,私钥密码和私钥。

    console.log(encryptedJsonKey)
    fs.writeFileSync(&quot;./.encryptedKey.json&quot;, encryptedJsonKey) //保存这个加密后的私钥到一个名为encryptedKey.json的新文件中
}

main()
    .then(() =&gt; process.exit(0))
    .catch((error) =&gt; {
        console.error(error)
        process.exit(1)
    })
</code></pre>
<p><strong>package.json</strong></p>
<pre><code class="lang-json">{
    &quot;dependencies&quot;: {
        &quot;@types/fs-extra&quot;: &quot;^9.0.13&quot;,
        &quot;dotenv&quot;: &quot;^16.0.3&quot;,
        &quot;ethers&quot;: &quot;^5.7.2&quot;,
        &quot;fs-extra&quot;: &quot;^10.1.0&quot;,
        &quot;prettier&quot;: &quot;^2.7.1&quot;,
        &quot;prettier-plugin-solidity&quot;: &quot;^1.0.0-beta.24&quot;,
        &quot;solc&quot;: &quot;0.8.7-fixed&quot;,
        &quot;ts-node&quot;: &quot;^10.9.1&quot;,
        &quot;typescript&quot;: &quot;^4.8.4&quot;
    },
    &quot;scripts&quot;: {
        &quot;compile&quot;: &quot;yarn solcjs --bin --abi --include-path node_modules/ --base-path . -o . SimpleStorage.sol&quot;
    }
}
</code></pre>
<p><strong>.env</strong></p>
<pre><code>PRIVATE_KEY=86e9942743b459aad40008f3b98ed284bc1275bfd85ad84bbb9f10294bb65cba
RPC_URL=https://eth-goerli.g.alchemy.com/v2/lAj5SUwXbY6jQlIl9FWy2fheSYmdCIDL
</code></pre><h2 id="6-hardhat-simple-storage-">6.Hardhat介绍(Simple Storage示例)(已)</h2>
<p>我们使用ethers的Simple Storage部署合约可能需要大量代码，但是我们还是有很多功能没有做,例如我们没有保存合约的部署位置,所以我们每次都要手动去记忆address(而不是以编程的方式添加它),我们还需要建立自己的测试功能,我们如果想让项目成为一个跨链的应用程序的话，我们需要的不仅仅是一个私钥，rpc或者url。</p>
<p>上述的这些缺失的功能就是Harthat发挥作用的地方</p>
<p>Hardhat几乎是目前最流行最先进的智能合约开发框架之一,它被很多大宗使用(例如Aave,Uniswap,SushiSwap等)</p>
<p>Hardhat，这是一种有助于在以太坊上构建的开发环境。它可以帮助开发人员管理和自动化构建智能合约和 dApp 过程中固有的重复性任务，并且它允许您围绕此工作流程轻松引入更多功能。这意味着在核心进行编译和测试。</p>
<p>Hardhat 还内置了 Hardhat Network，这是一个专为开发而设计的本地以太坊网络。它允许您部署合约、运行测试和调试代码。</p>
<p><img src="img/21-1668442993109-203.png" alt="21"></p>
<p><img src="img/22-1668442996170-205.png" alt="22"></p>
<p><strong>首先把Github上的代码拉下来</strong></p>
<pre><code>git clone https://github.com/PatrickAlphaC/hardhat-simple-storage-fcc
</code></pre><p>拉代码时如果报错的话就用git配置代理(本机代理端口是7890)</p>
<pre><code>git config --global http.https://github.com.proxy http://127.0.0.1:7890
</code></pre><p>代码拉取成功</p>
<p><img src="img/23-1668443001451-207.png" alt="23"></p>
<p>这种拉取下来的代码只能作为备份。</p>
<p>让我们使用Hardhat创建下一个项目!!!hardhat- simple-storage-fcc</p>
<h3 id="hardhat-">Hardhat 安装</h3>
<p>准备工作</p>
<p><img src="img/24-1668443004305-209.png" alt="24"></p>
<p>在此文件夹中初始化一个新项目init</p>
<p>系统会给我们设置一些问题</p>
<p>并且多次回车给这个新项目设置信息</p>
<p><img src="img/25-1668443032366-211.png" alt="25"></p>
<p>现在可以安装安全帽了</p>
<pre><code>yarn add --dev hardhat@2.9.3
</code></pre><p><strong>到目前为止无论我们的包名名是什么我们都运行yarn add *</strong> 来安装,但是有很多时候我们都是yarn add --dev  *来安装**</p>
<p><strong>主要原因在于前一个方式安装的包需要运行我们的项目,后一个方式安装的包只需要开发，大多数情况下我们所做的安装都是yarn add --dev。</strong></p>
<p> 当我们看见npx的时候,都可以用yarn代替npx</p>
<p>接着在安装Hardhat的同一目录下运行该代码</p>
<pre><code>yarn hardhat
</code></pre><p>我们会被提示是否开始创建一个Hardhat项目</p>
<p>选择创建basic hardhat项目</p>
<p>确定创建.gitignore文件</p>
<p>确定使用yarn安装依赖</p>
<p><strong>该项目的预装情况</strong></p>
<p> <img src="img/27-1668443037803-213.png" alt="27"></p>
<p>contract文件夹下安装了Greeter.sol,是一个简约的合约</p>
<p>node_modules文件夹下都是我们安装的JavaScript依赖</p>
<p>我们会发现有些依赖的包前方会有@前缀，这种包被称作“作用域包”，它有效地允许 NPM 包/yarn包被命名。NPM/yarn 上的每个用户和组织都有自己的范围，并且他们是唯一可以向其中添加包的人。</p>
<ul>
<li>它允许组织明确哪些软件包是“官方的”，哪些不是。<ul>
<li>例如，如果一个包有 scope <code>@angular</code>，你就知道它是由 Angular 核心团队发布的。</li>
</ul>
</li>
</ul>
<p>scipts文件夹是这将是我们添加我们想要编写的任何脚本的地方(比如部署与合约交互的版本等)</p>
<p>test文件夹为我们提供了一个简约的测试，用于测试我们的智能合约</p>
<p>.gitignore预先填充了需要被Github所忽略的一些重要的事情,例如.env和node_modules(文件太大了有可能无法推送到Github中)</p>
<p>最大的变化就是这里添加了harthat.config.js,这里可以认为是我们编写的所有脚本的入口点，这是配置文件，决定了我们的其余代码将如何与区块链工作和互动</p>
<p>然后就是放置依赖信息的package.json和大纲阅读README.md了</p>
<h3 id="hardhat-">Hardhat配置常见问题</h3>
<p>1.如果我们想要再创建一次hardhat项目时,运行yarn hardhat命令出现帮助文档的问题,这通常只是意味着你有一个配置文件在它不应该在的地方,删除它就会摆脱这种问题,我们需要运行命令npx hardhat --verbose来找到这个配置文件的位置，删除此配置文件后,再次输入yarn hardhat命令就会显示hardhat的创建界面。</p>
<p>2.“npm install”命令等价于&quot;yarn&quot;</p>
<h3 id="-hardhat">继续配置Hardhat</h3>
<p>这是一些主要的我们可以用hardhat运行的任务</p>
<p><img src="img/1-1668443045984-215.png" alt="1"></p>
<p>不同的任务需要我们通过hardhat的不同命令去运行。</p>
<p>例如 yarn hardhat accounts命令将打印出虚假账户列表(和Ganache中使用的虚假账户列表相同)</p>
<p><strong>yarn hardhat compile命令可以编译我们的合约，编译后我们会得到一个cache文件夹，cache文件夹下的文件将是访问solidity文件的快速方法；还会得到一个artifacts文件夹这个文件夹包含我们编译的代码的所有信息。</strong></p>
<h3 id="-hardhat-simple-storage">通过Hardhat部署Simple Storage</h3>
<p>首先第一步是重写contracts文件夹下的合约为Simple Storage</p>
<p>然后运行yarn hardhat compile命令,报错后手动更改hardhat.config.js中solidity编译器的版本使得最终成功编译</p>
<p>接下来我们需要在scripts文件夹下编写deploy.js脚本，部署脚本的样式和Ether中的部署脚本类似</p>
<p>运行我们的yarn add --dev prettier prettier-plugin-solidity命令用更好的格式化模板覆盖prettier插件</p>
<p>创建.prettierignore告诉prettier不要格式化某些文件</p>
<p>编写完deploy.js脚本后运行yarn hardhat run scripts/deploy.js命令</p>
<pre><code class="lang-js">//import
//如果是导入外置的ethers包的话,外置的包无法找到contracts文件夹,更无法找到我们已经编写好的SimpleStorage合约,只能通过abi,二进制文件,wallet来部署
const { ethers } = require(&quot;hardhat&quot;) //导入hardhat内置的ethers

//async mian
async function main() {
    const SimpleStorageFactory = await ethers.getContractFactory(
        &quot;SimpleStorage&quot;
    ) //使用hardhat内置的ethers可以立即获得合约工厂对象
    console.log(&quot;Deploying contract...&quot;)
    const simpleStorage = await SimpleStorageFactory.deploy() //部署这个合约
    await simpleStorage.deployed() //等待合约部署完成
    //没有私钥没有rpc_url能部署成功吗?答案是可以的
    console.log(`Deployed contract to: ${simpleStorage.address}`)
}

//main
main()
    .then(() =&gt; process.exit(0))
    .catch((error) =&gt; {
        console.error(error)
        process.exit(1)
    })
</code></pre>
<p><img src="img/2-1668443056404-217.png" alt="2"></p>
<h3 id="hardhat-">Hardhat网络</h3>
<p>Hardhat中内置了hardhat网络，这是一个专为开发而设计的本地以太坊网络节点。它允许您在本地机器范围内部署合约、运行测试和调试代码。它是连接到的默认网络 Hardhat，因此您无需进行任何设置即可使其正常工作。只需运行您的测试。</p>
<p>这个Hardhat网络与Ganache非常相似</p>
<p>在hardhat.config.js中我们可以在module.exports中添加有关默认网络的更多信息</p>
<p>这个Hardhat网络自动附带rpc,url,私钥，这就是使用Hardhat工作的优势之一。</p>
<p>我们在运行脚本指令的时候可以指定网络</p>
<p><img src="img/3-1668443059557-219.png" alt="3"></p>
<p>我们切换默认网络的话直接在hardhat.config.js中修改即可</p>
<pre><code>const GOERLI_RPC_URL = process.env.GOERLI_RPC_URL
const PRIVATE_KEY = process.env.PRIVATE_KEY

module.exports = {
    defaulyNetwork: &quot;hardhat&quot;,
    networks: {
        goerli: {
            url: GOERLI_RPC_URL,
            account: [PRIVATE_KEY],
            chainId: 5,
        },
    },
    solidity: &quot;0.8.8&quot;,
}
</code></pre><p>添加dotenv以便于让我们可以在js中访问环境变量</p>
<pre><code>yarn add --dev dotenv
</code></pre><p>每一个单独的EVM基础网络都有一个新的chain id。</p>
<p>在Goerli测试网上面部署合约</p>
<pre><code>yarn hardhat run scripts/deploy.js --network goerli
</code></pre><p>运行后会发现出错了</p>
<p><img src="img/4-1668443068542-221.png" alt="4"></p>
<p>应该把上述js中的account改为accounts</p>
<p><img src="img/5-1668443071720-223.png" alt="5"></p>
<h3 id="-">代码方式验证合约</h3>
<p>之前在Ethers中都是使用浏览器来验证合约,在Hardhat中可以添加一些代码在我们部署合约后立即自动验证。</p>
<p>Ethers scan浏览器上的AIP文档，我们可以通过这些api验证我们的合约，我们甚至可以自己制作原生api进行调用验证。</p>
<p>Hardhat是一个可扩展的框架,我们可以向其中添加插件，验证合约我们需要添加hardhat-etherscan这个插件使得验证过程变得容易。</p>
<p>此插件可帮助您验证 Solidity 合约的源代码<a href="https://etherscan.io/">以太扫描</a>.</p>
<p>它很聪明，它会尽可能地促进这个过程：</p>
<ul>
<li>只需提供部署地址和构造函数参数，插件将在本地检测要验证的合约。</li>
<li>如果你的合约使用 Solidity 库，插件会自动检测并处理它们。你不需要对它们做任何事情。</li>
<li>验证过程的模拟将在本地运行，允许插件检测和传达过程中的任何错误。</li>
<li>模拟成功后，将使用 Etherscan API 验证合约。</li>
</ul>
<p>运行yarn add --dev @nomiclabs/hardhat-etherscan命令安装hardhat-etherscan插件。</p>
<p>安装后需要在hardhat.config.js文件中导入此插件。</p>
<p>同时我们需要在环境变量当中写入在Ethers scan浏览器中创建的API密钥。</p>
<pre><code class="lang-javascript">require(&quot;@nomiclabs/hardhat-waffle&quot;)
require(&quot;dotenv&quot;).config() //启用dotenv配置
require(&quot;@nomiclabs/hardhat-etherscan&quot;) //启用hard-etherscan插件用来验证合约

// This is a sample Hardhat task. To learn how to create your own go to
// https://hardhat.org/guides/create-task.html
task(&quot;accounts&quot;, &quot;Prints the list of accounts&quot;, async (taskArgs, hre) =&gt; {
    const accounts = await hre.ethers.getSigners()

    for (const account of accounts) {
        console.log(account.address)
    }
})

// You need to export an object to set up your config
// Go to https://hardhat.org/config/ to learn more

/**
 * @type import(&#39;hardhat/config&#39;).HardhatUserConfig
 */
const GOERLI_RPC_URL = process.env.GOERLI_RPC_URL
const PRIVATE_KEY = process.env.PRIVATE_KEY
const ETHERSCAN_API_KEY = process.env.ETHERSCAN_API_KEY

module.exports = {
    defaulyNetwork: &quot;hardhat&quot;,
    networks: {
        goerli: {
            url: GOERLI_RPC_URL,
            accounts: [PRIVATE_KEY],
            chainId: 5,
        },
    },
    solidity: &quot;0.8.8&quot;,
    etherscan: {
        apiKey: ETHERSCAN_API_KEY,
    },
}
</code></pre>
<p>在hardhat.config.js文件中编写完成后,我们就获得了验证合约的能力</p>
<p>运行命令yarn hardhat</p>
<p><img src="img/6-1668443078677-225.png" alt="6"></p>
<p>当我们运行Hardhat,hardhat就去查看配置文件并检查导入的插件,如果有新插件,它会把它们添加为我们可以执行的新任务。</p>
<p><strong>示例:</strong></p>
<p>这是命令行的操作,我们要构建的是代码的操作</p>
<p>运行<code>verify</code>任务，传递合约的地址、部署它的网络以及用于部署它的构造函数参数（如果有）</p>
<pre><code>yarn hardhat verify --network mainnet DEPLOYED_CONTRACT_ADDRESS &quot;Constructor argument 1&quot;
</code></pre><p>在deploy.js代码中构造验证函数</p>
<pre><code class="lang-js">//import
//如果是导入外置的ethers包的话,外置的包无法找到contracts文件夹,更无法找到我们已经编写好的SimpleStorage合约,只能通过abi,二进制文件,wallet来部署
const { ethers, run, network } = require(&quot;hardhat&quot;) //导入hardhat内置的ethers,导入hardhat内置的run允许我们运行任何hardhat任务,导入hardhat网络配置信息

//async mian
async function main() {
    const SimpleStorageFactory = await ethers.getContractFactory(
        &quot;SimpleStorage&quot;
    ) //使用hardhat内置的ethers可以立即获得合约工厂对象
    console.log(&quot;Deploying contract...&quot;)
    const simpleStorage = await SimpleStorageFactory.deploy() //部署这个合约
    await simpleStorage.deployed() //等待合约部署完成
    //没有私钥没有rpc_url能部署成功吗?答案是可以的
    console.log(`Deployed contract to: ${simpleStorage.address}`)
    //当我们把合约部署到我们的hardhat网络时不需要到Ether scan这样的区块链浏览器上面进行验证
    //hardhat运行时的环境是我们机器本地的区块链网络,所以我们验证在Ether scan上部署的hardhat网络合约是没有意义的
    //所以当我们使用本地网络时我们实际上不想调用验证函数
    //故当我们在测试网或主网上部署合约的时候我们的验证函数便有了用武之地
    // console.log(network.config)//输出hardhat本地网络的配置信息,本地网络的chainid是31337
    //我们可以使用chainid去计算哪个是测试网,哪个是主网
    //&amp;&amp;的后者没有判断条件是如何工作的呢?
    //JavaScript中,如果一个对象存在并且你尝试将其转换为布尔值,它将被转换成true;如果这个对象不存在的话,它将被转换成false
    if (network.config.chainId === 5 &amp;&amp; process.env.ETHERSCAN_API_KEY) {
        //我们最好等待几个区块再实际运行验证过程,因为这些区块链浏览器在我们部署合约的时候可能还不知道这个交易(交易未发送到区块链上)
        console.log(&quot;Waiting for block txes...&quot;)
        await simpleStorage.deployTransaction.wait(6)
        await verify(simpleStorage.address, []) //地址和构造函数参数,调用此方法来实际验证我们的合约
    }

    //开始与合约进行交互
    const currentValue = await simpleStorage.retrieve() //通过retrieve函数获得我们最喜欢的号码
    console.log(`Current Value is:${currentValue}`)

    //Update the current value
    const transactionReponse = await simpleStorage.store(7) //通过store函数更新我们最喜欢的号码,默认初始化为0
    await transactionReponse.wait(1) //等待一个区块,让上述交易通过
    const updateValue = await simpleStorage.retrieve() //获得更新后的号码
    console.log(`Update Value is:${updateValue}`)
}

//验证函数
//当.sol文件中有构造函数时,参数将被填充
//此自动验证过程适用于像Ether scan这样的区块链浏览器
async function verify(contractAddress, args) {
    console.log(&quot;Verifying contract...&quot;)
    //我们需要添加一个try-catch,因为在实践中经常出现运行时等待这样的错误
    //下面的e将有可能是我们抛出的任何错误
    try {
        //hardhat包中的run方法,并且传递了一个verify命令。
        //我们可以传递验证参数(故在这里采用冒号验证)---第一个参数
        //第二个参数进入内部运行,这将是实际参数的列表
        await run(&quot;verify:verify&quot;, {
            address: contractAddress,
            constructorArguments: args,
        })
    } catch (e) {
        //如果这个合约已经在Etherscan上验证过,则抛出一个错误并输出提示信息而不影响部署流程
        if (e.message.toLowerCase().includes(&quot;already verified&quot;)) {
            console.log(&quot;Already Verified!&quot;)
        }
        //如果出现任何问题,那我们就输出错误,然后进行下一次验证,避免验证中断
        else {
            console.log(e)
        }
    }
}

//main
main()
    .then(() =&gt; process.exit(0))
    .catch((error) =&gt; {
        console.error(error)
        process.exit(1)
    })
// 4 == 4 ture
// 4 == &quot;4&quot; true
// 4 === &quot;4&quot; false

//部署我们的合约(如果我们在测试网上,它会验证我们的合约);然后我们与合约交互,将值更新为7,下方写着我们的验证函数,以及对主函数的调用
</code></pre>
<h3 id="-hardhat-">通过Hardhat与合约交互</h3>
<pre><code>//开始与合约进行交互
    const currentValue = await simpleStorage.retrieve() //通过retrieve函数获得我们最喜欢的号码
    console.log(`Current Value is:${currentValue}`)

    //Update the current value
    const transactionReponse = await simpleStorage.store(7) //通过store函数更新我们最喜欢的号码,默认初始化为0
    await transactionReponse.wait(1) //等待一个区块,让上述交易通过
    const updateValue = await simpleStorage.retrieve() //获得更新后的号码
    console.log(`Update Value is:${updateValue}`)
</code></pre><h3 id="artifacts-">Artifacts常见问题</h3>
<p><img src="img/7-1668443085222-227.png" alt="7"></p>
<p>补救措施:</p>
<p>删除我们的artifacts文件夹和cache文件夹后重新运行上述命令合约部署成功/有可能出现连接超时错误</p>
<p>出现连接超时错误的话需要在hardhat.config.js文件中进行如下配置同时将clash的代理模式改为规则并开启TUN模式</p>
<p><img src="img/9-1668443087999-229.png" alt="9"></p>
<p><img src="img/10-1668443091936-231.png" alt="10"></p>
<p>部署并验证成功</p>
<p><img src="img/8-1668443105323-233.png" alt="8"></p>
<h3 id="-hardhat-">自定义Hardhat任务</h3>
<p>我们可以用Hardhat编写自己的任务，可以直接在hardhat.config.js中编写；但是人们一般都是在项目当中创建一个新的tasks文件夹，将所有自定义的任务放在里面。</p>
<p>任务通过task()函数来创建,并通过setAction()函数来设置任务的执行函数,其中taskArgs是一个包含所有参数的对象,hre是一个HardhatRuntimeEnvironment对象，可以用来获取其他的资源</p>
<p>新任务:block-number.js</p>
<pre><code>//我们用这个任务来得到我们使用的任何区块链的当前区块号
const { task } = require(&quot;hardhat/config&quot;) //导入harthat配置中的任务函数

//定义函数
//&quot;名字&quot;,&quot;描述&quot;
//1.我们通过使用 .添加命令 将参数传递给任务
//2.我们设置动作,定义任务实际上应该做什么
task(&quot;block-number&quot;, &quot;Prints the current block number&quot;).setAction(
    //空白的任务参数,hre(Hardhat运行时环境) =&gt; hre可以访问很多导入过harhat的包
    //这种定义是JavaScript中的arrow(箭头)函数,也就是匿名函数
    //相当于不使用function关键字来定义函数
    async (taskArgs, hre) =&gt; {
        //就像从hardhat导入ethers一样
        const blockNumber = await hre.ethers.provider.getBlockNumber()
        console.log(`Current block number:${blockNumber}`)
    }
)

//为了让配置文件导入成功,我们添加一个导出模块
module.exports = {}
</code></pre><p>写好后需要将它添加到hardhat.config.js文件中</p>
<pre><code>require(&quot;./tasks/block-number&quot;) //自定义任务
</code></pre><p>使用新方法,我们自己的方法!!!</p>
<p><img src="img/11-1668443111272-235.png" alt="11"></p>
<p>现在我们既可以通过脚本与合约交互,还可以通过任务与合约交互。</p>
<p><strong>任务的交互对于特定用例来说非常好,但是脚本还是主流中的主流。</strong></p>
<p><strong>任务更适合插件,脚本更适合自己本地开发环境。</strong></p>
<h3 id="hardhat-">Hardhat本地节点</h3>
<p>hardhat网络是一个空白区块链,每次我们的脚本完成时它都会被销毁。</p>
<p>每次我们在Hardhat本地网络上发送交易时,它都会重置,以至于一个合约中涉及多项交易的时候,我们没办法进行交互。</p>
<p>现在有一种方法,让我们在运行Hardhat网络就像在Ganache上运行一样。</p>
<p>首先运行命令</p>
<pre><code>yarn hardhat node
</code></pre><p><strong>启动hardhat网络节点</strong>后,新建一个终端部署合约。</p>
<p><img src="img/12-1668443119124-237.png" alt="12"></p>
<p>但此时查看hardhat网络节点,账户上没有ETH的消耗,就好像没有任何交易通过一样。</p>
<p>我们本地的主机(本地的网络节点)使用的是Hardhat的运行环境而不是Hardhat的网络.</p>
<p>所以我们实际可以向Hardhat.config.js添加一个新的网络来与之交互</p>
<p><strong>localhost的url可以从我们运行yarn hardhat node命令的终端输出中得到。</strong></p>
<p><img src="img/2-1668443122205-239.png" alt="2"></p>
<p>添加好后,先启动hardhat节点,然后再通过本地网络部署合约</p>
<p><img src="img/1-1668443126076-241.png" alt="1"></p>
<p>而且此时Hardhat节点的末尾有一些日志记录的输出</p>
<p><img src="img/3-1668443129382-243.png" alt="3"></p>
<h3 id="hardhat-">Hardhat控制台</h3>
<p>除了通过代码与链/合约进行交互外,我们还可以通过Hardhat Console来调试项目，查看链状态，合约的输入输出等</p>
<p>控制台是一个JavaScript环境,让我们运行JavaScript命令与任何区块链交互</p>
<pre><code>yarn hardhat console --network localhost
</code></pre><p><img src="img/4-1668443135270-245.png" alt="4"></p>
<p>在这个shell中,我们可以做我们在deploy.js中所做的一切,我们甚至不用再写各种的导入代码(因为hardhat把各种配置都自动导入我们的控制台当中)</p>
<p>例如:我想要得到SimpleStorageFactory对象并用其来部署合约</p>
<p><img src="img/5-1668443139534-247.png" alt="5"></p>
<p>此时hardhat的节点末尾也有一些日志记录的输出</p>
<p><img src="img/6-1668443142517-249.png" alt="6"></p>
<p>此控制台适用于任何网络，<strong>是快速测试合约并与合约交互的好方法</strong></p>
<h3 id="-">运行测试</h3>
<p>对于智能合约来说,其大多数操作都需要部署上链，与资产交互，消耗gas，且一旦有安全隐患会造成严重的后果。因此，我们需要对智能合约进行详细的测试。</p>
<pre><code>yarn hardhat clean
</code></pre><p>该命令将删除artificats文件夹并清理cache文件夹下的内容。</p>
<p>运行测试是用程序化的方法确保我们的代码的功能正是我们想要它做的，尤其是在Defi和去中心化的世界里,我们所有的代码都将是开源的。</p>
<p>运行测试是我们在面临黑客攻击的第一道防线</p>
<p>在test文件夹下书写我们的运行测试脚本</p>
<p>Hardhat运行测试适用于Mocha框架(这是一个基于JavaScript的框架运行我们的测试)</p>
<p>运行测试脚本既可以用Solidity语言编写(尽可能接近代码)也可以用JavaScript语言编写(有更多的灵活性来做更多的事情交互和测试你的智能合约)</p>
<p>我们在这里使用JavaScript语言来编写测试脚本</p>
<pre><code>const { ethers } = require(&quot;hardhat&quot;) //导入hardhat内置的ethers
const { expect, assert } = require(&quot;chai&quot;) //导入依赖包chai的两个关键字

//describe是一个关键字,它需要两个参数(hardhat和mocha都可以使用该关键字)
// describe(&quot;SimpleSorage&quot;, () =&gt; {}) 上下两种写法一样
//需要一个字符串和一个匿名函数
describe(&quot;SimpleSorage&quot;, function () {
    // let simpleStorageFactory //将它初始化为空
    // let simpleStorage
    let simpleStorageFactory, simpleStorage //将它们初始化为空

    //该函数会告诉我们在每个it()前/我们的测试框架在每次测试前需要做什么
    beforEach(async function () {
        //在这里,我们需要部署我们的SimpleStorage合约,以至于我们每次测试的时候都能有一份全新的合约与我们的每一项测试进行交互
        simpleStorageFactory = await ethers.getContractFactory(&quot;SimpleStorage&quot;)
        simpleStorage = await simpleStorageFactory.deploy()
        //我们的“simpleStorage”和“simpleStorageFactory”对象的范围仅限于 beforeeach 内部，
        //我们实际上需要将这些变量粘贴到 beforeeach 之外，以便我们所有的 it() 都可以与它们交互。
        //因此，我们不是让“simpleStorage”和“simpleStorageFactory”成为常量变量，而是使用 let 关键字在beforeeach之外定义它们
    })

    //it()函数将是我们实际编码的地方
    //需要先写需要测试什么的字符串,然后添加async函数
    it(&quot;应该从favroiteNumber 0 开始&quot;, async function () {
        const currentValue = await simpleStorage.retrieve() //现在检查当前值是否确实为0
        const expectedValue = &quot;0&quot; //期望当前值为0
        //assert和expect这两个关键字来自chai这个依赖包中
        assert.equal(currentValue.toString(), expectedValue)//布尔表达式,两参数相等返回true,不相等返回false
        // expect(currentValue.toString()).to.equal(expectedValue) 上下两个语句作用相同
    })

    it(&quot;当我们调用store函数时应该更新favoriteNumber&quot;, async function () {
        const expectedValue = &quot;7&quot; //我们期待当我们调用store函数时它更新为7
        const transactionResponse = await simpleStorage.store(expectedValue) //把期待值传递给store函数
        await transactionResponse.wait(1) //等待一个区块

        const currentValue = await simpleStorage.retrieve() //获取更新后的当前值
        assert.equal(currentValue.toString(), expectedValue) //布尔表达式,两参数相等返回true,不相等返回false
    })

    //嵌套describe用于分离和模块化我们的测试
    // describe(&quot;something&quot;, () =&gt; {
    //     beforEach()

    //     it()
    //     it()
    //     it()
    // } )
})
</code></pre><p>编写好后使用该命令运行此测试脚本</p>
<pre><code>yarn hardhat test
</code></pre><p><img src="img/7-1668443152958-251.png" alt="7"></p>
<p><img src="img/8-1668443156216-253.png" alt="8"></p>
<pre><code>yarn hardhat test --grep store//可以运行特定测试,只需要把测试主体字符串的关键词写到grep后面即可
</code></pre><p>或者还可以在it后添加<strong>only关键字</strong>,这时候运行yarn hardhat test也就只是运行特定测试了</p>
<pre><code>it.only(&quot;当我们调用store函数时应该更新favoriteNumber&quot;, async function () {
        const expectedValue = &quot;7&quot; //我们期待当我们调用store函数时它更新为7
        const transactionResponse = await simpleStorage.store(expectedValue) //把期待值传递给store函数
        await transactionResponse.wait(1) //等待一个区块

        const currentValue = await simpleStorage.retrieve() //获取更新后的当前值
        assert.equal(currentValue.toString(), expectedValue) //布尔表达式,两参数相等返回true,不相等返回false
    })
</code></pre><h3 id="hardhat-gas-reporter">Hardhat Gas Reporter</h3>
<p><code>hardhat-gas-reporter</code>是hardhat的一个插件，专门用于查看每个测试函数所消耗的gas费用，</p>
<p>使用下面的命令安装此插件</p>
<pre><code>yarn add hardhat-gas-reporter --dev
</code></pre><p>安装此插件后到hardhat.config.js中添加一些参数</p>
<pre><code>require(&quot;@nomiclabs/hardhat-waffle&quot;)
require(&quot;hardhat-deploy&quot;)
require(&quot;dotenv&quot;).config() //启用dotenv配置
require(&quot;@nomiclabs/hardhat-etherscan&quot;) //启用hard-etherscan插件用来验证合约
require(&quot;./tasks/block-number&quot;) //自定义任务
require(&quot;hardhat-gas-reporter&quot;) //添加记录Gas费的插件

// You need to export an object to set up your config
// Go to https://hardhat.org/config/ to learn more

/**
 * @type import(&#39;hardhat/config&#39;).HardhatUserConfig
 */
const GOERLI_RPC_URL = process.env.GOERLI_RPC_URL
const PRIVATE_KEY = process.env.PRIVATE_KEY
const ETHERSCAN_API_KEY = process.env.ETHERSCAN_API_KEY

module.exports = {
    defaulyNetwork: &quot;hardhat&quot;,
    networks: {
        goerli: {
            url: GOERLI_RPC_URL,
            accounts: [PRIVATE_KEY],
            chainId: 5,
        },
        localhost: {
            //我们运行hardhat节点的终端输出
            url: &quot;http://127.0.0.1:8545/&quot;,
            //acoutns:hardhat已经为我们提供了账户
            //即使本地网络和Harhdht网络不同,但二者仍有相同的chainId
            chainId: 31337,
        },
    },
    solidity: &quot;0.8.8&quot;,
    etherscan: {
        apiKey: ETHERSCAN_API_KEY,
        customChains: [
            {
                network: &quot;goerli&quot;,
                chainId: 5,
                urls: {
                    apiURL: &quot;http://api-goerli.etherscan.io/api&quot;, //https =&gt; http
                    browserURL: &quot;http://goerli.etherscan.io&quot;,
                },
            },
        ],
    },
    gasReporter: {
        enable: true, //在我们运行测试时让这个插件运行
    },
}
</code></pre><p>接着在运行测试时就会出现如下的Gas费记录</p>
<p><img src="img/9-1668443162870-255.png" alt="9"></p>
<p>然后我们把这个记录以文件的形式输出出来</p>
<pre><code class="lang-js">require(&quot;@nomiclabs/hardhat-waffle&quot;)
require(&quot;hardhat-deploy&quot;)
require(&quot;dotenv&quot;).config() //启用dotenv配置
require(&quot;@nomiclabs/hardhat-etherscan&quot;) //启用hard-etherscan插件用来验证合约
require(&quot;./tasks/block-number&quot;) //自定义任务
require(&quot;hardhat-gas-reporter&quot;) //添加记录Gas费的插件

// You need to export an object to set up your config
// Go to https://hardhat.org/config/ to learn more

/**
 * @type import(&#39;hardhat/config&#39;).HardhatUserConfig
 */
const GOERLI_RPC_URL = process.env.GOERLI_RPC_URL
const PRIVATE_KEY = process.env.PRIVATE_KEY
const ETHERSCAN_API_KEY = process.env.ETHERSCAN_API_KEY
const COINMARKETCAP_API_KEY = process.env.COINMARKETCAP_API_KEY

module.exports = {
    defaulyNetwork: &quot;hardhat&quot;,
    networks: {
        goerli: {
            url: GOERLI_RPC_URL,
            accounts: [PRIVATE_KEY],
            chainId: 5,
        },
        localhost: {
            //我们运行hardhat节点的终端输出
            url: &quot;http://127.0.0.1:8545/&quot;,
            //acoutns:hardhat已经为我们提供了账户
            //即使本地网络和Harhdht网络不同,但二者仍有相同的chainId
            chainId: 31337,
        },
    },
    solidity: &quot;0.8.8&quot;,
    etherscan: {
        apiKey: ETHERSCAN_API_KEY,
        customChains: [
            {
                network: &quot;goerli&quot;,
                chainId: 5,
                urls: {
                    apiURL: &quot;http://api-goerli.etherscan.io/api&quot;, //https =&gt; http
                    browserURL: &quot;http://goerli.etherscan.io&quot;,
                },
            },
        ],
    },
    gasReporter: {
        enable: true, //在我们运行测试时让这个插件运行
        outputFile: &quot;gas-report.txt&quot;, //把Gas费的消耗输出到一个文件中
        noColors: true, //当我们输出到文件时,颜色基本上会弄乱,所以直接不设置颜色了
        currency: &quot;USD&quot;, //添加货币,这样我们就可以得到以美元所计的函数Gas费成本
        coinmarketcap: COINMARKETCAP_API_KEY, //为了获得货币我们需要得到来自货币市值的API密钥(就像那次获得Ether scan密钥一样)
    },
}
</code></pre>
<p><img src="img/10-1668443168127-257.png" alt="10"></p>
<h3 id="solidity-coverage">Solidity Coverage</h3>
<p>合约测试对于保障业务逻辑正确性与安全防范至关重要，因此，我们需要对合约进行覆盖率测试。HardHat 也有一个solidity-coverage插件，可以很方便地输出覆盖率情况(测试中覆盖了多少行我们的.sol 代码)。</p>
<p>首先安装该插件</p>
<pre><code>yarn add --dev solidity-coverage 
</code></pre><p>然后导入配置并添加一些参数</p>
<p>最终的运行效果为</p>
<p><img src="img/11-1668443171589-259.png" alt="11"></p>
<p><strong>在这期间有可能会出现报错,可以更换hardhat版本为该插件推荐的版本来解决。</strong></p>
<p><img src="img/12-1668443181315-261.png" alt="12"></p>
<p>可以在安装插件的日志里查看其推荐的版本</p>
<p><img src="img/13-1668443184361-263.png" alt="13"></p>
<h3 id="hardhat-waffle">Hardhat Waffle</h3>
<p>用于与Waffle框架集成的Hardhat插件</p>
<p>您可以使用此插件在 Hardhat 中使用 Waffle 构建智能合约测试，充分利用两者。</p>
<p>这个插件在 Hardhat Runtime Environment 中添加了一个 Hardhat-ready 版本的 Waffle，并自动初始化[Waffle Chai 匹配器]</p>
<h3 id="-">回顾</h3>
<p>我们学习了如何启动我们自己的Hardhat项目，使用yarn hardhat查看任务列表和我们可以使用hardhat做的不同事情；hardhat.config.js是我们运行的任何以hardhat开头的任务的入口点；我们可以把我们的.sol文件添加到contracts文件夹,我们可以使用yarn hardhat compile命令编译我们的合约文件,编译后我们会得到一个cache文件夹，cache文件夹下的文件将是访问solidity文件的快速方法，还会得到一个artifacts文件夹这个文件夹包含我们编译的代码的所有信息(我们可以使用yarn hardhat clean命令来清除这两个文件夹的全部内容)；我们可以使用脚本或任务来实际部署并且与我们的智能合约交互(任务是针对插件的,脚本适用于我们本地的开发模式)；</p>
<p>我们了解到我们可以从hardhat中导入很多东西,任务到我们的脚本文件中，我们可以使用async函数来获取我们的合约并部署它们，并且可以摆脱浏览器而是使用编程的方式验证它们(使用hardhat和hardhat插件)写了一个验证的函数，并且与合约交互的过程和Ethers时使用的很相似。</p>
<p>我们写了一个自定义的任务，一个运行测试脚本(运行测试是非常重要的,在真正专业的环境中,测试会起到决定性作用)，每当得到一个新项目的时候，第一件事去读README.md，第二件事就是去看测试脚本。</p>
<p>我们学到了更多的环境变量，我们还学会了Gas reporter和Coverage来验证我们的运行测试脚本的Gas费花销和测试代码的覆盖率。</p>
<p>我们学到了很多Hardhat配置的知识,以及我们如何添加多个网络到我们的Hardhat中,这样就可以使我们的EVM代码适用于任何网络</p>
<p>我们现在是在和dev 依赖合作而不是原来的常规依赖(常规依赖需要运行我们的项目，dev依赖只需要开发)</p>
<p>README.md有模板、</p>
<h3 id="typescript">typescript</h3>
<p>谁使用typescipt去编程才学这一节,不强制</p>
<pre><code>yarn add @typechain/ethers-v5 @typechain/hardhat @types/chai @types/node @types/mocha ts-node typechaintypescript
</code></pre><p>把所有的js转换成ts</p>
<h2 id="7-hardhat-fund-me-">7.使用Hardhat完成Fund Me智能合约(已)</h2>
<h3 id="hardhat-">Hardhat 配置</h3>
<pre><code>yarn add --dev hardhat@2.9.3
</code></pre><pre><code>yarn hardhat
</code></pre><p>如果说再有什么操作诡异报错的话,就安装最新的hardhat,老版本只是用它的模板文件</p>
<p>这次选择高级示例项目</p>
<p><img src="img/14-1668443189449-265.png" alt="14"></p>
<p>高级示例项目中有:</p>
<p>contract文件夹下安装了Greeter.sol,是一个简约的合约</p>
<p>node_modules文件夹下都是我们安装的JavaScript依赖</p>
<p>我们会发现有些依赖的包前方会有@前缀，这种包被称作“作用域包”，它有效地允许 NPM 包/yarn包被命名。NPM/yarn 上的每个用户和组织都有自己的范围，并且他们是唯一可以向其中添加包的人。</p>
<ul>
<li>它允许开发团队明确哪些软件包是“官方的”，哪些不是。<ul>
<li>例如，如果一个包有 scope <code>@angular</code>，你就知道它是由 Angular 核心团队发布的。</li>
</ul>
</li>
</ul>
<p>scipts文件夹是这将是我们添加我们想要编写的任何脚本的地方(比如部署与合约交互的版本等)</p>
<p>test文件夹为我们提供了一个简约的测试，用于测试我们的智能合约</p>
<p>自带了一个.env.example文件，.eslintignore文件，.eslintrc.js文件(这两个eslint可以删除)</p>
<p><strong>Eslint被称为JavaScript linter,它可以帮助我们自动找到并修复代码中的问题</strong></p>
<p>.gitignore预先填充了需要被Github所忽略的一些重要的事情,例如.env和node_modules(文件太大了有可能无法推送到Github中)</p>
<p>.npmignore有助于忽略文件,推动你的项目成为一个npm包(可以删除)</p>
<p>harthat.config.js,这里可以认为是我们编写的所有脚本的入口点，这是配置文件，决定了我们的其余代码将如何与区块链工作和互动</p>
<p>自带robston网络，gas reporter和etherscan包</p>
<p>deploy.js(可以删除)</p>
<p>然后就是放置依赖信息的package.json和大纲阅读README.md了</p>
<p>还附带了.solhint.json和.solhintignore</p>
<h3 id="linting">Linting</h3>
<p>solhint被称为Solidity linter</p>
<p>我们可以用它来整理我们的代码，Linting是运行程序的过程，该程序将分析代码以查找潜在错误，它还经常进行一些格式化。</p>
<p>ESLint是一种lint JavaScript代码的方法；solhint是一种lint Solidity代码的方法</p>
<p>我们使用.prettierrc来格式化我们的代码,.solhint来整理我们的代码，他们经常互换使用。</p>
<pre><code>yarn solhint contracts/*.sol //整理我们的Solidity代码
</code></pre><p>这是一种很好的方法，可以检查我们代码的最佳实践</p>
<h3 id="-hardhat">继续配置Hardhat</h3>
<p>把FundMe.sol和PriceConverter.sol导入到convert文件夹中，然后我们把配置文件当中的solidity版本修改一下即可</p>
<h3 id="-npm-">从NPM导入</h3>
<p>因为在Remix里面,我们直接从 npm 和 github 往合约中导入chainlink,但在我们的本地代码中我们必须具体告诉hardhat从哪里得到这个chainlink</p>
<p>我们可以专门从npm中下载@chainlink/contracts也可以采用yarn命令来下载它</p>
<pre><code>yarn add --dev @chainlink/contracts
</code></pre><p>运行后我们可以在node_modules文件夹下看到@chainlink文件夹</p>
<p>此时我们可以运行</p>
<pre><code>yarn hardhat compile
</code></pre><p><img src="img/15-1668443196617-267.png" alt="15"></p>
<h3 id="hardhat-deploy">Hardhat-deploy</h3>
<p>在这之前我们都是通过编写deploy.js脚本来手动部署合约,但是随着我们的项目越来越复杂,这种方法变得不够方便，如果我们只使用deploy.js的话,它不会将我们的部署保存到任何文件中，另外在部署脚本中包含用于部署的所有内容无法使测试和部署脚本完全协同工作(一次只能部署一个脚本文件)</p>
<p>我们实际上将使用hardhat-deploy包来替代以前的手动部署和其他的一些事情。使用这种方式部署后会在本地生成deployments文件夹。</p>
<p>运行以下命令安装这个包</p>
<pre><code>yarn add --dev hardhat-deploy 
</code></pre><p>下载后还需要到hardhat.config.js文件中进行声明</p>
<p>然后我们要创建一个deploy文件夹,这将是我们编写脚本的地方.</p>
<p>因为我们将在我们的包中使用ethers.js,所以需要往我们的包中添加hardhat-deploy-ethers</p>
<p>运行以下命令进行添加</p>
<pre><code>yarn add --dev @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers
</code></pre><p>这就像ethers的一个超集一样,将使ethers能够跟踪并记住我们合约中所有不同的部署。</p>
<p>hardhat deploy的工作方式是将所有脚本添加到我们的部署文件夹中，当我们运行命令时我们会一并运行。</p>
<p>所以最好给脚本文件编号(按照你理想中的运行顺序进行编号)</p>
<pre><code>// 1.import
// 2.main function
// 3.calling of main function
// 这是以前的布置,使用hardhat-deploy不需要后两步了
// 当我们运行hardhat-deply,hadhat-deply实际上会调用我们在这个脚本中指定的函数

const { getNamedAccounts, network } = require(&quot;hardhat&quot;)

//我们将导出这个deployFunc()作为我们hardhat-deploy的默认函数
// function deployFunc(hre) {
//     console.log(&quot;Hi!&quot;)
//     hre.getNamedAccounts()
//     hre.deployments
// }

// module.exports.default = deployFunc//这里为什么不能有小括号呢?

//我们将使用匿名异步函数
//我们将以hardhat运行时的环境作为参数(hre)
//我们将导出这个匿名函数作为我们hardhat-deploy的默认函数
// module.exports = async (hre) =&gt; {
//     //我们只使用hre中的两个变量
//     const { getNamedAccounts, deployments } = hre //拉取hre中的具体变量
//     //这和hre.getNamedAccounts以及hre.deployments有点像
// }
//上述是未使用语法糖时的语法
module.exports = async ({ getNamedAccounts, deployments }) =&gt; {
    //我们可以使用deployments对象获得两个函数
    const { deploy, log } = deployments //从deployments拉取这两个函数
    const { deployer } = await getNamedAccounts() //从getNamedAccounts()拉取deployer函数
    //getNameAccounts函数是让我们获得NameAccounts的方法,当我们使用ethers时我们是根据号码在每个网络的accounts部分来获取我们的accounts
    const chainId = network.config.chainId //获取我们的chainId
}
</code></pre><h3 id="mockinghelper-hardhat-config">Mocking&amp;helper-hardhat-config</h3>
<p>在修补和摆弄这些合约时,我们一般在本地完成所有测试后，把测试网作为部署的最后一站(或者我们可以将它部署到一个测试中，以查看一些非常具体的代码工作，例如:使用chainlink文档。所以理想情况下，我们首先将它部署到本地网络)</p>
<p><img src="img/1-1668443202977-269.png" alt="1"></p>
<p>但是如果我们部署到hardhat网络时，hardhat网络是一个空白区块链,每次我们的脚本完成时它都会被销毁。即使我们使用的是localhost这样的本地节点这个喂价合约仍然将不会存在，这个代码不会进行数据更新</p>
<h4 id="mocking">Mocking</h4>
<p><strong>在MetaMask调用合约时,会模拟执行一次,如果调用失败,会提前显示失败并问你是否要强制执行。Mock实现的就是类似的功能</strong></p>
<p>Mocking主要用于单元测试(Uint test)。被测对象可能依赖于其他（复杂）对象。为了隔离您要测试的对象的行为，您可以用模拟真实对象行为的模拟替换其他对象。如果将真实对象合并到单元测试中是不切实际的，这将很有用。</p>
<p>简而言之，Mocking就是创建模拟真实对象行为的对象。</p>
<p><strong>在这里我们只模拟喂价合约</strong></p>
<p><strong>我们想做一个在本地工作时我们可以使用并且可以控制的假的喂价合约。</strong></p>
<p>重构我们原来的合约代码</p>
<blockquote>
<p>我们对priceFeedAddress进行参数化并将其与构造函数一起传递,那样可以作为全局变量保存为AggregatorV3Interface类型;</p>
<p>并将priceFeed传递给getConversionRate函数和getPrice函数</p>
<p>然后getPrice函数中只调用最新的一轮数据</p>
<pre><code>(, int256 price, , , ) = priceFeed.latestRoundData(); //相当于返回最新一轮数据的价格
</code></pre></blockquote>
<p>现在我们传递什么样的priceFeedAddress取决于我们所在的网络</p>
<p><strong>FundMe.sol</strong></p>
<pre><code class="lang-solidity">//希望从用户那里获得资金
//用户可以取回自己的钱
//把计量货币最小值换成美元

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;

import &quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&quot;;
import &quot;./PriceConverter.sol&quot;;

//794743
contract FundMe {
    using PriceConverter for uint256;

    uint256 public constant MINIMUM_USD = 50 * 1e18; // 1 * 10^18

    //当有人把钱寄到这个合约上时,我们想要追踪所有寄给我们的钱
    //让我们创建一个名为资助者的地址数组
    address[] public funders;

    //地址到uint256的映射
    //资助者地址到资助金额的映射
    mapping(address =&gt; uint256) public addressToAmountFunded;

    //设置一些参数,以便只有合约的所有者可以调用withdraw函数
    address public immutable i_owner;

    //创建一个聚合器对象作为全局变量,命名为喂价,这个合约地址的对象拥有聚合器接口的全部功能
    AggregatorV3Interface public priceFeed;

    //构造函数,在同一个交易中立即调用。
    //我们可以让构造函数接受参数,我们可能的参数之一是喂价的地址
    //当我们现在部署我们的合约时,我们会依据它部署的区块链来传递相应的喂价地址
    constructor(address priceFeedAddress) {
        i_owner = msg.sender;
        priceFeed = AggregatorV3Interface(priceFeedAddress); //现在的喂价就变得很灵活了(现在的问题是我们怎么抓住喂价的地址)
    }

    function fund() public payable {
        //0.想要把计量货币最小值换成美元
        //1.我们怎么把以太坊发给这个合约
        //通过使用全局关键字之一(msg.value)得到某人发送了多少value
        //假设我们希望人们在每个交易中至少发送一个完整的以太,我们会像下面这样设置它
        //这个require关键字是一个检查器,如果msg.value &lt;= 1e18，它会发送错误日志并还原
        //还原的意思是说当它撤销之前发生的任何操作后,并将剩余的汽油费送回

        //msg.value被认为是这些库函数的第一个参数变量,第二个参数将是我们的喂价
        require(
            msg.value.getConversionRate(priceFeed) &gt;= MINIMUM_USD,
            &quot;Didn&#39;t send enough&quot;
        ); //1e18 == 1 * 10^18 ==(1 * 10^18 Wei == 1 ETH) &quot;&quot;引号里面不能填写汉字

        //msg.value有18位小数位,代表多少以太坊/发送了多少原生区块链代币
        //只要有人给我们寄钱,并且满足检查器要求时,我们会把资助者加到数组里
        funders.push(msg.sender); //msg.sender是一个始终可用的全局关键字,代表调用fund函数的人的地址,把地址加到资助者数组里
        //当有人资助我们的合约时,地址=&gt;资助金额
        addressToAmountFunded[msg.sender] = msg.value;
    }

    //资助者通过这个函数从合约中撤回所有资金
    function withdraw() public onlyOwner {
        //继续循环投资者数组然后更新映射对象
        /*starting index, ending index, step amount */
        //重置映射
        for (
            uint256 funderIndex = 0;
            funderIndex &lt; funders.length;
            funderIndex++
        ) {
            address funder = funders[funderIndex]; //这个会返回一个供我们使用的地址,一个资助者地址可以看作一个资质者
            addressToAmountFunded[funder] = 0; //当我们从合同中把钱取走时,要把映射重置为0,新的key-value对的key是funder
        }
        //重置数组
        funders = new address[](0); //funders变量现在等于一个全新的里面没有对象的地址数组
        //提取资金
        //call是Solidity中的一个低级命令,这个调用函数实际上非常强大,我们可以用它来调用以太坊中几乎所有的功能(甚至不需要ABI)
        (bool callSuccess, ) = payable(msg.sender).call{
            value: address(this).balance
        }(&quot;&quot;); //&quot;&quot;号里可以填任何函数信息,或者想在其他合约中调用的函数的信息;如果不想调用函数的话就可以什么都不填
        //call允许我们调用不同的函数,如果该函数返回一些数据或值,我们会把它保存在dataReturned变量中,因为bytes对象是数组,返回的数据需要在内存中,故用memory修饰。
        require(callSuccess, &quot;Call failed&quot;);
    }

    //修改器将是一个我们可以添加在函数声明中用来修改函数功能的关键字
    modifier onlyOwner() {
        // 必须是合约所有者才能真正地调用取钱函数
        require(msg.sender == i_owner, &quot;Sender is not i_owner!&quot;);
        _; //在函数声明中,对于取款函数,在阅读其他代码之前,先过来阅读onlyOwner修改器代码,先执行检查器代码,然后做下划线上的事,这个下划线表示执行剩下的代码。
    }

    receive() external payable {
        fund();
    }

    fallback() external payable {
        fund();
    }
}
</code></pre>
<p><strong>PriceConverter.sol</strong></p>
<pre><code class="lang-solidity">//SPDX-License-Identifier:MIT

pragma solidity ^0.8.0;

import &quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&quot;;

library PriceConverter {
    //用该函数来计算以美元为单位时,代币的理论价格
    //为了获取价格一定要使用Chainlink喂价来获取定价信息
    function getPrice(AggregatorV3Interface priceFeed)
        internal
        view
        returns (uint256)
    {
        //引入项目外合约里的价格函数
        //因为这是我们在与项目之外的合约进行交互,所以我们需要两样东西(之前的交互都是使用import)
        //1.合约的ABI 通过编译聚合器V3接口合约,我们能得到ABI
        //2.合约的地址address     ETH/USD:0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e
        //创建一个聚合器对象,命名为喂价,这个合约地址的对象是否拥有聚合器接口的全部功能?
        // AggregatorV3Interface priceFeed = AggregatorV3Interface(
        //     0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e
        // ); //创建此对象后向chainlink报告说这是一个接口对象这是一个接口对象，它被编译成 abi。如果您将 abi 与地址匹配，您将获得可以与之交互的合约。

        //调用函数,获取最新一轮的价格,由于这个函数返回一大堆不同的变量,故需要设置返回值,但是这些变量里我们只关注价格,把其他变量去掉只留下逗号
        (, int256 price, , , ) = priceFeed.latestRoundData(); //相当于返回最新一轮数据的价格
        //上述函数返回的是按美元计算的ETH的价格
        //AggregatorV3Interface合约有一个小数(decimals)函数,它会告诉你在喂价中有多少个小数位.
        //解决小数点问题
        return uint256(price * 1e10); //1 * 10^10 == 10000000000//因为msg.value是uint256类型的,获取的定价也应是uint256类型的
        //18-10=8位小数?

        //(uint80 roundId,int price,uint startedAt,uint timeStamp,uint80 answeredInRound) = priceFeed.latestRoundData();
    }

    //用该函数来获取转换率
    function getConversionRate(
        uint256 ethAmount,
        AggregatorV3Interface priceFeed
    ) internal view returns (uint256) {
        //调用新创建的getPrice函数来为自变量赋值
        uint256 ethPrice = getPrice(priceFeed); //现在当我们调用我们的getPrice函数时,我们可以将喂价传递给getPrice()

        //3000_000000000000000000 = ETH/USD

        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18;
        return ethAmountInUsd;
    }
}
</code></pre>
<h4 id="helper-hardhat-config">helper-hardhat-config</h4>
<p>Aave 是另一个在多条链上的协议，必须将其代码部署到多条链并使用多个不同的地址，这个协议中有一个我们可以用的配置文件</p>
<p>helper-hardhat-config.js有了这个配置文件,他们有不同的变量取决于他们实际使用的网络，所以我们也可以尝试这个配置文件，让我们可以通过chainId来获取address。</p>
<p><strong>helper-hardhat-config.js</strong></p>
<pre><code class="lang-js">//跨越不同链跟踪不同合约地址的喂价
const networkConfig = {
    //这个5是chainId
    5: {
        name: &quot;goerli&quot;,
        ethUsdPriceFeed: &quot;0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e&quot;, //喂价地址
    },
    137: {
        name: &quot;polygon&quot;,
        ethUsdPriceFeed: &quot;0xF9680D99D6C9589e2a93a78A04A279e509205945&quot;,
    },
    //31337
}
//需要导出networkConfig
module.exports = {
    networkConfig,
}
</code></pre>
<p>Mocking,localhost和hardhat以及我们如何在localhost进行测试</p>
<p>如果我们在一个没有任何喂价合约的网络上(例如hardhat和localhost),我们将使用我们自己的合约而不是导入其他人建立的合约</p>
<p>创建00-deploy-mocks.js来模拟这一切
并创建MockV3Aggregator.sol来测试</p>
<p>导入代码</p>
<p><img src="img/2-1668443218434-271.png" alt="2"></p>
<p>模拟合约部署成功</p>
<p><img src="img/3-1668443222299-273.png" alt="3"></p>
<p>把一切都部署到本地的Hardhat网络</p>
<p><img src="img/4-1668443225162-275.png" alt="4"></p>
<p>关于Hardhat-deploy还有一个重要的作用就是：当我们运行本地区块链时,hardhat-deploy会自动运行我们所有的部署脚本并将它们添加到区块链节点中。</p>
<p><img src="img/5-1668443228526-277.png" alt="5"></p>
<p>所以每次我们启动一个本地节点,它会自动打包我们想要的合约。</p>
<h4 id="-">梳理一下</h4>
<p>首先我们改变了以往使用一个deploy.js来部署合约的方式,现在用一个叫做hardhat-deploy的插件将所有脚本添加到我们的部署文件夹中，当我们运行yarn hardhat deploy命令时我们会一并运行，现在对这些部署脚本编号，按顺序运行，现在的这种方式能够承担更复杂的合约的部署,而且部署后的文件会保存在deployments文件夹里面。</p>
<p>然后这样分成很多个脚本文件去部署合约时又出现了新的问题,如果我们部署到hardhat网络时，hardhat网络是一个空白区块链,每次我们的脚本完成时它都会被销毁。即使我们使用的是localhost这样的本地节点这个喂价合约仍然将不会存在，这个代码不会进行数据更新，所以就引出了Mocking这个概念,也就是模拟合约.</p>
<p>我们想做一个在本地工作时我们可以使用并且可以控制的模拟喂价合约.</p>
<p>然后在修改过原合约代码和FundMe部署脚本后就有了helper-hardhat-config.js这个配置文件，让我们可以通过chainId来获取喂价address。</p>
<p>最后建立了模拟合约以及模拟脚本,并且在FundMe脚本中和模拟脚本进行了交互</p>
<p>模拟合约三件套:MockV3Aggregator.sol，helper-hardhat-config.js，00-deploy-mocks.js</p>
<p><strong>MockV3Aggregator.sol</strong></p>
<pre><code class="lang-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import &quot;@chainlink/contracts/src/v0.6/tests/MockV3Aggregator.sol&quot;; //像这样导入代码与复制粘贴合约完全相同(从Github导入的代码)
</code></pre>
<p><strong>helper-hardhat-config.js</strong></p>
<pre><code class="lang-js">//跨越不同链跟踪不同合约地址的喂价
const networkConfig = {
    //这个5是chainId
    5: {
        name: &quot;goerli&quot;,
        ethUsdPriceFeed: &quot;0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e&quot;, //喂价地址
    },
    137: {
        name: &quot;polygon&quot;,
        ethUsdPriceFeed: &quot;0xF9680D99D6C9589e2a93a78A04A279e509205945&quot;,
    },
    31337: {
        name: &quot;localhost&quot;,
    },
}

const developmentChains = [&quot;hardhat&quot;, &quot;localhost&quot;] //模拟合约部署的链
const DECIMALS = 8
const INITIAL_ANSWER = 200000000000

//需要导出networkConfig
module.exports = {
    networkConfig,
    developmentChains,
    DECIMALS,
    INITIAL_ANSWER,
}
</code></pre>
<p><strong>00-deploy-mocks.js</strong></p>
<pre><code class="lang-js">//我们要部署自己的Mock喂价合约
//并且在deploy-fund-me.js里面如果我们在一个没有任何喂价合约的网络上(例如hardhat和localhost),我们将使用我们自己的合约而不是已经建立的合约
const { network } = require(&quot;hardhat&quot;) //导入hardhat网络
const {
    developmentChains,
    DECIMALS,
    INITIAL_ANSWER,
} = require(&quot;../helper-hardhat-config&quot;) //导入模拟合约专属开发链
//导入模拟合约构造函数的两大参数

//我们将使用匿名异步函数
//我们将以hardhat运行时的环境作为参数(hre)
//我们只使用hre中的两个变量
module.exports = async ({ getNamedAccounts, deployments }) =&gt; {
    //我们可以使用deployments对象获得两个函数
    const { deploy, log } = deployments //从deployments拉取这两个函数
    const { deployer } = await getNamedAccounts() //从getNamedAccounts()拉取deployer函数
    //getNameAccounts函数是让我们获得NameAccounts的方法,当我们使用ethers时我们是根据号码在每个网络的accounts部分来获取我们的accounts
    // const chainId = network.config.chainId //获取我们的chainId

    //编译完模拟合约后我们现在有一个合约，我们可以使用它来将虚假的价格信息部署到区块链
    //但是我们不想把这个模拟合约部署到测试网或者主网上(这个功能需要到helper-hardhat-config.js中去完成)
    if (developmentChains.includes(network.name)) {
        log(&quot;Local network detected! Deploying mocks...&quot;) //相当于consolo.log()
        await deploy(&quot;MockV3Aggregator&quot;, {
            contract: &quot;MockV3Aggregator&quot;,
            from: deployer,
            log: true,
            args: [DECIMALS, INITIAL_ANSWER], //构造函数_decimals相当于小数函数,_initialAnswer相当于是喂价从多少开始(初始喂价)
        }) //部署测试合约
        log(&quot;Mocks deployed!&quot;)
        log(&quot;------------------------------------------------&quot;)
    }
}

//只会运行具有特殊标签的部署脚本
//只部署我们的模拟合约yarn hardhat deploy --tags mocks
module.exports.tags = [&quot;all&quot;, &quot;mocks&quot;] //all是说导出所有的配置
</code></pre>
<p><strong>01-deploy-fund-me.js</strong></p>
<pre><code class="lang-js">// 1.import
// 2.main function
// 3.calling of main function
// 这是以前的布置,使用hardhat-deploy不需要后两步了
// 当我们运行hardhat-deply,hadhat-deply实际上会调用我们在这个脚本中指定的函数

const { getNamedAccounts, network } = require(&quot;hardhat&quot;)

//我们将导出这个deployFunc()作为我们hardhat-deploy的默认函数
// function deployFunc(hre) {
//     console.log(&quot;Hi!&quot;)
//     hre.getNamedAccounts()
//     hre.deployments
// }

// module.exports.default = deployFunc//这里为什么不能有小括号呢?

//我们将使用匿名异步函数
//我们将以hardhat运行时的环境作为参数(hre)
//我们将导出这个匿名函数作为我们hardhat-deploy的默认函数
// module.exports = async (hre) =&gt; {
//     //我们只使用hre中的两个变量
//     const { getNamedAccounts, deployments } = hre //拉取hre中的具体变量
//     //这和hre.getNamedAccounts以及hre.deployments有点像
// }
//上述是未使用语法糖时的语法

const { networkConfig, developmentChains } = require(&quot;../helper-hardhat-config&quot;) //导入helper-hardhat-config.js中的网络配置
//上述导入配置语句的工作原理和下面两行相同
// const helperConfig = require(&quot;../helper-hardhat-config&quot;)
// const networkConfig = helperConfig.networkConfig
// const { network } = require(&quot;hardhat&quot;) //导入hardhat网络

module.exports = async ({ getNamedAccounts, deployments }) =&gt; {
    //我们可以使用deployments对象获得两个函数
    const { deploy, log } = deployments //从deployments拉取这两个函数
    const { deployer } = await getNamedAccounts() //从getNamedAccounts()拉取deployer函数
    //getNameAccounts函数是让我们获得NameAccounts的方法,当我们使用ethers时我们是根据号码在每个网络的accounts部分来获取我们的accounts
    const chainId = network.config.chainId //获取我们的chainId

    //通过chainId来获得address
    //Aave 是另一个在多条链上的协议，必须将其代码部署到多条链并使用多个不同的地址
    // const ethUsdPriceFeedAddress = networkConfig[chainId][&quot;ethUsdPriceFeed&quot;]
    let ethUsdPriceFeedAddress //这样就可以更新喂价地址了
    //在模拟合约中指定的开发链和测试链之间进行切换
    if (developmentChains.includes(network.name)) {
        const ethUsdAggregator = await deployments.get(&quot;MockV3Aggregator&quot;) //从模拟合约中获得聚合器对象
        ethUsdPriceFeedAddress = ethUsdAggregator.address //聚合器对象此时因为部署网络的原因获得了helper-hardhat-config.js脚本文件中的喂价地址
    } else {
        //如果使用的开发链模拟合约中未指定,那么还是通过chainId从helper-hardhat-config.js中获取喂价地址
        ethUsdPriceFeedAddress = networkConfig[chainId][&quot;ethUsdPriceFeed&quot;]
    }
    //这些Mocking合约的想法是如果真正的合约不存在(hardhat网络是一个空白区块链,每次我们的脚本完成时它都会被销毁)，我们会部署它的低仿版本以进行本地测试

    //当我们想该改变链条时会发生什么?(硬分叉？)
    //在访问 localhost 或hardhat网络时，我们想使用模拟对象

    const args = [ethUsdPriceFeedAddress] //参数列表
    //之前我们都是使用contractFactory来部署合约
    const fundMe = await deploy(&quot;FundMe&quot;, {
        from: deployer, //部署者
        args: [ethUsdPriceFeedAddress], //我们将把所有参数传递给构造函数(这里用来放置喂价地址)
        log: true, //自定义日志,这样我们就不必做所有的console.log
    }) //调用部署函数
    log(
        &quot;--------------------------------------------------------------------------------&quot;
    )
}

//只会运行具有特殊标签的部署脚本
//只部署我们的模拟合约yarn hardhat deploy --tags fundme
module.exports.tags = [&quot;all&quot;, &quot;fundme&quot;]
</code></pre>
<h3 id="utils-">Utils 文件夹</h3>
<p>不能让我们的验证代码还留在我们的部署脚本中，Utils文件夹就应运而生了，专门存放验证脚本。</p>
<p><strong>verify.js</strong></p>
<pre><code class="lang-js">const { run } = reqire(&quot;hardhat&quot;)

//验证函数
//当.sol文件中有构造函数时,参数将被填充
//此自动验证过程适用于像Ether scan这样的区块链浏览器
//const verify = async(contractAddress,args) =&gt; { 上下两种定义方法等价
async function verify(contractAddress, args) {
    console.log(&quot;Verifying contract...&quot;)
    //我们需要添加一个try-catch,因为在实践中经常出现运行时等待这样的错误
    //下面的e将有可能是我们抛出的任何错误
    try {
        //我们可以传递验证参数(故在这里采用冒号验证)---第一个参数
        //第二个参数进入内部运行,这将是实际参数的列表
        await run(&quot;verify:verify&quot;, {
            address: contractAddress,
            constructorArguments: args,
        })
    } catch (e) {
        //如果这条消息已经验证,那我们就继续
        if (e.message.toLowerCase().includes(&quot;already verified&quot;)) {
            console.log(&quot;Already Verified!&quot;)
        }
        //如果出现任何问题,那我们就输出错误,然后进行下一次验证,避免验证中断
        else {
            console.log(e)
        }
    }
}

//导出配置,让我们的验证脚本文件可以被其他程序导入
module.exports = { verify }
</code></pre>
<p>在部署脚本中的交互</p>
<pre><code class="lang-js">  //如果部署时指定网络的名称不是模拟合约中指定的开发链
    if (
        !developmentChains.includes(network.name) &amp;&amp;
        process.env.ETHERSCAN_API_KEY
    ) {
        //验证合约
        await verify(fundeMe.address, args)
    }
</code></pre>
<h3 id="-">测试网演示</h3>
<p>首先在hardhat.config.js文件当中进行配置</p>
<p>配置好各类环境变量，network，,gasreporter,但这次有些不同的是我们可以为每个测试网新添加一个参数,也就是我们所要等待的区块数(以确保合约部署和验证的正常执行)</p>
<pre><code class="lang-js">require(&quot;dotenv&quot;).config()
require(&quot;@nomiclabs/hardhat-etherscan&quot;)
require(&quot;@nomiclabs/hardhat-waffle&quot;)
require(&quot;hardhat-gas-reporter&quot;)
require(&quot;solidity-coverage&quot;)
require(&quot;hardhat-deploy&quot;)

const GOERLI_RPC_URL = process.env.GOERLI_RPC_URL
const PRIVATE_KEY = process.env.PRIVATE_KEY
const COINMARKETCAP_API_KEY = process.env.COINMARKETCAP_API_KEY
const ETHERSCAN_API_KEY = process.env.ETHERSCAN_API_KEY

module.exports = {
    solidity: {
        compilers: [{ version: &quot;0.8.8&quot; }, { version: &quot;0.6.6&quot; }],
    },
    defaultNetwork: &quot;hardhat&quot;,
    networks: {
        goerli: {
            url: GOERLI_RPC_URL,
            accounts: [PRIVATE_KEY],
            chainId: 5,
            blockConfirmations: 6,
        },
    },
    gasReporter: {
        enable: false, //在我们运行测试时先不让这个插件运行
        outputFile: &quot;gas-report.txt&quot;, //把Gas费的消耗输出到一个文件中
        noColors: true, //当我们输出到文件时,颜色基本上会弄乱,所以直接不设置颜色了
        currency: &quot;USD&quot;, //添加货币,这样我们就可以得到以美元所计的函数Gas费成本
        coinmarketcap: COINMARKETCAP_API_KEY, //为了获得货币我们需要得到来自货币市值的API密钥(就像那次获得Ether scan密钥一样)
    },
    etherscan: {
        apiKey: process.env.ETHERSCAN_API_KEY,
    },
    //我们可以在这里统一书写每个网络的accounts数组中的用户编号
    namedAccounts: {
        //用户编号
        deployer: {
            default: 0,
        },
        //如果我们想为某些用户做一些测试的话,设置该用户的默认编号
        users: {
            default: 1,
        },
    },
}
</code></pre>
<p>这时候运行部署命令</p>
<pre><code>yarn hardhat deploy --network goerli
</code></pre><p>这次的部署命令不会部署任何模拟合约,因为所选择的区块链不是指定的开发链,但他应该使用正确的喂价地址,运行我们的deploy-fund-me.js.</p>
<p><img src="img/6-1668443244977-279.png" alt="6"></p>
<p>测试网演示成功!</p>
<p><img src="img/7-1668443247650-281.png" alt="7"></p>
<p>现在我们既可以部署到本地网络也可以部署到测试网(只需要更新我们的hardhat.config.js和helper-hardhat-config.js，<strong>前者负责测试网，后者负责喂价</strong>)</p>
<h3 id="solidity-">Solidity代码风格</h3>
<p>代码风格是为了保持代码的一致性</p>
<h4 id="-">布局顺序</h4>
<p>函数的各元素建议布局的顺序如下：</p>
<ol>
<li>Pragma 语句</li>
<li>Import 语句</li>
<li>Interfaces</li>
<li>Libraries</li>
<li>Contracts</li>
</ol>
<p>在每个合约、库或接口内，使用如下顺序：</p>
<ol>
<li>类型声明 Type Declarations(不带public的那种)</li>
<li>状态声明 State variables(带public的那种)</li>
<li>事件 Events</li>
<li>修改器 Modifiers</li>
<li>函数 functions</li>
</ol>
<h4 id="natspec">NatSpec</h4>
<p>Solidity 合约可以使用一种特殊形式的注释来为函数、返回变量等提供丰富的文档。这种特殊形式被命名为以太坊自然语言规范格式（NatSpec）。</p>
<blockquote>
<p>它基本是记录我们代码的一种方式，NatSpec 的灵感来自<a href="https://en.wikipedia.org/wiki/Doxygen">Doxygen</a>。虽然它使用 Doxygen 样式的注释和标签，但无意保持与 Doxygen 的严格兼容性。</p>
</blockquote>
<pre><code>/** @title 这是一个众筹的合约
 *  @author Loop Love
 *  @notice 这个合约是一个简单的众筹合约demo
 *  @dev 喂价是我们的库
 */
 contract FundMe {}


 /**
  *  @notice 该功能为该合约提供资金
  *  @dev 喂价是我们的库
  */
function fund() public payable {}
</code></pre><p>我们可以使用NatSpec为我们自动创建文档，我们可以运行下面的命令自动生成文档。</p>
<pre><code>solc --userdoc --devdoc 文件名.sol
</code></pre><p>所以说NatSpec对于与我们交互的其他开发人员来说帮助很大,因为我们大多数人不会为了程序专门去制作文档</p>
<h3 id="-fundme-">测试FundMe合约</h3>
<p>当我们得到越来越大的项目时,我们将要开始测试越来越多不同的东西,大致分为两种不同类型的测试。</p>
<ul>
<li>Unit测试(单元测试)</li>
</ul>
<p>​        在计算机编程中，<strong>单元测试</strong>（英语：Unit Testing）又称为<strong>模块测试</strong>，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是函数，包括基类（超类）、抽象类、或者派生类（子类）中的函数。</p>
<p>​        基本上我们想做的是在我们的合约中测试我们代码的最小部分以确保它们正常工作</p>
<p>​        现在可以在<strong>local hardhat网络</strong>，<strong>分叉的hardhat网络</strong>运行单元测试。</p>
<ul>
<li>Staging测试(分期/集成测试)</li>
</ul>
<p>​        这是我们在<strong>测试网</strong>上运行代码的地方,确保我们的代码可以与实际的其他合约一起使用,Staging测试这是合约部署到主网之前的最后一站</p>
<p>FundMe.test.js</p>
<pre><code class="lang-js">//我们将使用hardhat-deploy来自动设置我们的测试
//我们可以基于不同的函数对我们的测试进行分组。

const { assert, expect } = require(&quot;chai&quot;)
const { deployments, ethers, getNamedAccounts } = require(&quot;hardhat&quot;) //hardhat运行时环境相当于hardhat

describe(&quot;FundMe&quot;, function () {
    //我们的“fundMe”,“deployer”和“mockV3Aggregator”对象的范围仅限于 beforeeach 内部，
    //我们实际上需要将这些变量粘贴到 beforeeach 之外，以便我们所有的 it() 都可以与它们交互。
    //因此，我们不是让“fundMe”,“deployer”和“mockV3Aggregator”成为常量变量，而是使用 let 关键字在beforeeach之外定义它们
    let fundMe
    let deployer
    let mockV3Aggregator //将它们初始化为空
    const sendValue = ethers.utils.parseEther(&quot;1&quot;) // 1ETH 这是ethers.js包中的util函数的作用,可以在这个函数中对ETH的任何单位进行转换

    //该函数会告诉我们在每个it()前/我们的测试框架在每次测试前需要做什么
    //我们想要在函数测试之前部署合约
    beforeEach(async function () {
        //在这里,我们需要部署我们的FundMe合约,以至于我们每次测试的时候都能有一份全新的合约与我们的每一项测试进行交互
        // const accounts = await ethers.getSigners()//getSigners函数将返回部署网络中账户的全部内容(如果在默认网络hardhat上部署的话,它会给你一份10个假帐户的清单)
        // const accountZero = accounts[0]

        //下面的函数都是很严格的,要么给参数,要么包装
        //上述是其他获得资助者账户的方法
        deployer = (await getNamedAccounts()).deployer //合约部署者账户
        //使用hardhat-deploy部署我们的FundMe合约
        await deployments.fixture([&quot;all&quot;]) //fixture的作用是它允许我们使用我们all标签来运行我们的整个部署文件夹
        //当我们运行上述这行代码时,我将在本地网络上运行我们的部署脚本并部署所有合约
        fundMe = await ethers.getContract(&quot;FundMe&quot;, deployer) //getContract将获取我们告诉它的任何合约的最新部署,把合约部署者账户连接入合约中
        //每当我们用fundMe调用一个函数时,它将自动来自合约部署者账户
        mockV3Aggregator = await ethers.getContract(
            &quot;MockV3Aggregator&quot;,
            deployer
        )
    })

    //构造函数的测试
    describe(&quot;constructor&quot;, function () {
        it(&quot;正确设置聚合器地址&quot;, async function () {
            const response = await fundMe.priceFeed() //我们要确保测试时的喂价与我们的模拟合约相同,因为我们将在本地运行测试
            assert.equal(response, mockV3Aggregator.address) //这就是上述的beforeEach中定义mockV3Aggregator对象的原因
        })
    })

    //众筹函数的测试
    describe(&quot;fund&quot;, function () {
        it(&quot;如果您没有发送足够的 ETH,则会失败&quot;, async function () {
            await expect(fundMe.fund()).to.be.revertedWith(
                &quot;You need to spend more ETH!&quot;
            ) //来自华夫饼匹配器,这段代码是测试事务是否被require检查器还原,如果还原的话说明资助的ETH不够最低标准
        })
        //测试是否更新了资助者地址数组到资助金额的映射
        it(&quot;更新了资助者地址数组到资助金额的映射&quot;, async function () {
            await fundMe.fund({ value: sendValue }) //调用fundMe合约的fund函数,并传了一个ETH进去作为资助金额
            const response = await fundMe.addressToAmountFunded(deployer) //传完资金之后这里给个映射把资金提出来然后下面匹配一下看看是否更新成功address =&gt; uints
            assert.equal(response.toString(), sendValue.toString())
        })
        it(&quot;将资助者添加到资助者数组中&quot;, async function () {
            await fundMe.fund({ value: sendValue }) //调用fundMe合约的fund函数,并传了一个ETH进去作为资助金额,也就是资助者数组的数组首元素
            const funder = await fundMe.funders(0) //在索引为0处调用资助者数组创建对象
            assert.equal(funder, deployer)
        })
    })
    describe(&quot;withdraw&quot;, function () {
        //在取钱之前先往里面资助一些钱
        beforeEach(async function () {
            await fundMe.fund({ value: sendValue })
        })

        it(&quot;从单个资助者那里提取 ETH&quot;, async function () {
            //安排测试
            const startingFundMeBalance = await fundMe.provider.getBalance(
                fundMe.address
            ) //首先要获得fundMe合约的起始余额(他是一个BigNumber对象)
            const startingDeployerBalance = await fundMe.provider.getBalance(
                deployer
            ) //然后获得合约部署者余额
            //根据测试调用取款函数后二者余额的变化来决定是否正常调用

            //采取行动
            const transactionResponse = await fundMe.withdraw() //调用取款函数创建对象
            const transactionReceipt = await transactionResponse.wait(1) //等待一个区块后再取钱
            const { gasUsed, effectiveGasPrice } = transactionReceipt //使用的Gas数量以及有效的Gas价格
            const gasCost = gasUsed.mul(effectiveGasPrice) //实际使用的Gas数量*有效的Gas价格=Gas的实际花费

            const endingFundMeBalance = await fundMe.provider.getBalance(
                fundMe.address
            ) //取完钱后的fundMe合约余额
            const endingDeployerBalance = await fundMe.provider.getBalance(
                deployer
            ) //取完钱后的合约部署者余额
            //华夫饼匹配
            assert.equal(endingFundMeBalance, 0) //我们取出了所有的钱
            assert.equal(
                startingDeployerBalance.add(startingFundMeBalance).toString(),
                endingDeployerBalance.add(gasCost).toString() //调用withdraw函数消耗Gas费
            ) //钱回到了合约部署者的口袋里面
        })
    })
})
</code></pre>
<p><img src="img/8-1668443268112-283.png" alt="8"></p>
<p><img src="img/1-1668443270597-285.png" alt="1"></p>
<p><img src="img/2-1668443273364-287.png" alt="2"></p>
<p><img src="img/3-1668443277115-289.png" alt="3"></p>
<h4 id="-debug">断点&amp;Debug</h4>
<p>断点允许我们进入调试控制台并查看此时正在发生的所有变量</p>
<p><img src="img/4-1668443281382-291.png" alt="4"></p>
<p>在调试的过程中我们发现了函数调用过程存在着Gas费的损耗，以及我们可以从transactionReceipt对象中提取出实际使用的Gas数量以及有效的Gas费用</p>
<p><img src="img/5-1668443285501-293.png" alt="5"></p>
<h4 id="gas-iii">Gas费 III</h4>
<pre><code>  const { gasUsed, effectiveGasPrice } = transactionReceipt //使用的Gas数量以及有效的Gas价格
  const gasCost = gasUsed.mul(effectiveGasPrice) //实际使用的Gas数量*有效的Gas价格=Gas的实际花费



  assert.equal(
                startingDeployerBalance.add(startingFundMeBalance).toString(),
                endingDeployerBalance.add(gasCost).toString() //调用withdraw函数消耗Gas费
  ) //钱回到了合约部署者的口袋里面
</code></pre><p><strong>小回顾</strong></p>
<p>首先我们从fundMe合约的部署者处获得了起始余额，然后我们调用了withdraw函数并从transaction处获取了我们所使用的Gas数量和Gas的实际价格，并用它来获得本次交易中Gas的总成本，接着我们获得了末尾余额，并使用所有的变量来确保了收支平衡</p>
<h4 id="console-logdebugging">console.log&amp;Debugging</h4>
<p>这是一个很好的调试工具</p>
<p>在 Hardhat Network 上运行合约和测试时，您可以打印<code>console.log()</code>从 Solidity 代码调用的日志消息和合约变量。如果要使用<code>hardhat/console.sol</code>，您必须在您的合同代码中导入(import &quot;hardhat/console.sol&quot;)。</p>
<p>示例</p>
<pre><code class="lang-solidity">pragma solidity ^0.8.9;

import &quot;hardhat/console.sol&quot;;

contract Token {

function transfer(address to, uint256 amount) external {
    require(balances[msg.sender] &gt;= amount, &quot;Not enough tokens&quot;);

    console.log(
        &quot;Transferring from %s to %s %s tokens&quot;,
        msg.sender,
        to,
        amount
    );

    balances[msg.sender] -= amount;
    balances[to] += amount;

    emit Transfer(msg.sender, to, amount);
    }
}
</code></pre>
<p>在运行测试时将显式输出这些日志(这不就是C语言的printf吗)</p>
<p><strong>输出结果</strong></p>
<pre><code>$ npx hardhat test

  Token contract
    Deployment
      ✓ Should set the right owner
      ✓ Should assign the total supply of tokens to the owner
    Transactions
Transferring from 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 to 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 50 tokens
Transferring from 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 to 0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc 50 tokens
      ✓ Should transfer tokens between accounts (373ms)
      ✓ Should fail if sender doesn’t have enough tokens
Transferring from 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 to 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 50 tokens
Transferring from 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 to 0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc 50 tokens
      ✓ Should update balances after transfers (187ms)


  5 passing (2s)
</code></pre><p>所以说除了VSCode内置的调试器之外,在Solidity中导入hardhat/consolde.sol以及使用console.log也可以成为有效的调试策略.</p>
<h4 id="-fundme-ii">测试FundMe合约II</h4>
<pre><code class="lang-js">//我们将使用hardhat-deploy来自动设置我们的测试
//我们可以基于不同的函数对我们的测试进行分组。

const { assert, expect } = require(&quot;chai&quot;)
const { deployments, ethers, getNamedAccounts } = require(&quot;hardhat&quot;) //hardhat运行时环境相当于hardhat

describe(&quot;FundMe&quot;, function () {
    //我们的“fundMe”,“deployer”和“mockV3Aggregator”对象的范围仅限于 beforeeach 内部，
    //我们实际上需要将这些变量粘贴到 beforeeach 之外，以便我们所有的 it() 都可以与它们交互。
    //因此，我们不是让“fundMe”,“deployer”和“mockV3Aggregator”成为常量变量，而是使用 let 关键字在beforeeach之外定义它们
    let fundMe
    let deployer
    let mockV3Aggregator //将它们初始化为空
    const sendValue = ethers.utils.parseEther(&quot;1&quot;) // 1ETH 这是ethers.js包中的util函数的作用,可以在这个函数中对ETH的任何单位进行转换

    //该函数会告诉我们在每个it()前/我们的测试框架在每次测试前需要做什么
    //我们想要在函数测试之前部署合约
    beforeEach(async function () {
        //在这里,我们需要部署我们的FundMe合约,以至于我们每次测试的时候都能有一份全新的合约与我们的每一项测试进行交互
        // const accounts = await ethers.getSigners()//getSigners函数将返回部署网络中账户的全部内容(如果在默认网络hardhat上部署的话,它会给你一份10个假帐户的清单)
        // const accountZero = accounts[0]

        //下面的函数都是很严格的,要么给参数,要么包装
        //上述是其他获得资助者账户的方法
        deployer = (await getNamedAccounts()).deployer //合约部署者账户
        //使用hardhat-deploy部署我们的FundMe合约
        await deployments.fixture([&quot;all&quot;]) //fixture的作用是它允许我们使用我们all标签来运行我们的整个部署文件夹
        //当我们运行上述这行代码时,我将在本地网络上运行我们的部署脚本并部署所有合约
        fundMe = await ethers.getContract(&quot;FundMe&quot;, deployer) //getContract将获取我们告诉它的任何合约的最新部署,把合约部署者账户连接入合约中
        //每当我们用fundMe调用一个函数时,它将自动来自合约部署者账户
        mockV3Aggregator = await ethers.getContract(
            &quot;MockV3Aggregator&quot;,
            deployer
        )
    })

    //构造函数的测试
    describe(&quot;constructor&quot;, function () {
        it(&quot;正确设置聚合器地址&quot;, async function () {
            const response = await fundMe.priceFeed() //我们要确保测试时的喂价与我们的模拟合约相同,因为我们将在本地运行测试
            assert.equal(response, mockV3Aggregator.address) //这就是上述的beforeEach中定义mockV3Aggregator对象的原因
        })
    })

    //众筹函数的测试
    describe(&quot;fund&quot;, function () {
        it(&quot;如果您没有发送足够的 ETH,则会失败&quot;, async function () {
            await expect(fundMe.fund()).to.be.revertedWith(
                &quot;You need to spend more ETH!&quot;
            ) //来自华夫饼匹配器,这段代码是测试事务是否被require检查器还原,如果还原的话说明资助的ETH不够最低标准
        })
        //测试是否更新了资助者地址数组到资助金额的映射
        it(&quot;更新了资助者地址数组到资助金额的映射&quot;, async function () {
            await fundMe.fund({ value: sendValue }) //调用fundMe合约的fund函数,并传了一个ETH进去作为资助金额
            const response = await fundMe.addressToAmountFunded(deployer) //传完资金之后这里给个映射把资金提出来然后下面匹配一下看看是否更新成功address =&gt; uints
            assert.equal(response.toString(), sendValue.toString())
        })
        it(&quot;将资助者添加到资助者数组中&quot;, async function () {
            await fundMe.fund({ value: sendValue }) //调用fundMe合约的fund函数,并传了一个ETH进去作为资助金额,也就是资助者数组的数组首元素
            const funder = await fundMe.funders(0) //在索引为0处调用资助者数组创建对象
            assert.equal(funder, deployer)
        })
    })
    describe(&quot;withdraw&quot;, function () {
        //在取钱之前先往里面资助一些钱
        beforeEach(async function () {
            await fundMe.fund({ value: sendValue })
        })

        it(&quot;从单个资助者那里提取 ETH&quot;, async function () {
            //安排测试
            const startingFundMeBalance = await fundMe.provider.getBalance(
                fundMe.address
            ) //首先要获得fundMe合约的起始余额(他是一个BigNumber对象)
            const startingDeployerBalance = await fundMe.provider.getBalance(
                deployer
            ) //然后获得合约部署者余额
            //根据测试调用取款函数后二者余额的变化来决定是否正常调用

            //采取行动
            const transactionResponse = await fundMe.withdraw() //调用取款函数创建对象
            const transactionReceipt = await transactionResponse.wait(1) //等待一个区块后再取钱
            const { gasUsed, effectiveGasPrice } = transactionReceipt //使用的Gas数量以及有效的Gas价格
            const gasCost = gasUsed.mul(effectiveGasPrice) //实际使用的Gas数量*有效的Gas价格=Gas的实际花费

            const endingFundMeBalance = await fundMe.provider.getBalance(
                fundMe.address
            ) //取完钱后的fundMe合约余额
            const endingDeployerBalance = await fundMe.provider.getBalance(
                deployer
            ) //取完钱后的合约部署者余额
            //华夫饼匹配
            assert.equal(endingFundMeBalance, 0) //我们取出了所有的钱
            assert.equal(
                startingDeployerBalance.add(startingFundMeBalance).toString(),
                endingDeployerBalance.add(gasCost).toString() //调用withdraw函数消耗Gas费
            ) //钱回到了合约部署者的口袋里面
        })
        it(&quot;从多个资助者那里提取 ETH&quot;, async function () {
            //先创建一大堆不同的账户
            const accounts = await ethers.getSigners() //getSigners函数将返回部署网络中账户的全部内容(相当于是一个数组)
            //遍历这些账户并让这些账户中的每一个都调用fund函数存点钱方便一会儿取
            //从1开始,因为0号是部署者账户
            for (let i = 1; i &lt; 6; i++) {
                const fundMeConnectedContract = await fundMe.connect(
                    accounts[i]
                ) //调用connect函数创建新对象来连接所有这些不同的账户(因为fundMe合约在使用时自动和部署者连接)
                await fundMeConnectedContract.fund({ value: sendValue })
            }
            const startingFundMeBalance = await fundMe.provider.getBalance(
                fundMe.address
            ) //首先要获得fundMe合约的起始余额(他是一个BigNumber对象)
            const startingDeployerBalance = await fundMe.provider.getBalance(
                deployer
            ) //然后获得合约部署者余额

            const transactionResponse = await fundMe.withdraw() //再次调用withdraw函数
            const transactionReceipt = await transactionResponse.wait(1) //等待一个区块后再取钱
            const { gasUsed, effectiveGasPrice } = transactionReceipt //使用的Gas数量以及有效的Gas价格
            const gasCost = gasUsed.mul(effectiveGasPrice) //实际使用的Gas数量*有效的Gas价格=Gas的实际花费

            const endingFundMeBalance = await fundMe.provider.getBalance(
                fundMe.address
            ) //取完钱后的fundMe合约余额
            const endingDeployerBalance = await fundMe.provider.getBalance(
                deployer
            ) //取完钱后的合约部署者余额
            //华夫饼匹配
            assert.equal(endingFundMeBalance, 0) //我们取出了所有的钱
            assert.equal(
                startingDeployerBalance.add(startingFundMeBalance).toString(),
                endingDeployerBalance.add(gasCost).toString() //调用withdraw函数消耗Gas费
            ) //钱回到了合约部署者的口袋里面

            //遍历所有的资助者账户,发现他们都被还原了
            await expect(fundMe.fund()).to.be.reverted

            //映射
            for (i = 1; i &lt; 6; i++) {
                assert.equal(
                    await fundMe.addressToAmountFunded(accounts[i].address),
                    0
                ) // address =&gt; uint256
            }
        })

        it(&quot;只允许合约的部署者(主人)撤回资金&quot;, async function () {
            const accounts = await ethers.getSigners()
            const fundMeConnectedContract = await fundMe.connect(accounts[1]) //第一个资助者账户是随机的攻击者,把这个攻击者连接到一个新合约
            await expect(fundMeConnectedContract.withdraw()).to.be.revertedWith(
                &quot;FundMe__NotOwner&quot;
            ) //确保当其他账户尝试调用withdraw函数时会自动恢复并抛出修改器特有的error code
        })
    })
})
</code></pre>
<p><img src="img/6-1668443299040-295.png" alt="6"></p>
<h3 id="solidity-storage">Solidity中的Storage</h3>
<p>了解这些可以优化Gas费</p>
<p><img src="img/7-1668443309026-297.png" alt="7"></p>
<p>全局变量都被困在存储里，可以将存储视为一个巨大的数组或我们实际创建的所有变量的巨大列表。因此，当我们有一些称为存储之子的合约，并且我们有一个变量 favoriteNumber 时，我们基本上是在说我们希望这个 favoriteNumber 变量保持不变。</p>
<p>存储盒是与此合约相关联的巨大列表，其中存储部分中的每个变量和每个值都被插入此存储数组中的一个 32 字节长的插槽中。</p>
<p>因此，例如，其字节实现中的数字 25 是 0x00...19。这是uint256 的十六进制版本。</p>
<p>每个存储都像数组一样看着增量从0开始,所以我们的下一个全局变量(或存储变量)被插到一个新插槽中。每个存储变量都会占用一个存储插槽。</p>
<p><img src="img/8-1668443312794-299.png" alt="8"></p>
<p>那么那些动态长度的变量会如何呢?例如动态数组,映射这些.</p>
<p>数组内或映射内的元素，它们实际上是使用某种类型的哈希函数存储的。对象本身确实占用了一个存储槽，但他不会是整个数组。</p>
<p>例如我的数组变量在存储插槽二号中，存储插槽二号中没有整个数组，它实际上存储的只是数组长度，数组的长度存储在存储插槽二号中。</p>
<p>但是在myArray.push(222)中我们做一些哈希函数，我们将 数字222 存储在storage中，222的十六进制为0x00..0de</p>
<p><img src="img/9-1668443319447-301.png" alt="9"></p>
<p> constant变量和immutable变量不能占用存储空间,原因是因为constant变量实际上是合约代码本身的一部分</p>
<p>下面代码中的NOT_IN_STORAGE只是一个指向数字123的指针,不占用存储插槽</p>
<p><img src="img/10-1668443324166-303.png" alt="10"></p>
<p>当我们在函数内部有变量时,这些变量只存在于函数运行期间,这些变量不能添加到存储中,而是添加到自己的内存数据结构中运行后再被删除</p>
<p><img src="img/11-1668443328611-305.png" alt="11"></p>
<p>在Solidity中，memory的作用是什么(尤其是在字符串方面)?</p>
<p>因为string在技术上是一个动态大小的数组,因为string是一个数组,所以我们需要添加memory给数组指定数据位置,但是我们无法在_name前面添加storage关键字,Solidity也知道,这是一个函数,这个 _name变量实际上并没有存储在任何地方,故这个 _name变量只接受memory和calldata。</p>
<p>总结:当我们将数组,结构和映射作为参数添加到不同的函数时,需要给出memory或calldata关键字。</p>
<h3 id="-storage-gas">通过Storage节省Gas</h3>
<p>实际计算Gas费的方式实际上是通过ByteCode中的opcodes</p>
<p><img src="img/12-1668443335541-307.png" alt="12"></p>
<p>存储变量命名：s_name</p>
<p>immutable常量命名：i_name</p>
<p>const常量命名：MINIMUM_USD</p>
<pre><code>//节省Gas费
    //刚开始这个节省的幅度可能不明显,数组越大越明显
    function cheaperWithdraw() public payable onlyOwner {
        //一次将整个数组读入内存,然后从内存中读取而不是从存储中进行昂贵的读取
        address[] memory funders = s_funders; //memory意味着该数组只会暂时存在于函数当中,把存储变量保存到内存变量(多出来的这行代码也消耗Gas费)
        //这样我们可以在内存变量中读写(Gas费便宜得多),读写完成后再保存到存储变量中
        //映射不能使用memory关键字
        for (
            uint256 funderIndex = 0;
            funderIndex &lt; funders.length;
            funderIndex++
        ) {
            address funder = funders[funderIndex]; //使用我们的内存变量
            s_addressToAmountFunded[funder] = 0; //重置映射
        }
        s_funders = new address[](0); //读写完成后再保存到存储变量中
        (bool success, ) = i_owner.call{value: address(this).balance}(&quot;&quot;);
        require(success);
    }
</code></pre><h3 id="chainlink-solidity-">Chainlink风格的Solidity代码</h3>
<p>下划线式的命名单个拿出来看的话能够很清楚地看出来意义,但是集中起来就很恶心。</p>
<p>Chainlink风格的代码更恶心,化简为繁了，为了所谓的Fake不可窜改性不要脸了都。</p>
<h3 id="storage-">Storage 回顾</h3>
<p>我们希望在合约执行和交易中持续存在的任何可变变量，我们保存到一个名为storage的巨型数组中，该数组从0开始按顺序索引，所以我们在合约中拥有的第一个变量使用的索引为0<strong>。动态数组和映射等其他动态大小的对象使用特定的散列函数确定那些动态的元素在哪里的数据结构中。</strong></p>
<p><strong>内存(memory)变量,常量(const)变量和不可变(immutable)变量不会在storage中，它们都是临时存储在区块链上</strong></p>
<p>谈论存储的一个重要原因是从存储加载的操作码和用于从存储读取和写入数据消耗的都是非常昂贵的汽油。因此，在任何地方，我们都希望减少从存储中读取和加载的数量。这是节省 gas 并尝试优化我们的代码以提高 gas 效率的最简单方法之一。</p>
<h3 id="staging-test">Staging Test</h3>
<p>这是我们可以在测试网上运行的测试，也是我们平时开发智能合约的最后一步。</p>
<pre><code>const { getNamedAccounts, ethers, network } = require(&quot;hardhat&quot;)
const { developmentChains } = require(&quot;../../helper-hardhat-config&quot;)
const { assert } = require(&quot;chai&quot;)
//条件运算符
//我们的测试碰上开发链的话直接跳过
developmentChains.includes(network.name)
    ? describe.skip
    : describe(&quot;FundMe Staging Test&quot;, function () {
          let fundMe
          let deployer
          const sendValue = ethers.utils.parseEther(&quot;1&quot;)
          beforeEach(async function () {
              deployer = (await getNamedAccounts()).deployer
              fundMe = await ethers.getContract(&quot;FundMe&quot;, deployer)
          })

          it(&quot;允许人们投资和提款&quot;, async function () {
              await fundMe.fund({ value: sendValue })
              await fundMe.withdraw()
              const endingBalance = await fundMe.provider.getBalance(
                  fundMe.address
              )
              assert.equal(endingBalance.toString(), &quot;0&quot;)
          })
      })
</code></pre><p><img src="img/13-1668443346642-309.png" alt="13"></p>
<h3 id="-">在本地节点运行脚本</h3>
<p>当说到区块链,当涉及到智能合约时,与社区互动,与开源互动,成为Github或者Gitlabs的一部分是至关重要的，建立一个脚本把我们的代码推送到Githhub上。</p>
<p><strong>fund.js</strong></p>
<pre><code class="lang-js">//如果我们只是想快速给我们的合约提供一份资金,我们可以这样做
const { getNamedAccounts, ethers } = require(&quot;hardhat&quot;)

async function main() {
    const { deployer } = await getNamedAccounts()
    const fundMe = await ethers.getContract(&quot;FundMe&quot;, deployer)
    console.log(&quot;Funding Contract...&quot;)
    const transactionResponse = await fundMe.fund({
        value: ethers.utils.parseEther(&quot;0.1&quot;),
    })
    await transactionResponse.wait(1)
    console.log(&quot;Funded!&quot;)
}

main()
    .then(() =&gt; process.exit(0))
    .catch((error) =&gt; {
        console.error(error)
        process.exit(1)
    })
</code></pre>
<p><strong>withdraw.js</strong></p>
<pre><code class="lang-js">const { getNamedAccounts, ethers } = require(&quot;hardhat&quot;)

//如果我们只是想快速从我们的合约取出一份资金,我们可以这样做
async function main() {
    const { deployer } = await getNamedAccounts()
    const fundMe = await ethers.getContract(&quot;FundMe&quot;, deployer)
    console.log(&quot;Funding...&quot;)
    const transactionResponse = await fundMe.withdraw()
    await transactionResponse.wait(1)
    console.log(&quot;Got it back!&quot;)
}

main()
    .then(() =&gt; process.exit(0))
    .catch((error) =&gt; {
        console.error(error)
        process.exit(1)
    })
</code></pre>
<p><img src="img/1-1668443350232-311.png" alt="1"></p>
<h3 id="-package-json-">在package.json中加入脚本(奇妙)</h3>
<p><img src="img/2-1668443352973-313.png" alt="2"></p>
<p>我们可以添加这个脚本部分，让我们的编程更轻松，并将所有这些长测试浓缩成一个yarn脚本，供我们使用。</p>
<p>lint:fix可以自动修复.sol文件中的错误</p>
<h3 id="push-github-">Push到Github中</h3>
<p>建立好存储库后的第一件事就是初始化一个Git分支，Git被称为版本控制，它允许我们更改我们的代码但是保留我们更改代码的历史记录。Github是一个我们可以push所有的这些变化并跟踪我们的地方。</p>
<pre><code>git init
</code></pre><p><img src="img/3-1668443356444-315.png" alt="3"></p>
<p>初始化主分支后运行git status命令查看到所有文件的状态都是未提交，然后运行git add.命令后再次运行git status命令查看状态都是暂存。</p>
<p>git config --global user.email &quot;<a href="mailto:0xjlzxiaoye.eth@gmail.com">0xjlzxiaoye.eth@gmail.com</a>&quot;
git config --global user.name &quot;LoopLove-Ether&quot;</p>
<p>git commit -m &quot;initial commit&quot;</p>
<p>然后运行上面那三条命令提交文件，这时候再运行git stauts命令会发现分支上是空白的，没什么可提交的了</p>
<p>接着添加远程仓库</p>
<pre><code>git remote add origin https://github.com/LoopLove-Ether/hardhat-fund-me-fcc.git
</code></pre><p>我们现在可以说origin远程仓库将位于此url</p>
<p>然后我们运行命令</p>
<pre><code>git remote -v
</code></pre><p><img src="img/4-1668443360609-317.png" alt="4"></p>
<p>我们会发现fetch和push都在这个url中,这将是您唯一的仓库 URL</p>
<p>fetch是从远程仓库中获取最新版本到本地；push是把本地提交到远程仓库</p>
<p>接着运行命令将本地仓库提交到GitHub.com中</p>
<pre><code>git branch -M main
git push -u origin main
</code></pre><p>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(在Github上生成的令牌)</p>
<p><img src="img/5-1669194554161-1.png" alt="5"></p>
<p>总的来说可以无脑使用这六步把自己的本地仓库push到Github.com中</p>
<h2 id="8-html-javascript-fundme-">8.使用HTML/Javascript完成FundMe智能合约的前端(已)</h2>
<p>node.js和JavaScript之间存在着区别</p>
<p>当我们搭建Dapps的时候,我们通常有两个仓库</p>
<p>前后端分离</p>
<p>一个仓库用于智能合约</p>
<p>一个仓库用于前端/网站</p>
<p>这两个仓库的组合，构成了全栈</p>
<p>全栈=智能合约(后端)+Html/JavaScript/Website(前端)</p>
<p>网站的幕后是如何与区块链交互的?</p>
<h3 id="-web3-">网站怎么使用Web3钱包</h3>
<p>这些钱包如此重要的原因在于它们的内部有一个与之相连的区块链节点，为了与区块链交互，我们总是需要一个节点.</p>
<p>Alchemy是您可以与之交互的第三方区块链的示例,我们需要他们创建一个节点来发送我们的交易(在后端的操作中我们喜欢使用这个)</p>
<p>但是在前端的操作中我们使用的是用户的Metamask或者其他钱包，它们公开了在内部的节点，可以通过在F12网页控制台中输入window.ethersum查看是否安装了Metamask。</p>
<h3 id="html-">HTML设置</h3>
<p>1.我们将使用原始的 HTML/Javascript 结合我们的智能合约建立这个网站 </p>
<p>2.我们将使用Nextjs/Reactjs,它们是建立网站时更先进的技术栈</p>
<p>HTML就是脚手架,就是网站外观的基础</p>
<p>使用live server插件来go live到谷歌查看HTML效果</p>
<p>我们的网站托管在本地主机端点127.0.0.1，端口5500</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;title&gt;Fund Me App&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    Whats good?
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="metamask-html">Metamask连接HTML</h3>
<p>我们的第一件事就是在控制台中用window.ethersum来检查是否Metamask是否存在,如果不存在的话意味着它们无法连接到区块链</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;title&gt;Fund Me App&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    Whats good?
    &lt;!-- script标签内部书写的都是JavaScript --&gt;
    &lt;script&gt;
      // 先检查Metatmask钱包是否存在
      async function connect() {
        if (typeof window.ethereum !== &quot;undefined&quot;) {
          await window.ethereum.request({ method: &quot;eth_requestAccounts&quot; });
          //引入钱包权限,将Metamask自动连接到我们的网站(网站可以对我们的Metamask进行API调用)
          document.getElementById(&quot;connectButton&quot;).innerHTML = &quot;Connected!&quot;; //当通过按钮连接成功时按钮上的字体会变成Connected!
        } else {
          console.log(&quot;No metamask!&quot;);
          document.getElementById(&quot;connectButton&quot;).innerHTML =
            &quot;Please install metamask&quot;; //当连接失败时按钮上的字体会变成Please install metamask
        }
      }
    &lt;/script&gt;
    &lt;!-- 点击这个按纽时会调用connect函数 --&gt;
    &lt;button id=&quot;connectButton&quot; onclick=&quot;connect()&quot;&gt;Connect&lt;/button&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="-javascript-">把Javascript部分单独创建文件</h3>
<p>把JavaScript分离到我们熟悉的.js文件中</p>
<pre><code>&lt;script src=&quot;./index.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
</code></pre><h3 id="es6-js-nodejs">ES6(前端JS)对比NodeJS</h3>
<p>这个ethers-5.6.esm.min.js是从官方文档复制下来后放在项目目录里面了,跟导jar包似的</p>
<pre><code>//在node.js中我们需要使用require关键字导入依赖
//在前端JS中通过import关键字导入依赖

//我们不想使用node_modules包安装ethers
//将 ethers 库复制到您自己的目录并自己提供服务通常是更好的做法
import { ethers } from &quot;./ethers-5.6.esm.min.js&quot;
</code></pre><h3 id="-web-">从Web端发送交易</h3>
<p>需要将钱包连接至本地网络,导入本地节点的私钥新创建一个账户</p>
<p>记得在前端项目中建立constants.js文件夹,用来存放合约地址和abi</p>
<p>将我们后端项目中artifacts文件夹下的FundMe.json中的abi粘贴到contants.js文件中</p>
<p>在后端项目中运行yarn hardhat node命令获得合约地址然后粘贴到contants.js文件中</p>
<p>contractAddress和abi使用的是后端代码中FundMe.sol运行后生成的</p>
<pre><code class="lang-js">//在node.js中我们需要使用require关键字导入依赖
//在前端JS中通过import关键字导入依赖

//我们不想使用node_modules包安装ethers
//将 ethers 库复制到您自己的目录并自己提供服务通常是更好的做法
import { ethers } from &quot;./ethers-5.6.esm.min.js&quot;
import { abi, contractAddress } from &quot;./constants.js&quot; //abi和address都部署到constants.js中了

//定义按钮
const connectButton = document.getElementById(&quot;connectButton&quot;)
const fundButton = document.getElementById(&quot;fundButton&quot;)
connectButton.onclick = connect
fundButton.onclick = fund

console.log(ethers) //输出ethers对象

// 先检查Metatmask钱包是否存在
async function connect() {
    if (typeof window.ethereum !== &quot;undefined&quot;) {
        await window.ethereum.request({ method: &quot;eth_requestAccounts&quot; })
        //引入钱包权限,将Metamask自动连接到我们的网站(网站可以对我们的Metamask进行API调用)
        connectButton.innerHTML = &quot;Connected!&quot; //当通过按钮连接成功时按钮上的字体会变成Connected!
    } else {
        console.log(&quot;No metamask!&quot;)
        connectButton.innerHTML = &quot;Please install metamask&quot; //当连接失败时按钮上的字体会变成Please install metamask
    }
}

// fund
async function fund() {
    const ethAmount = &quot;0.1&quot;
    console.log(`Funding with ${ethAmount}...`)
    if (typeof window.ethereum !== &quot;undefined&quot;) {
        // 发送交易的话都需要什么呢?
        //1.provider / connection to the blockchain
        //2.signer / wallet(someone with some gas)
        //3.我们正在与之交互的合约
        //4.abi和address
        const provider = new ethers.providers.Web3Provider(window.ethereum) //Web3Provider是ethers中的一个对象，它允许我们包装Metamask之类的东西
        //Web3Provider提取Metamask中的http端点并自动为我们放入ethers中,provider在这里连接到我们的Metamask
        const signer = provider.getSigner() //这将从provider处连接到的任何钱包,我们的provider是Metamask
        //signer将是我们连接到前端的帐户

        //一旦签署了合约,地址将会改变,在constants.js里添加地址和abi
        const contract = new ethers.Contract(contractAddress, abi, signer) //ethers的合约对象

        //进行交易
        //设置try-catch的目的是为了让我们在拒绝交易的时候不至于让代码无处可去,报一些奇奇怪怪的错误阻断程序的运行
        try {
            const transactionResponse = await contract.fund({
                value: ethers.utils.parseEther(ethAmount),
            })
        } catch (error) {
            console.log(error)
        }
    }
}
</code></pre>
<h3 id="metamask-">Metamask重置账户</h3>
<p><img src="img/6-1668443374359-319.png" alt="6"></p>
<p>重置账户,以便Metamask与区块链上的随机数同步，在我们使用钱包发送交易莫名报错的时候可以尝试重置账户</p>
<h3 id="-">事件监听&amp;完成交易</h3>
<p>我们的await关键字现在正在等待promise解决还是拒绝，我们只在我们的provider完成promise后找到交易收据中的交易哈希。</p>
<pre><code class="lang-js">//在node.js中我们需要使用require关键字导入依赖
//在前端JS中通过import关键字导入依赖

//我们不想使用node_modules包安装ethers
//将 ethers 库复制到您自己的目录并自己提供服务通常是更好的做法
import { ethers } from &quot;./ethers-5.6.esm.min.js&quot;
import { abi, contractAddress } from &quot;./constants.js&quot; //abi和address都部署到constants.js中了

//定义按钮
const connectButton = document.getElementById(&quot;connectButton&quot;)
const fundButton = document.getElementById(&quot;fundButton&quot;)
connectButton.onclick = connect
fundButton.onclick = fund

console.log(ethers) //输出ethers对象

// 先检查Metatmask钱包是否存在
async function connect() {
    if (typeof window.ethereum !== &quot;undefined&quot;) {
        await window.ethereum.request({ method: &quot;eth_requestAccounts&quot; })
        //引入钱包权限,将Metamask自动连接到我们的网站(网站可以对我们的Metamask进行API调用)
        connectButton.innerHTML = &quot;Connected!&quot; //当通过按钮连接成功时按钮上的字体会变成Connected!
    } else {
        console.log(&quot;No metamask!&quot;)
        connectButton.innerHTML = &quot;Please install metamask&quot; //当连接失败时按钮上的字体会变成Please install metamask
    }
}

// fund
async function fund() {
    const ethAmount = &quot;0.1&quot;
    console.log(`Funding with ${ethAmount}...`)
    if (typeof window.ethereum !== &quot;undefined&quot;) {
        // 发送交易的话都需要什么呢?
        //1.provider / connection to the blockchain
        //2.signer / wallet(someone with some gas)
        //3.我们正在与之交互的合约
        //4.abi和address
        const provider = new ethers.providers.Web3Provider(window.ethereum) //Web3Provider是ethers中的一个对象，它允许我们包装Metamask之类的东西
        //Web3Provider提取Metamask中的http端点并自动为我们放入ethers中,provider在这里连接到我们的Metamask
        const signer = provider.getSigner() //这将从provider处连接到的任何钱包,我们的provider是Metamask
        //signer将是我们连接到前端的帐户

        //一旦签署了合约,地址将会改变,在constants.js里添加地址和abi
        const contract = new ethers.Contract(contractAddress, abi, signer) //ethers的合约对象

        //进行交易
        //设置try-catch的目的是为了让我们在拒绝交易的时候不至于让代码无处可去,报一些奇奇怪怪的错误阻断程序的运行
        try {
            const transactionResponse = await contract.fund({
                value: ethers.utils.parseEther(ethAmount),
            })
            await listenForTransactionMine(transactionResponse, provider) //交易完成了
            console.log(&quot;Done!&quot;)
        } catch (error) {
            console.log(error)
        }
    }
}

//希望前端页面给用户一些提示让其知道交易通过(监听交易)
//JavaScript能够在前端脱颖而出就是因为这个异步函数
//让该函数返回一个promise
function listenForTransactionMine(transactionResponse, provider) {
    console.log(`Mining ${transactionResponse.hash}...`)
    // return new Promise()
    //返回promise的原因就是我们需要为区块链创建一个监听器,监听交易的完成与否

    //如果promise正常运行调用这个resolve函数,对我们来说当监听完成的时候这个promise将会实现,然后如果超时的话我们会调用reject函数
    return new Promise((resolve, reject) =&gt; {
        provider.once(transactionResponse.hash, (transactionReceipt) =&gt; {
            console.log(
                `Completed with ${transactionReceipt.confirmations} confirmations`
            )
            resolve()
        })
    })
}
//当我们调用listenForTransactionMine时,我们的listenForTransactionMine会启动并且它会把provider.once作为自己的主线程
//只是启动这个函数但是不会等待它,我们的前端将会定期检查它是否返回promise
//改进它让它立即返回promise

// withdraw
</code></pre>
<h3 id="-">负责输入的表单</h3>
<p>我们需要一个表单来使得fund的支付更加方便，这样就可以灵活地指定资助的金额了。</p>
<p>前端</p>
<pre><code class="lang-html">        &lt;!-- 表单 --&gt;
        &lt;!-- 添加一个小文本框让我们的输入变得容易 --&gt;
        &lt;!-- label:带有输入字段和相关标记的简单 HTML 表单 --&gt;
        &lt;label for=&quot;fund&quot;&gt;ETH Amount&lt;/label&gt;
        &lt;!-- placeholder:输入框的提示文字 --&gt;
        &lt;input id=&quot;ethAmount&quot; placeholder=&quot;0.1&quot; /&gt;
</code></pre>
<p>后端</p>
<pre><code class="lang-js">const ethAmount = document.getElementById(&quot;ethAmount&quot;).value //定义输入框的内容为发送的价值
</code></pre>
<p><img src="img/7-1668443384462-321.png" alt="7"></p>
<h3 id="-">读区块链数据</h3>
<p>我们需要查看一下合约中募集了多少资金,添加一个getbalance的按钮吧，然后在js中编写好这个按钮的函数后把二者进行交互。</p>
<p>前端</p>
<pre><code class="lang-html">&lt;button id=&quot;balanceButton&quot;&gt;getBalance&lt;/button&gt;
</code></pre>
<p>后端</p>
<pre><code class="lang-js">//getBalance
async function getBalance() {
    //先检查Metamask钱包是否存在
    if (typeof window.ethereum != &quot;undefined&quot;) {
        const provider = new ethers.providers.Web3Provider(window.ethereum) //Web3Provider提取Metamask中的http端点并自动为我们放入ethers中,provider在这里连接到我们的Metamask
        const balance = await provider.getBalance(contractAddress) //从合约地址中获得总募资余额
        console.log(ethers.utils.formatEther(balance)) //将余额的数字格式化,使其更易阅读
    }
}
</code></pre>
<h3 id="withdraw-">Withdraw函数</h3>
<pre><code class="lang-js">// withdraw
async function withdraw() {
    if (typeof window.ethereum != &quot;undefined&quot;) {
        console.log(&quot;Withdrawing...&quot;)
        const provider = new ethers.providers.Web3Provider(window.ethereum) //Web3Provider提取Metamask中的http端点并自动为我们放入ethers中,provider在这里连接到我们的Metamask
        const signer = provider.getSigner() //这将从provider处连接到的任何钱包,我们的provider是Metamask
        const contract = new ethers.Contract(contractAddress, abi, signer) //ethers的合约对象
        try {
            const transactionResponse = await contract.withdraw() //调用withdraw函数
            await listenForTransactionMine(transactionResponse, provider) //交易完成了
            console.log(&quot;资金已撤出!&quot;)
        } catch (error) {
            console.log(error)
        }
    }
}
</code></pre>
<p><img src="img/8-1668443389520-323.png" alt="8"></p>
<h3 id="-">回顾</h3>
<p>我们创建了一个简约的网站,这使我们能够连接到区块链并从前端和网站调用函数。</p>
<p>首先通常我们需要为我们的后端准备存储仓库或者代码库，让我们的智能合约成为和前端不同的存储库，前端代码将是HTML和JavaScript的组合，当我们有一个像Metamask这样的钱包时，我们接入这些基于区块链浏览器的钱包，每个区块链浏览器都有不同的扩展名(Metamask的扩展名是ethereum,所以我们使用window.ethereum来查看是否安装了Metamask钱包)，我们这样做的原因是我们想连接到我们的Metamask中内置的 rpc_url，并用这种方式进行api调用就像我们使用hardhat本地网络一样。</p>
<p>然后我们创建了第一个基于promise的函数，我们有一个监听函数，我们把它包装在promise中等待我们的交易完成后再返回promise，这样在前端中,一旦我们的交易完成后,可以通过控制台告诉用户，然后用户就可以继续做其他事情了。</p>
<h2 id="9-lottery_raffle-hardhat-">9.Lottery_Raffle智能合约(Hardhat)(已)</h2>
<p>我们正在构建一个应用程序，该应用程序允许用户完全去中心化，以允许用户参与公平的可变随机彩票。</p>
<p>我们将在计时器上运行它，彩票将自动触发 sombody 获胜，并这样做以获得一个经过验证的<strong>纯随机数</strong>,我们将使用chainlink VRF来获得经过验证的纯随机数然后我们将使用chainlink keepers来触发自动化以自动选择其中一个获胜者,每次这些时间间隔之一结束时,一旦keepers开始运转,他们将从去中心化彩票中选出一名获胜者。我们会说上一个赢家是xxx,他们将从这个彩票中得到所有的钱。</p>
<p>这就是一个完全公平的去中心化彩票，我们的合约名字为Raffle.sol。</p>
<h3 id="hardhat-">Hardhat配置</h3>
<pre><code>yarn add --dev hardhat@2.9.3
yarn hardhat
</code></pre><p>这次创建空的hardhat项目
接着添加我们所有的依赖项</p>
<pre><code>yarn add --dev @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers @nomiclabs/hardhat-etherscan @nomiclabs/hardhat-waffle chai ethereum-waffle hardhat hardhat-contract-sizer hardhat-deploy hardhat-gas-reporter prettier prettier-plugin-solidity solhint solidity-coverage dotenv
</code></pre><h3 id="raffle-sol-">Raffle.sol配置</h3>
<pre><code class="lang-solidity">//进入彩票（支付一定金额）



//选出一个随机的获胜者(可验证的随机数)，希望这个不会被篡改


//每分钟选出一个获胜者 -&gt; 部署一次，以后完全自动运行



//需要Chainlink预言机来实现-&gt;随机性,自动执行(Chainlink Keepers)


//SPDX-License-Identifier:MIT
pragma solidity ^0.8.8;

error Raffle__NotEnoughETHEntered();


contract Raffle{
    /* State Variables */
    uint256 private immutable i_entranceFee;//入场费(不可变)
    address payable[] private s_players;//玩家(玩家获胜我们需要付钱给他们)


    constructor(uint entranceFee){
        i_entranceFee = entranceFee;
    }



    //进入彩票
    function enterRaffle() public payable{
        //require (msg.value &gt; i_entranceFee, &quot;Not enough ETH!&quot;)
        //下面这种写法比较节省Gas费
        if(msg.value &lt; i_entranceFee){
            revert Raffle__NotEnoughETHEntered(); 
        }
        s_players.push(payable(msg.sender));//加入应付帐款地址作为新的玩家

    }

    //选出随机的获胜者
    // function pickRandomWinner(){}


    //其他用户查看入场费
    function getEntranceFee() public view returns(uint256){
        return i_entranceFee;
    }

    //查看用户
    function getPlayer(uint index) public view returns(address){
        return s_players[index];
    }
}
</code></pre>
<h3 id="events-">Events介绍</h3>
<p>每当我们更新一个动态对象(数组或映射),我们总是想发出一个事件。</p>
<p>首先我们知道EVM制作了很多像以太坊一样的区块链，并且EVM具有日志记录功能，当区块链上发生事情时，EVM 会将这些事情写入称为日志的特定数据结构，我们可以从运行的节点中读取这些日志，在这些日志里面是一个被称为事件的重要部分。</p>
<p>事件允许你将内容“打印”到此日志(这种方法的Gas效率比将内容保存在Storage里要高)，智能合约无法访问日志这种数据结构。</p>
<p>这些事件中的每一个都与在这些交易中忽略此事件的智能合约或账户地址相关联，监听这些事件非常有帮助。</p>
<p>比如说:</p>
<p>每次有人调用传递函数时，您都想做一些事情，而不是总是读取所有变量并寻找一些可以翻转和切换的变量，您所要做的就是监听事件。</p>
<p>所以发生了一笔交易并完成了事件我们可以监听这些事件，这就是许多链下基础设施的工作方式，当您在一个网站上并且该网站在交易完成时重新加载时，<strong>它实际上正在等待该交易完成并监听要发出的事件以便它可以重新加载或执行其他操作</strong>，这对前端/chainlink非常重要。</p>
<p>在chainlink网络中，chainlink节点实际上是在监听请求数据事件例如调用api这种。有时候有太多的事件你需要以一种有意义的方式索引它们，这样你就可以查询发生的所有这些事件，Graph监听这些事件并将他们存储在Graph中，这样他们以后很方便查询。</p>
<p><strong>事件机制是合约中非常重要的一个设计。事件允许将信息记录到区块链上，DAPP等应用可以通过监听事件来实现业务逻辑，存储成本很低。以下是一个简单的日志抛出机制。</strong></p>
<p><strong>事件的语法样式</strong></p>
<pre><code class="lang-solidity">event storedNumber(
        uint256 indexed oldNumber,
        uint256 indexed newNumber,
        uint256 addedNumber,
        address sebder
);
</code></pre>
<p>indexed是一个非常重要的关键字,最多可以拥有三个indexed参数,它们也被称为主题(topics),索引参数是比非索引参数更容易搜索和查询的参数，事实上，早在getlog()函数，它甚至有一个参数允许让我们搜索特定主题，所以说它比非索引更容易搜索。</p>
<p>非索引更难搜索是因为他们有abi编码，必须知道abi才能解码它们。</p>
<p>索引参数的过滤:var event = myContract.transfer({value:[&quot;99&quot;,&quot;100&quot;,&quot;101&quot;]});</p>
<p><strong>发送事件</strong></p>
<pre><code>emit storedNumber{
            favoriteNumber,
            _favoriteNumber,
            _favoriteNumber + favoriteNumber,
            msg.sender
};
</code></pre><p><strong>具有事件的合约的完整示例</strong></p>
<pre><code class="lang-solidity">//SPDX-License-Identifier:MIT
pragma solidity ^0.8.7;
contract SimpleStorage{
    uint256 favoriteNumber;
    event storedNumber(
        uint256 indexed oldNumber,
        uint256 indexed newNumber,
        uint256 addedNumber,
        address sender
    );
    //当有人调用store函数时,我们会发出这个事件
    function store(uint256 _favoriteNumber) public {
        emit storedNumber(
            favoriteNumber,
            _favoriteNumber,
            _favoriteNumber + favoriteNumber,
            msg.sender
        );
        favoriteNumber = _favoriteNumber;
    }

    function retrive() public view returns (uint256) {
        return favoriteNumber;
    } 
}
</code></pre>
<p>在下面这个交易当中,我们调用了值为1的store函数，事件将像下面这样被分解</p>
<p><img src="img/1-1668443397000-325.png" alt="1"></p>
<p>Data是是事件的abi编码的非索引参数。这意味着我们获取了那些未索引的参数，我们将它们与它们的 abi 或应用程序二进制接口匹配在一起，通过编码算法将它们输入。如果有abi的话很容易解码,如果没有abi的话他们很难解码，这些非索引参数写入日志时消耗更少的Gas费。</p>
<h3 id="raffle-sol-events">Raffle.sol中的Events</h3>
<p><img src="img/2-1668443401943-327.png" alt="2"></p>
<h3 id="chainlink-vrf-">Chainlink VRF介绍(可验证的随机函数)</h3>
<p>关于 VRF 版本 2 最重要的一点是，您将通过链接为合约提供资金，但并不是使用通过链接为合约提供资金的 VRF 版本1模型，而是使用订阅为合约提供资金的模型，这基本上允许您为多个消费者合约提供资金并保存余额。</p>
<p><img src="img/3-1668443405992-329.png" alt="3"></p>
<p>订阅地址是使用VRF的重心,订阅地址就是我们注资的账户,我们可以使用该账户来处理我们所有的随机性请求，然后添加资金(请求每个随机数的link价格将基于给定链上的当前 Gas 费率以及您选择的 Gas 车道)，资金添加完之后我们继续添加消费者合约，它要求我们提供消费者地址(这时候我们前往Chainlink官方文档并创建一个将请求一个数字的合约)，</p>
<p><img src="img/4-1668443409861-331.png" alt="4"></p>
<p>keyhash是我们所指定的Gas车道，因此，根据您为给定链选择的 keyhash，您的 Gas 限制将针对您的随机数请求进行不同的设置。</p>
<p>最重要的功能是我们可以指定我们想要的随机数</p>
<p>部署该合约获得消费者地址后重回VRF订阅处</p>
<p><img src="img/5-1668443415040-333.png" alt="5"></p>
<p>将部署后的地址添加为消费者之后,我们已经成功授权我们的消费者合约获得请求随机性功能。</p>
<p><img src="img/6-1668443419336-335.png" alt="6"></p>
<p>我们请求随机数之后,我们会等待预言机在我们的合约上调用随机数然后我们将存储所有这些随机数</p>
<p><img src="img/7-1668443422363-337.png" alt="7"></p>
<p><img src="img/8-1668443430630-339.png" alt="8"></p>
<h3 id="chainlink-vrf-">Chainlink VRF应用</h3>
<p>安装Chainlink的库</p>
<pre><code>yarn add --dev @chainlink/contracts
</code></pre><p>主要是构造函数和获得随机数的函数的重写</p>
<pre><code class="lang-solidity">//进入彩票（支付一定金额）
//选出一个随机的获胜者(可验证的随机数)，希望这个不会被篡改
//每分钟选出一个获胜者 -&gt; 部署一次，以后完全自动运行
//需要Chainlink预言机来实现-&gt;随机性,自动执行(Chainlink Keepers)

//SPDX-License-Identifier:MIT
pragma solidity ^0.8.8;

//导入chainlink的VRF消费者合约
import &quot;@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol&quot;;

error Raffle__NotEnoughETHEntered();

contract Raffle is VRFConsumerBaseV2 {
    /* State Variables */
    uint256 private immutable i_entranceFee; //入场费(不可变)
    address payable[] private s_players; //玩家(玩家获胜我们需要付钱给他们)

    /* Events */
    //函数名称颠倒的事件名称
    event RaffleEnter(address indexed player);

    //做随机数验证的合同地址也要加入构造函数(模仿的是VRFConsumerBasV2这个合约)
    constructor(address vrfCoordinatorV2, uint256 entranceFee) VRFConsumerBaseV2(vrfCoordinatorV2) {
        i_entranceFee = entranceFee;
    }

    //进入彩票
    function enterRaffle() public payable {
        //require (msg.value &gt; i_entranceFee, &quot;Not enough ETH!&quot;)
        //下面这种写法比较节省Gas费
        if (msg.value &lt; i_entranceFee) {
            revert Raffle__NotEnoughETHEntered();
        }
        s_players.push(payable(msg.sender)); //加入应付帐款地址作为新的玩家
        //Events
        emit RaffleEnter(msg.sender); //发送事件
    }

    //选出随机的获胜者(这就是我们需要在 Chainlin Keepers 中使用 Chainlink VRF 的地方)
    function requestRandomWinner() external {
        //请求随机数
        //得到随机数后
        //Chainlink VRF是两个交易过程(如果只是一个交易过程人们可以用蛮力尝试模拟调用此事务)
    }

    //重写Chanlink VRF合约中的这个函数
    //Chainlink节点调用此函数,得到随机数
    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords)
        internal
        override
    {}

    //其他用户查看入场费
    /*View/Pure 函数 */
    function getEntranceFee() public view returns (uint256) {
        return i_entranceFee;
    }

    //查看用户
    function getPlayer(uint256 index) public view returns (address) {
        return s_players[index];
    }
}
</code></pre>
<h3 id="hardhat-shorthand">Hardhat shorthand</h3>
<p>Hardhat 有一个配套的 npm 包，它充当 的简写<code>npx hardhat</code>，同时，它可以在终端中启用命令行完成。</p>
<p>这个包<code>hardhat-shorthand</code>安装了一个全局可访问的二进制文件<code>hh</code>，它运行你本地安装的<code>hardhat</code>.</p>
<p>运行下面这个命令安装该库</p>
<pre><code>yarn global add hardhat-shorthand
</code></pre><p>现在我们再运行命令的时候就可以用hh来代替yarn hardhat。</p>
<h3 id="chainlink-vrf-request-">Chainlink VRF应用(request)</h3>
<pre><code class="lang-solidity">  //选出随机的获胜者(这就是我们需要在 Chainlin Keepers 中使用 Chainlink VRF 的地方)
    function requestRandomWinner() external {
        //请求随机数(首先在vrfCoordinatorV2地址上调用这个函数)

        uint256 requestId = i_vrfCoordinator.requestRandomWords(
            i_gasLane, //Gas通道
            i_subscriptionId, //订阅ID(用于资助请求)我们需要订阅id来请求随机数并支付link币来作为预言机的Gas费
            REQUEST_CONFIRMATIONS, //Chainlink节点在响应之前应该等待多少次确认。节点等待的时间越长，随机值就越安全。它必须大于coordinator合约的REQUEST_CONFIRMATIONS
            i_callbackGasLimit, //对合约的fulfillRandomWords() 函数的回调请求使用多少gas 的限制,必须小于callbackGasLimit限制。
            NUM_WORDS //我们想得到多少随机数
        );
        //得到随机数后要做的事
        emit RequestedRaffleWinner(requestId); //发送随机数事件
        //Chainlink VRF是两个交易过程(如果只是一个交易过程人们可以用蛮力尝试模拟调用此事务)
    }
</code></pre>
<h3 id="chainlink-vrf-fulfill-">Chainlink VRF应用(fulfill)</h3>
<pre><code class="lang-solidity">//重写Chanlink VRF合约中的这个函数
//Chainlink节点调用此函数,得到获胜者
 function fulfillRandomWords(
        uint256, /*requestId*/
        uint256[] memory randomWords
    ) internal override {
        //我们可以使用Modulo函数从我们的玩家数组中获取一个随机数
        //Modulo函数的原理是什么样子的呢?
        //假设s_player数组的长度大小是10,随机数是202
        // 202 % 10 = 2,我们使用索引2作为胜利者索引

        uint256 indexOfWinner = randomWords[0] % s_players.length; //获得胜利者在玩家数组中的索引
        address payable recentWinner = s_players[indexOfWinner]; //获得胜利者的地址(可验证的随机获胜者)
        s_recentWinner = recentWinner; //把获胜者放入storage中
        (bool success, ) = recentWinner.call{value: address(this).balance}(&quot;&quot;); //把余额里的钱汇给获胜者
        //require(success)
        if (!success) {
            revert Raffle__TransferFailed(); //如果不成功的话我们将恢复一个新的传输失败错误
        }
        emit WinnerPicked(recentWinner); //发送一个事件用来查询历届获奖名单
    }
</code></pre>
<h3 id="chainnlink-keepers-chainlink-keepers-chainlink-automation-">Chainnlink Keepers介绍(Chainlink Keepers 现在更名为 Chainlink Automation)</h3>
<p>Chainlink Automation 可以自动化执行我们的的合约并让合约访问链下计算.</p>
<p>Chainlink Automation 将使用各种触发器可靠地执行智能合约功能。</p>
<p>为了启动某种类型的交易,有的人需要花费Gas,有的人需要坐下来按下开始按钮/交易按钮,这显然是一个集中向量,如果你有一个去中心化的应用程序需要在特定时间/特定事件触发之后运行,Chainlink Keepers 是解决此问题的方法。Chainlink Keepers是Chainlink节点用来登记合约的功能，对于你指定要触发的不同事件(比如每10分钟喝一次水或当BTC的价格突破10万美金的时候把它给卖掉),无论编写什么事件都可以,Chainlink节点不断监听,让这些触发器发生,并检查这些触发器的不同合约,一旦触发器返回true,然后Chainlink节点将执行设定的操作。</p>
<p>这就像一个闹钟一样。</p>
<h3 id="chainlink-keepers-checkupkeep-">Chainlink Keepers应用(checkUpkeep)</h3>
<pre><code> /**
     * @dev 这是chainlink keeper节点调用的函数，他们寻找“upkeepNeeded”以返回true
     * 如果upkeepNeeded为true,这意味着是时候获取一个新的随机数了
     * 返回true的条件为:
     * 1.我们的时间间隔已经过去了
     * 2.彩票合约至少有一位参与者,并且有一些ETH在合约账户上
     * 3.我们的订阅由 LINK 资助
     * 4.彩票应处于“打开”状态(需要一些状态变量)
     */
    function checkUpkeep(
        bytes calldata /*checkData*/
    ) external override {}
</code></pre><h3 id="enum">Enum</h3>
<p>枚举可用于创建具有一组有限“常量值”的自定义类型。</p>
<pre><code> /* 枚举类型声明 */
    //彩票状态
    enum RaffleState {
        OPEN,
        CALCULATING
    } //当我们创建这样的枚举时,我们其实是在创建这样的常量值规则:uint256 0 = OPEN, 1 = CALCULATING
</code></pre><p>创建出这样的枚举类型可以在其他函数中控制彩票的开启和暂时中断</p>
<h3 id="chainlink-keepers-checkupkeep-">Chainlink Keepers应用(继续checkUpkeep)</h3>
<pre><code class="lang-solidity"> /**
     * @dev 这是chainlink keeper节点调用的函数，他们寻找“upkeepNeeded”以返回true
     * 如果upkeepNeeded为true,这意味着是时候获取一个新的随机数了
     * 返回true的条件为:
     * 1.我们的时间间隔已经过去了
     * 2.彩票合约至少有一位参与者,并且有一些ETH在合约账户上
     * 3.我们的订阅由 LINK 资助
     * 4.彩票应处于“打开”状态(需要一些状态变量)
     */
    function checkUpkeep(
        bytes calldata /*checkData*/
    )
        external
        override
        returns (
            bool upkeepNeeded,
            bytes memory /* performData(执行数据) */
        )
    {
        //上述四个条件都通过后,该函数返回真,我们将触发Chainlink Keepers去调用requestRandomWinner()函数
        bool isOpen = (RaffleState.OPEN == s_raffleState); //彩票应处于&quot;打开&quot;状态
        bool timePassed = ((block.timestamp - s_lastTimeStamp) &gt; i_interval); //检查时间间隔;要求 (block.timestamp - last block timestamp) &gt; 区间间隔(在两轮不同彩票运行之间我们想等待多久)
        bool hasPlayers = (s_players.length &gt; 0); //检查我们是否有足够的玩家
        bool hasBalance = address(this).balance &gt; 0; //彩票合约里是否有足够的钱
        upkeepNeeded = (isOpen &amp;&amp; timePassed &amp;&amp; hasPlayers &amp;&amp; hasBalance); //以上所有条件满足后才开始触发调用
    }
</code></pre>
<h3 id="chainlink-keepers-performupkeep-">Chainlink Keepers应用(performUpkeep)</h3>
<p>把requestRandomWinner()函数改为performUpKeep</p>
<pre><code class="lang-solidity"> //选出随机的获胜者(这就是我们需要在 Chainlin Keepers 中使用 Chainlink VRF 的地方)
    //以编程的方式自动去选择可验证的获胜者(checkUpkeep)
    //我们要确保该函数只会被触发函数checkUpkeep调用
    function performUpkeep(
        bytes calldata /* performData */
    ) external override {
        (bool upkeepNeeded, ) = checkUpkeep(&quot;&quot;);//重要
        //if（!a）和if(a==0)等价
        //确保彩票合约真正&quot;打开&quot;
        if (!upkeepNeeded) {
            revert Raffle__UpkeepNotNeeded(
                address(this).balance,
                s_players.length,
                uint256(s_raffleState)
            ); //往此错误中传递一些变量,这样无论谁遇到这个错误,可以清晰地看到为什么他们得到这个错误
        }
        //请求随机数(首先在vrfCoordinatorV2地址上调用这个函数)
        s_raffleState = RaffleState.CALCULATING; //在获得随机数的时候暂时中断彩票合约以便没有人可以进入我们的彩票并且没有人可以触发新的更新
        uint256 requestId = i_vrfCoordinator.requestRandomWords(
            i_gasLane, //Gas通道
            i_subscriptionId, //订阅ID(用于资助请求)我们需要订阅id来请求随机数并支付link币来作为预言机的Gas费
            REQUEST_CONFIRMATIONS, //Chainlink节点在响应之前应该等待多少次确认。节点等待的时间越长，随机值就越安全。它必须大于coordinator合约的REQUEST_CONFIRMATIONS
            i_callbackGasLimit, //对合约的fulfillRandomWords() 函数的回调请求使用多少gas 的限制,必须小于callbackGasLimit限制。
            NUM_WORDS //我们想得到多少随机数
        );
        //得到随机数后要做的事
        emit RequestedRaffleWinner(requestId); //发送随机数事件
        //Chainlink VRT是两个交易过程(如果只是一个交易过程人们可以用蛮力尝试模拟调用此事务)
    }
</code></pre>
<h3 id="-">代码整理</h3>
<p>添加一些Natspec，Solidity 合约可以使用一种特殊形式的注释来为函数、返回变量等提供丰富的文档。这种特殊形式被命名为以太坊自然语言规范格式（NatSpec）。</p>
<pre><code class="lang-solidity">//进入彩票（支付一定金额）
//选出一个随机的获胜者(可验证的随机数)，希望这个不会被篡改
//每分钟选出一个获胜者 -&gt; 部署一次，以后完全自动运行
//需要Chainlink预言机来实现-&gt;随机性,自动执行(Chainlink Keepers)

//SPDX-License-Identifier:MIT
pragma solidity ^0.8.8;

//导入chainlink的VRF消费者合约
import &quot;@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol&quot;;

//导入vrfCoordinatorV2地址使用的接口合约
import &quot;@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol&quot;;

//导入checkUpkeep()函数所使用的接口合约
import &quot;@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol&quot;;

error Raffle__NotEnoughETHEntered();
error Raffle__TransferFailed();
error Raffle__NotOpen();
error Raffle__UpkeepNotNeeded(uint256 currentBalnace, uint256 numPlayers, uint256 raffleState);

/**@title 一个彩票抽奖合约样本
 * @author Loop Love
 * @notice 该合约用于创建不可篡改的去中心化智能合约
 * @dev 该合约实现了 Chainlink VRF V2 和 Chainlink Keepers
 */

contract Raffle is VRFConsumerBaseV2, KeeperCompatibleInterface {
    /* 枚举类型声明 */
    //彩票状态
    enum RaffleState {
        OPEN,
        CALCULATING
    } //当我们创建这样的枚举时,我们其实是在创建这样的常量值规则:uint256 0 = OPEN, 1 = CALCULATING

    /* State Variables */
    uint256 private immutable i_entranceFee; //入场费(不可变)
    address payable[] private s_players; //玩家(玩家获胜我们需要付钱给他们)
    VRFCoordinatorV2Interface private immutable i_vrfCoordinator; //创建接口对象
    bytes32 private immutable i_gasLane; //Gas通道
    uint64 private immutable i_subscriptionId; //订阅id
    uint32 private immutable i_callbackGasLimit; //回调请求Gas费限制
    uint16 private constant REQUEST_CONFIRMATIONS = 3; //区块确认次数
    uint32 private constant NUM_WORDS = 1; //随机数 数量

    //彩票变量
    address private s_recentWinner; //新决出的获胜者
    RaffleState private s_raffleState; //彩票合约状态
    uint256 private s_lastTimeStamp; //上一轮彩票的结束时间
    uint256 private immutable i_interval; //自定义彩票区间(开局定义,永不再变)

    /* Events */
    //函数名称颠倒的事件名称
    event RaffleEnter(address indexed player); //参与的玩家的事件
    event RequestedRaffleWinner(uint256 indexed requestId); //随机数事件
    event WinnerPicked(address indexed winner); //历届获奖名单事件

    /* 函数 */

    //做随机数验证的合同地址也要加入构造函数(模仿的是VRFConsumerBasV2这个合约)
    constructor(
        address vrfCoordinatorV2,
        uint256 entranceFee,
        bytes32 gasLane,
        uint64 subscriptonId,
        uint32 callbackGasLimit,
        uint256 interval
    ) VRFConsumerBaseV2(vrfCoordinatorV2) {
        i_entranceFee = entranceFee;
        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinatorV2); //初始化构造接口对象,这个合约地址的对象拥有接口的全部功能
        i_gasLane = gasLane;
        i_subscriptionId = subscriptonId;
        i_callbackGasLimit = callbackGasLimit;
        s_raffleState = RaffleState.OPEN;
        s_lastTimeStamp = block.timestamp;
        i_interval = interval;
    }

    //进入彩票
    function enterRaffle() public payable {
        //require (msg.value &gt; i_entranceFee, &quot;Not enough ETH!&quot;)
        //下面这种写法比较节省Gas费
        //入场费小于最低金额的话恢复错误
        if (msg.value &lt; i_entranceFee) {
            revert Raffle__NotEnoughETHEntered();
        }
        //彩票不打开的话也是恢复错误
        if (s_raffleState != RaffleState.OPEN) {
            revert Raffle__NotOpen();
        }

        s_players.push(payable(msg.sender)); //加入应付帐款地址作为新的玩家
        //Events
        emit RaffleEnter(msg.sender); //发送参与玩家事件
    }

    /**
     * @dev 这是chainlink keeper节点调用的函数，他们寻找“upkeepNeeded”以返回true
     * 如果upkeepNeeded为true,这意味着是时候获取一个新的随机数了
     * 返回true的条件为:
     * 1.我们的时间间隔已经过去了
     * 2.彩票合约至少有一位参与者,并且有一些ETH在合约账户上
     * 3.我们的订阅由 LINK 资助
     * 4.彩票应处于“打开”状态(需要一些状态变量)
     */
    function checkUpkeep(
        bytes memory /*checkData*/
    )
        public
        override
        returns (
            bool upkeepNeeded,
            bytes memory /* performData(执行数据) */
        )
    {
        //上述四个条件都通过后,该函数返回真,我们将触发Chainlink Keepers去调用performUpkeep()函数
        bool isOpen = (RaffleState.OPEN == s_raffleState); //彩票应处于&quot;打开&quot;状态
        bool timePassed = ((block.timestamp - s_lastTimeStamp) &gt; i_interval); //检查时间间隔;要求 (block.timestamp - last block timestamp) &gt; 区间间隔(在两轮不同彩票运行之间我们想等待多久)
        bool hasPlayers = (s_players.length &gt; 0); //检查我们是否有足够的玩家
        bool hasBalance = address(this).balance &gt; 0; //彩票合约里是否有足够的钱
        upkeepNeeded = (isOpen &amp;&amp; timePassed &amp;&amp; hasPlayers &amp;&amp; hasBalance); //以上所有条件满足后才开始触发调用
    }

    //选出随机的获胜者(这就是我们需要在 Chainlin Keepers 中使用 Chainlink VRF 的地方)
    //以编程的方式自动去选择可验证的获胜者(checkUpkeep)
    //我们要确保该函数只会被触发函数checkUpkeep调用
    function performUpkeep(
        bytes calldata /* performData */
    ) external override {
        (bool upkeepNeeded, ) = checkUpkeep(&quot;&quot;); //calldata不适用于字符串
        //if（!a）和if(a==0)等价
        //确保彩票合约真正&quot;打开&quot;
        if (!upkeepNeeded) {
            revert Raffle__UpkeepNotNeeded(
                address(this).balance,
                s_players.length,
                uint256(s_raffleState)
            ); //往此错误中传递一些变量,这样无论谁遇到这个错误,可以清晰地看到为什么他们得到这个错误
        }
        //请求随机数(首先在vrfCoordinatorV2地址上调用这个函数)
        s_raffleState = RaffleState.CALCULATING; //在获得随机数的时候暂时中断彩票合约以便没有人可以进入我们的彩票并且没有人可以触发新的更新
        uint256 requestId = i_vrfCoordinator.requestRandomWords(
            i_gasLane, //Gas通道
            i_subscriptionId, //订阅ID(用于资助请求)我们需要订阅id来请求随机数并支付link币来作为预言机的Gas费
            REQUEST_CONFIRMATIONS, //Chainlink节点在响应之前应该等待多少次确认。节点等待的时间越长，随机值就越安全。它必须大于coordinator合约的REQUEST_CONFIRMATIONS
            i_callbackGasLimit, //对合约的fulfillRandomWords() 函数的回调请求使用多少gas 的限制,必须小于callbackGasLimit限制。
            NUM_WORDS //我们想得到多少随机数
        );
        //得到随机数后要做的事
        emit RequestedRaffleWinner(requestId); //发送随机数事件
        //Chainlink VRT是两个交易过程(如果只是一个交易过程人们可以用蛮力尝试模拟调用此事务)
    }

    //重写Chanlink VRF合约中的这个函数
    //Chainlink节点调用此函数,得到获胜者
    function fulfillRandomWords(
        uint256, /*requestId*/
        uint256[] memory randomWords
    ) internal override {
        //我们可以使用Modulo函数从我们的玩家数组中获取一个随机数
        //Modulo函数的原理是什么样子的呢?
        //假设s_player数组的长度大小是10,随机数是202
        // 202 % 10 = 2,我们使用索引2作为胜利者索引

        uint256 indexOfWinner = randomWords[0] % s_players.length; //获得胜利者在玩家数组中的索引
        address payable recentWinner = s_players[indexOfWinner]; //获得胜利者的地址(可验证的随机获胜者)
        s_recentWinner = recentWinner; //把获胜者放入storage中
        s_raffleState = RaffleState.OPEN; //挑选出获胜者之后重新开启新一轮彩票
        s_players = new address payable[](0); //挑选出获胜者后需要重置我们的s_players数组
        s_lastTimeStamp = block.timestamp; //挑选出获胜者后需要重置上一轮彩票的结束时间
        (bool success, ) = recentWinner.call{value: address(this).balance}(&quot;&quot;); //把余额里的钱汇给获胜者
        //require(success)
        if (!success) {
            revert Raffle__TransferFailed(); //如果不成功的话我们将恢复一个新的传输失败错误
        }
        emit WinnerPicked(recentWinner); //发送一个事件用来查询历届获奖名单
    }

    /* View/Pure 函数 */
    //其他用户查看入场费
    function getEntranceFee() public view returns (uint256) {
        return i_entranceFee;
    }

    //查看用户
    function getPlayer(uint256 index) public view returns (address) {
        return s_players[index];
    }

    //获取赢家
    function getRecentWinner() public view returns (address) {
        return s_recentWinner;
    }

    //获取彩票状态
    function getRaffleState() public view returns (RaffleState) {
        return s_raffleState;
    }

    //获取随机数 数量
    function getNumWords() public pure returns (uint256) {
        return NUM_WORDS; //常量变量
    }

    //获取玩家的数量
    function getNumberOfPlayers() public view returns (uint256) {
        return s_players.length;
    }

    //获取最新的时间
    function getLatestTimeStamp() public view returns (uint256) {
        return s_lastTimeStamp;
    }

    //获取区块确认次数
    function getRequestConfirmations() public pure returns (uint256) {
        return REQUEST_CONFIRMATIONS;
    }
}

</code></pre>
<p>我们现在有办法得到一个随机数，我们有办法在去中心化的环境中自动执行选择获胜者随机数函数，我们有办法让人们使用我们的抽奖函数以用来参加此彩票。我们创建了真正公平的去中心化彩票。</p>
<h3 id="-raffle-sol">部署Raffle.sol</h3>
<p>几乎不可能在不犯任何错误和不看任何文档的前提下编写完整的智能合约。</p>
<p>配置好hardhat.config.js，01-deploy-raffle.js，00-deploy-mock.js，helper-hardhat-config.js，verify.js</p>
<h3 id="raffle-sol-">Raffle.sol单元测试</h3>
<p>Raffle.test.js</p>
<h4 id="testing-events-chai-matchers">Testing events &amp; Chai Matchers</h4>
<p>进行发出事件的测试</p>
<pre><code class="lang-js">const { assert, expect } = require(&quot;chai&quot;)
const { getNamedAccounts, deployments, ethers, network } = require(&quot;hardhat&quot;)
const { developmentChains, networkConfig } = require(&quot;../../helper-hardhat-config&quot;)

//我们的单元测试只在开发链上运行
!developmentChains.includes(network.name)
    ? describe.skip
    : describe(&quot;Raffle&quot;, function () {
          //将这些变量粘贴到 beforeEach 之外，以便我们所有的 it() 都可以与它们交互
          let raffle, vrfCoordinatorV2Mock, raffleEntranceFee, deployer, interval
          const chainId = network.config.chainId

          //该函数会告诉我们在每个it()前/我们的测试框架在每次测试前需要做什么
          //在这里,我们需要部署我们的Raffle合约,以至于我们每次测试的时候都能有一份全新的合约与我们的每一项测试进行交互
          beforeEach(async function () {
              deployer = (await getNamedAccounts()).deployer
              await deployments.fixture([&quot;all&quot;]) //fixture的作用是它允许我们使用我们all标签来运行我们的整个部署文件夹
              raffle = await ethers.getContract(&quot;Raffle&quot;, deployer) //getContract将获取我们告诉它的合约的最新部署,把合约部署者账户连接入合约中
              //每当我们用raffle调用一个函数时,它将自动来自合约部署者账户
              vrfCoordinatorV2Mock = await ethers.getContract(&quot;VRFCoordinatorV2Mock&quot;, deployer)
              raffleEntranceFee = await raffle.getEntranceFee()
              interval = await raffle.getInterval()
          })
          //构造函数
          describe(&quot;constructor&quot;, function () {
              it(&quot;正确初始化彩票&quot;, async function () {
                  //理想情况下，我们测试每个“it”只使用一个assert
                  const raffleState = await raffle.getRaffleState() //确保彩票状态正确
                  assert.equal(raffleState.toString(), &quot;0&quot;)
                  assert.equal(interval.toString(), networkConfig[chainId][&quot;interval&quot;]) //确保自定义彩票区间正确
              })
          })
          //进入彩票
          describe(&quot;enterRaffle&quot;, function () {
              it(&quot;当您支付的金额不足时,它会恢复&quot;, async function () {
                  await expect(raffle.enterRaffle()).to.be.revertedWith(
                      &quot;Raffle__NotEnoughETHEntered&quot;
                  )
              })
              it(&quot;当玩家进入时记录&quot;, async function () {
                  await raffle.enterRaffle({ value: raffleEntranceFee }) //调用raffle合约的enterRaffle函数,并且把入场费传了进去
                  const playerFromContract = await raffle.getPlayer(0) //获得玩家数组的首元素(部署者)
                  assert.equal(playerFromContract, deployer)
              })
              it(&quot;进入时发出事件&quot;, async function () {
                  await expect(raffle.enterRaffle({ value: raffleEntranceFee })).to.emit(
                      raffle,
                      &quot;RaffleEnter&quot;
                  )
              })
              it(&quot;当彩票正在计算的时候不允许进入&quot;, async function () {
                  await raffle.enterRaffle({ value: raffleEntranceFee }) //传入入场费
                  await network.provider.send(&quot;evm_increaseTime&quot;, [interval.toNumber() + 1]) //增加我们区块链的时间,必须有新的区块产生这样的话新增加的时间才有意义
                  await network.provider.request({ method: &quot;evm_mine&quot;, params: [] }) //挖掘或创建新的区块
                  //我们假装是Chainlink Keeper
                  await raffle.performUpkeep([]) //调用performUpkeep通过这个函数让我们的彩票进入计算状态
                  await expect(raffle.enterRaffle({ value: raffleEntranceFee })).to.be.revertedWith(
                      &quot;Raffle__NotOpen&quot;
                  ) //如果彩票活动正在计算,则正确还原错误
              })
          })
          //这是chainlink keeper节点调用的函数，他们寻找“upkeepNeeded”以返回true
          describe(&quot;checkUpkeep&quot;, function () {
              it(&quot;如果人们没有发送任何 ETH,则返回 false&quot;, async function () {
                  await network.provider.send(&quot;evm_increaseTime&quot;, [interval.toNumber() + 1]) //增加我们区块链的时间,必须有新的区块产生这样的话新增加的时间才有意义
                  await network.provider.request({ method: &quot;evm_mine&quot;, params: [] }) //挖掘或创建新的区块
                  const { upkeepNeeded } = await raffle.callStatic.checkUpkeep(&quot;0x&quot;) //调用checkUpkeep(但是我们不想发送交易,只是想模拟发送此交易并查看upkeepNeeded---可以使用callstatic来完成)
                  assert(!upkeepNeeded) //确保没人发送ETH的时候会返回false
              })
              it(&quot;如果彩票没有打开,则返回 false&quot;, async function () {
                  await raffle.enterRaffle({ value: raffleEntranceFee }) //传入入场费
                  await network.provider.send(&quot;evm_increaseTime&quot;, [interval.toNumber() + 1])
                  await network.provider.request({ method: &quot;evm_mine&quot;, params: [] })
                  await raffle.performUpkeep([]) //调用performUpkeep通过这个函数让我们的彩票进入计算状态
                  const raffleState = await raffle.getRaffleState() //获得彩票如今的状态
                  const { upkeepNeeded } = await raffle.callStatic.checkUpkeep(&quot;0x&quot;)
                  assert.equal(raffleState.toString(), &quot;1&quot;) //确保彩票状态没有打开的时候返回1
                  assert.equal(upkeepNeeded, false) //确保彩票状态没有打开的时候会返回false
              })
              it(&quot;如果没有经过足够的时间，则返回 false&quot;, async () =&gt; {
                  await raffle.enterRaffle({ value: raffleEntranceFee })
                  await network.provider.send(&quot;evm_increaseTime&quot;, [interval.toNumber() - 5]) // use a higher number here if this test fails
                  await network.provider.request({ method: &quot;evm_mine&quot;, params: [] })
                  const { upkeepNeeded } = await raffle.callStatic.checkUpkeep(&quot;0x&quot;) // upkeepNeeded = (timePassed &amp;&amp; isOpen &amp;&amp; hasBalance &amp;&amp; hasPlayers)
                  assert(!upkeepNeeded)
              })
              it(&quot;如果经过足够的时间、有玩家、eth 并且是开放的，则返回 true&quot;, async () =&gt; {
                  await raffle.enterRaffle({ value: raffleEntranceFee })
                  await network.provider.send(&quot;evm_increaseTime&quot;, [interval.toNumber() + 1])
                  await network.provider.request({ method: &quot;evm_mine&quot;, params: [] })
                  const { upkeepNeeded } = await raffle.callStatic.checkUpkeep(&quot;0x&quot;) // upkeepNeeded = (timePassed &amp;&amp; isOpen &amp;&amp; hasBalance &amp;&amp; hasPlayers)
                  assert(upkeepNeeded)
              })
          })
          //以编程的方式自动去选择可验证的获胜者(checkUpkeep)
          describe(&quot;performUpkeep&quot;, function () {
              it(&quot;只有当“checkupkeep”为真时它才能运行&quot;, async function () {
                  await raffle.enterRaffle({ value: raffleEntranceFee })
                  await network.provider.send(&quot;evm_increaseTime&quot;, [interval.toNumber() + 1])
                  await network.provider.send(&quot;evm_mine&quot;, [])
                  const tx = await raffle.performUpkeep([]) //调用performUpkeep函数来确保我们的测试能够进行
                  assert(tx) //看看是真是假
              })
              it(&quot;当“checkupKeep”为假时它能恢复错误&quot;, async function () {
                  await expect(raffle.performUpkeep([])).to.be.revertedWith(
                      &quot;Raffle__UpkeepNotNeeded&quot;
                  )
              })
              it(&quot;更新彩票状态、发送和事件，并调用 vrf 协调器&quot;, async function () {
                  await raffle.enterRaffle({ value: raffleEntranceFee })
                  await network.provider.send(&quot;evm_increaseTime&quot;, [interval.toNumber() + 1])
                  await network.provider.request({ method: &quot;evm_mine&quot;, params: [] })
                  const txResponse = await raffle.performUpkeep([]) //调用performUpkeep函数来确保我们的测试能够进行
                  const txReceipt = await txResponse.wait(1)
                  const requestId = txReceipt.events[1].args.requestId //化多个参数为一个参数(这里的事件索引填1,原因是Chainlink合约里被重写的函数已经发送了一个事件,我们这里调用的是重写后的事件)
                  const raffleState = await raffle.getRaffleState() //获得彩票状态
                  assert(requestId.toNumber() &gt; 0) //确保成功发送事件
                  assert(raffleState.toString() == &quot;1&quot;) //确保彩票状态被更新
              })
          })
          //Chainlink节点调用此函数,得到获胜者
          describe(&quot;fulfillRandomWords&quot;, function () {
              beforeEach(async function () {
                  await raffle.enterRaffle({ value: raffleEntranceFee })
                  await network.provider.send(&quot;evm_increaseTime&quot;, [interval.toNumber() + 1])
                  await network.provider.request({ method: &quot;evm_mine&quot;, params: [] })
              })
              it(&quot;只能在 performUpkeep 之后调用&quot;, async function () {
                  //测试每个可能的requestId
                  await expect(
                      vrfCoordinatorV2Mock.fulfillRandomWords(0, raffle.address)
                  ).to.be.revertedWith(&quot;nonexistent request&quot;) //只能使用英文
                  await expect(
                      vrfCoordinatorV2Mock.fulfillRandomWords(1, raffle.address)
                  ).to.be.revertedWith(&quot;nonexistent request&quot;) //只能使用英文
              })
          })
      })
</code></pre>
<h3 id="massive-promise-test">Massive Promise test</h3>
<p>我们所做的时我们正在挑选一个赢家,在彩票中重置,并且发送金钱.测试fulfillRandomWords，选出随机获胜者,并且拿到钱。</p>
<p>我们首先让一群随机的人进入彩票，然后调用performUpkeep和fulfillRandomWords，我们想假装随机数被抽取，但是在测试中我们没有办法知道交易完成的确切时间,我们必须监听要触发的事件,在我们调用结束这整个事情的交易之前，我们需要设置一些东西用来监听该事件被触发(要达到的效果是只有当这个事件被触发,且调用此交易时物品，我们可以进行我们的测试)。</p>
<p>我们设置这个监听器,一旦我们听到WinnerPicked这个事件,然后我们将尝试实际检查所有的参数是否按照预期工作,如果事件有问题的话我们就拒绝掉</p>
<h3 id="-">改拼写错误&amp;运行测试</h3>
<h4 id="-">错误处理</h4>
<p>链上错误处理也是合约编写的重要环节。Solidity可以通过以下几种方式抛出错误。</p>
<p><strong>require都是在执行前验证条件，不满足则抛出异常。</strong></p>
<pre><code>function testRequire(uint _i) public pure {
        require(_i&gt;10,&quot;Input must be greater than 10&quot;);
}
</code></pre><p><strong>revert用来标记错误与进行回滚</strong></p>
<pre><code>function testRevert(uint _i) public pure {
        if (_i &lt;= 10){
                revert(&quot;Inupt must be greater than 10&quot;);
        }
}
</code></pre><p><strong>assert要求一定要满足条件</strong></p>
<pre><code>function testAssert() public view {
        assert(numm == 0);
}
</code></pre><h3 id="raffle-sol-staging-tests">Raffle.sol Staging Tests</h3>
<h3 id="-">在测试网上测试</h3>
<p>步骤:</p>
<p>1.获取Chainlink VRF的订阅Id(既可以在代码中自动完成也可以在Chainlink页面内完成)</p>
<p><img src="img/1-1668443459608-341.png" alt="1"></p>
<p>2.使用订阅Id部署我们的合约(yarn hardhat deploy --network goerli)</p>
<p><img src="img/2-1668443463059-343.png" alt="2"></p>
<p>3.使用Chainlink VRF和它的订阅Id注册合约</p>
<p><img src="img/4-1668443465991-345.png" alt="4">4.使用Chainlink Keepers注册合约</p>
<p><img src="img/3-1668443468809-347.png" alt="3"></p>
<p>5.运行staging测试</p>
<p>首先运行下面的命令</p>
<pre><code>yarn hardhat test --network goerli
</code></pre><p>在以太坊浏览器上看到我们已经参加了彩票活动</p>
<p><img src="img/6-1668443475394-349.png" alt="6"></p>
<p>Check keeper自动选出了获胜者</p>
<p><img src="img/7-1668443482966-351.png" alt="7"></p>
<p>也可以直接在ETH浏览器上运行合约中的函数</p>
<p><img src="img/5-1668443489769-353.png" alt="5"></p>
<h3 id="lottery-">Lottery智能合约总结</h3>
<p>我们成功创建一个可验证的随机去中心化的彩票/抽奖并部署在区块链上，这是一个高级项目</p>
<h2 id="10-nextjs-lottery-">10.使用NextJS开发Lottery智能合约的前端(已)</h2>
<p>为了让普通人使用我们的彩票,我们需要建立一个前端。</p>
<p>使用框架确实可以让我们轻松地添加更多功能并添加更多样式工具应用程序。</p>
<p>NextJS是一个基于React的框架;React是一个用于构建前端和全栈应用程序的框架。</p>
<p><strong>Uniswap和Ave等协议使用的都是React框架</strong></p>
<p>我们不仅要学会如何构建前端,而且要学会如何在一个实际的网站上托管它,这样您将能够将其推送到您自己的区块链，从而在去中心化的环境中托管网站。</p>
<h3 id="nextjs-">NextJS配置</h3>
<p>在前端过程中如果遇到了奇怪的错误,首先去检查自己的yarn.lock和package.json与Github上的有什么不同</p>
<pre><code>yarn create next-app .
</code></pre><p><img src="img/20-1668443494989-355.png" alt="20"></p>
<p><strong>node_modules文件夹下都是我们安装的JavaScript依赖;</strong></p>
<p><strong>pages文件夹下将是我们网站上的不同页面;</strong></p>
<p>运行页面我们可以运行下面这个命令</p>
<pre><code>yarn run dev
</code></pre><p><img src="img/19-1668443498565-357.png" alt="19"></p>
<p>点击即可进入Next.js导航页
index.js将成为我们的默认页面
运行后在命令运行期间都可以在导航栏处按照路径来访问页面,这条命令需要我们手动关闭。</p>
<p>这些页面文件使用的都是React语法，它们以.js文件的形式出现，但它们基本上是React语法。</p>
<p>因为NextJS是基于React的,所以我们经常能够看到这些页面文件代码里混杂着JavaScript和HTML的组合,这都是React语法所允许的。</p>
<p>_app.js将成为我们一切的切入点,NextJs 中“React”的工作方式就是基于我们这里所有文件中的Component,HTML+JavaScript组成的块被称为是一个Component,故我们所有的页面都通过app.js打包成一个Component放入程序当中,故称app.js是我们整个应用程序或整个前端的主要入口点.</p>
<p><strong>api文件夹下是我们想做的一些http，get http，post请求。</strong></p>
<p><strong>public文件夹下是一些公共图像</strong></p>
<p><strong>styles文件夹下是我们项目的CSS，CSS代表级联样式表，它是一种设置HTML样式的方法</strong></p>
<p><strong>我们要做的大部分事情都是在pages文件夹下完成。</strong></p>
<p>运行下面这个命令用来自动格式化</p>
<pre><code>yarn add --dev prettier
</code></pre><p>我们想要建造我们的前端使得人们能够与我们互动以公平的方式参与彩票并连接到正在运行的智能合约。</p>
<p><img src="img/21-1668443503334-359.png" alt="21"></p>
<h3 id="manual-header-1-">Manual Header(1)</h3>
<p>现在我们需要做的第一件事是我们需要创建connect按钮，之前我们都是用ES6(前端JS)来做，现在我们使用NextJS和React来做。</p>
<p>当我们申请连接的时候我们还想做很多事情,例如当我们改变网络/用户时,想要让我们的应用程序检测到,故连接按钮的函数实际上非常严格</p>
<p>(要求连接到钱包后我们可以切换网络，可以切换账户，几乎可以做任何事情，应用程序都会给予响应)</p>
<p>.js和.jsx做着完全相同的事</p>
<p>.jsx只是提醒我们在写的是一个React文件</p>
<h4 id="components">Components</h4>
<p>Components是独立且可重用的代码。 它们的用途与 JavaScript 函数相同，但独立工作并返回 HTML。 Components有两种类型，Class Components和 Function Components，在本教程中，我们将重点学习 Function Components。</p>
<h4 id="react-moralis">react-moralis</h4>
<p>这个库中有一些额外的插件，里面有一些连接到后端的可选的功能，可以给予我们的应用程序更多特性和更多功能。</p>
<p>运行该命令安装这个库</p>
<pre><code>yarn add moralis react-moralis
</code></pre><h3 id="react-hooks">React Hooks</h3>
<p><em>Hook</em> 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>
<p>Hooks 允许函数Components访问状态和其他 React 特性。因此，通常不再需要类组件。</p>
<h3 id="manual-header-2-">Manual Header(2)</h3>
<p>从钩子里取出了连接钱包的函数和展示账户的函数,都可以自动渲染更新。</p>
<h3 id="useeffect-hook">useEffect Hook</h3>
<p><strong>Effect Hook可以让你在函数组件中执行副作用操作（用于模拟类组件中的生命周期钩子）</strong></p>
<p><strong>React中的副作用操作：</strong></p>
<ul>
<li>发ajax请求数据获取</li>
<li>设置订阅/启动定时器</li>
<li>手动更改真实DOM</li>
</ul>
<pre><code class="lang-solidity">    //useEffect这个函数它有两个参数,它接受一个函数作为它的第一个参数,第二个参数它可选地接受一个依赖数组。
    //useEffect将会检查依赖数组中的值,如果这个依赖率有任何变化,它就会调用前面的函数然后重新渲染前端。
    useEffect(() =&gt; {
        console.log(&quot;HI!&quot;)
        console.log(isWeb3Enabled)
    }, [isWeb3Enabled])
    //由于React.Strict 模式开启,StrictMode渲染组件两次(在开发而不是生产上),以检测代码的任何问题并警告您(这可能非常有用)
    //如果不添加依赖数组的话,它每时每刻都会进行渲染,最终达到循环渲染的效果
    //如果给它添加空白数组的话,它仍会由于React.Strict 模式开启,StrictMode渲染组件两次,但是它在连接上Web3钱包后不会进行渲染
</code></pre>
<h3 id="local-storage">Local Storage</h3>
<p>我们使用useEffect Hook的目的是确保当我们刷新时,程序记得我们和钱包实际上是相连的。</p>
<p>我们想使用我们的本地存储去让我们的应用程序记住去点击连接按钮。</p>
<p>在本地存储了一个键值对</p>
<p>有了这个键值对,无论是连接操作还是断开操作都可以自动渲染。</p>
<p><img src="img/13-1668443509720-361.png" alt="13"></p>
<h3 id="isweb3enableloading">isWeb3EnableLoading</h3>
<p>当我们想要禁用Connect按钮时,我们可以添加isWeb3EnableLoading这个钩子。</p>
<h3 id="web3uikit">web3uikit</h3>
<p>适用于 web3 开发人员的美观轻量级 UI 组件。无论您构建在哪个链上，此 UI 库都将加速您的 dapp 开发。</p>
<p>我们可以使用该组件来构建我们的标题组件和Connect按钮组件。</p>
<p>运行下面的命令安装该组件</p>
<pre><code>yarn add web3uikit
</code></pre><p>使用该组件构建出来的Conncet按钮组件可以完成我们之前在ManualHeader里实现的所有功能</p>
<p><strong>Header.js</strong></p>
<pre><code class="lang-js">import { ConnectButton } from &quot;web3uikit&quot;

export default function Header() {
    return (
        &lt;div&gt;
            Decentralized Lottery
            {/*moralisAuth是可选钩子,可以进入服务器以向我们的网站添加更多的功能,我们不想挂接到服务器(因为我们想要一切都是开源的) */}
            &lt;ConnectButton moralisAuth={false} /&gt;
        &lt;/div&gt;
    )
}
</code></pre>
<h3 id="-nextjs-">介绍如何通过NextJS调用函数</h3>
<pre><code>import { useWeb3Contract } from &quot;react-moralis&quot;
//这个钩子给予我们从函数返回来的 数据(data)、错误(error)、一个我们可以用来调用任何函数的小函数(runContractFunction)、
//获取交易(isFetching)、加载交易(isLoading)等变量

export default function LotteryEntrance() {
    //建立一个进入彩票的函数
    const { runContractFunction: enterRaffle } = useWeb3Contract({
        abi:
        contractAddress:
        functionName:
        params:{}
        msgValue:
    })

    return &lt;div&gt;Hi from lottery entrance!&lt;/div&gt;
}

</code></pre><h3 id="automatic-constant-value-ui-updator">Automatic Constant Value UI Updator</h3>
<p>我们想要让在后端智能合约的change反映在前端里，也就是说我们希望能在前端里对后端进行编码，可以创建一个更新前端部署的脚本，这样在我们部署东西之后，我们运行一个小脚本(99-update-front-end.js)，这将为我们创建这个constants文件夹，文件夹下有一大堆东西，例如abi,contractAddress</p>
<p>然后我们可以写一个连接的脚本，连接到我们的前端，这样每当我们部署合约的时候，不管是什么样的区块链，我们都可以在前端更新constants文件夹。</p>
<p>它有助于我们的前端进行各种测试和工作</p>
<pre><code class="lang-js">// const { frontEndContractsFile, frontEndAbiFile } = require(&quot;../helper-hardhat-config&quot;)
const { ethers, network } = require(&quot;hardhat&quot;)
const fs = require(&quot;fs&quot;)
//nodejs中fs是“file system”文件系统的缩写，
//是NodeJS提供的文件操作API，fs模块用于对系统文件及目录进行读写操作，fs模块的所有方法都有同步和异步两种方式。

//合约地址
const FRONT_END_ADDRESSES_FILE =
    &quot;../nextjs-smartcontract-lottery-fcc/constants/contractAddresses.json&quot;
//abi
const FRONT_END_ABI_FILE = &quot;../nextjs-smartcontract-lottery-fcc/constants/abi.json&quot;
//我们不需要通过这个js文件部署任何合约,所以可以把参数进行留空
module.exports = async function () {
    if (process.env.UPDATE_FRONT_END) {
        console.log(&quot;Updaing front end...&quot;)
        updateContractAddresses() //调用更新合约地址的函数
        updateAbi() //调用更新abi的函数
    }
}

async function updateContractAddresses() {
    const raffle = await ethers.getContract(&quot;Raffle&quot;) //getContract将获取合约的最新部署,在这里是因为后面我们需要得到raffle.address
    const chainId = network.config.chainId.toString() //我们只是要使用chainId
    const contractAddresses = JSON.parse(fs.readFileSync(FRONT_END_ADDRESSES_FILE, &quot;utf8&quot;)) //从前端的json文件中读取当前地址
    //所连接网络配置的chainID在当前地址中
    if (chainId in contractAddresses) {
        //添加地址前检查合约地址的最新部署是否已经在json文件当中了
        if (!contractAddresses[chainId].includes(raffle.address)) {
            contractAddresses[chainId].push(raffle.address) //将最新部署的地址加入到当前地址数组列表当中
        }
    }
    //所连接网络配置的chainID不在当前地址中
    {
        contractAddresses[chainId] = [raffle.address] //把新地址数组添加到当前地址中
    }
    //读取完更新完后就要写入文件了
    fs.writeFileSync(FRONT_END_ADDRESSES_FILE, JSON.stringify(contractAddresses))
}

async function updateAbi() {
    const raffle = await ethers.getContract(&quot;Raffle&quot;)
    //contract.interface ⇒ interface 返回interface的 ABI。(这与Solidity的interface不同)
    fs.writeFileSync(FRONT_END_ABI_FILE, raffle.interface.format(ethers.utils.FormatTypes.json)) //我们实际上可以直接通过raffle对象得到abi
}

module.exports.tags = [&quot;all&quot;, &quot;frontend&quot;]

</code></pre>
<p><img src="img/1-1668443515851-363.png" alt="1"></p>
<p>现在我们的第一个终端有我们的前端代码在运行;</p>
<p>第二个终端我们的本地区块链节点在运行</p>
<h3 id="-">运行合约函数</h3>
<p>这时候之前从后端创建过来的abi和contractAddresses就发挥出应有的作用了。</p>
<pre><code> const { runContractFunction: getEntranceFee } = useWeb3Contract({
        abi: abi,
        contractAddress: raffleAddress, //指定网络Id
        functionName: &quot;getEntranceFee&quot;, //函数名字
        params: {}, //彩票合约没有参数
    })
    useEffect(() =&gt; {
        if (isWeb3Enabled) {
            //尝试读出彩票入场费
            async function updateUI() {
                const entranceFeeFromContract = await getEntranceFee()
                console.log(entranceFeeFromContract)
            }
            updateUI()
        }
    }, [isWeb3Enabled])
</code></pre><h3 id="usestate-hook">useState Hook</h3>
<pre><code class="lang-js">const [entranceFee, setEntranceFee] = useState(&quot;0&quot;)
 useEffect(() =&gt; {
        if (isWeb3Enabled) {
            //尝试读出彩票入场费
            async function updateUI() {
                const entranceFeeFromCall = (await getEntranceFee()).toString()
                setEntranceFee(entranceFeeFromCall) //现在当我们设置state钩子时,将触发重新渲染,下方dev里的entranceFee会被填充
                console.log(entranceFee) //想要让入场费的更新得到网页的重新渲染的话还需要使用state钩子
            }
            updateUI()
        }
    }, [isWeb3Enabled])
</code></pre>
<pre><code class="lang-js">    return (
        &lt;div&gt;
            Hi from lottery entrance!&lt;div&gt;{entranceFee}&lt;/div&gt;
        &lt;/div&gt;
    )
</code></pre>
<p><img src="img/image-20221115092430400.png" alt="image-20221115092430400"></p>
<h3 id="-nextjs-">通过NextJS调用函数</h3>
<p>这不就是HTML里掺杂进JavaScript语法来调用函数?</p>
<pre><code class="lang-js">  // 建立一个进入彩票的函数
    const { runContractFunction: enterRaffle } = useWeb3Contract({
        abi: abi,
        contractAddress: raffleAddress, //指定网络Id
        functionName: &quot;enterRaffle&quot;, //函数名字
        params: {}, //彩票合约没有参数
        msgValue: entranceFee,
    })

    return (
        &lt;div&gt;
            Hi from lottery entrance!
            {/* 只要确实有raffleAddress，我们就可以调用该函数 */}
            {raffleAddress ? (
                &lt;div&gt;
                    &lt;button
                        onClick={async function () {
                            await enterRaffle()
                        }}
                    &gt;
                        Enter Raffle
                    &lt;/button&gt;
                    Entrance Fee:{ethers.utils.formatUnits(entranceFee, &quot;ether&quot;)}ETH
                &lt;/div&gt;
            ) : (
                &lt;div&gt;No Raffle Address Deteched&lt;/div&gt;
            )}
        &lt;/div&gt;
    )
</code></pre>
<h3 id="usenotification-hook">useNotification Hook</h3>
<p>web3uikit工具库当中NotificationProvider下的useNotification钩子,里面有很多的通知窗口供我们选择使用.</p>
<p><img src="img/image-20221115104453310.png" alt="image-20221115104453310"></p>
<h3 id="-">读取&amp;展示合约数据</h3>
<p><img src="img/image-20221115142156670.png" alt="image-20221115142156670"></p>
<p>重启解决一切问题哈哈哈哈</p>
<pre><code class="lang-javascript">//自动渲染更新UI
    async function updateUI() {
        const entranceFeeFromCall = (await getEntranceFee()).toString()
        const numPlayersFromCall = (await getNumberOfPlayers()).toString()
        const resentWinnerFromCall = await getRecentWinner()
        setRecentWinner(resentWinnerFromCall)
        setNumPlayers(numPlayersFromCall)
        setEntranceFee(entranceFeeFromCall) //现在当我们设置state钩子时,将触发重新渲染,下方dev里的entranceFee会被填充
        // console.log(entranceFee) //想要让入场费的更新得到网页的重新渲染的话还需要使用state钩子
    }
</code></pre>
<h3 id="-onsuccess-">关于onSuccess的知识</h3>
<p>这个onSuccess不是检查交易是否有块确认，它只检查交易是否成功发送到Metamask。因此，onSuccess查看交易是否成功发送到Metamask。这就是为什么我们在其他函数执行交易时等待一个区块,因为这是真正等待交易确认的部分。</p>
<h3 id="-">小测试</h3>
<p>设置监听发送的事件,然后更新相应的前端;</p>
<p>例如我们可以监听获胜者事件被发送,然后自动更新前端中的数据而不需要我们手动去刷新。</p>
<h3 id="tailwind-styling">Tailwind &amp; Styling</h3>
<p>我们几乎完成了所有的功能,我们了解了useEffect,useMoralis,等等其他的钩子,我们有一个前端,可以很良好地处理与智能合约的交互。</p>
<p>在构建这些前端时有两件事需要考虑,组件库(例如web3uikit)和样式库(例如Tailwind),这个样式库好像类似于BootStrap</p>
<p>运行下面的命令安装Tailwind库</p>
<pre><code>yarn add --dev tailwindcss postcss autoprefixer
</code></pre><p>运行下面的命令为Tailwind制作配置文件</p>
<pre><code>yarn tailwindcss init -p
</code></pre><p>运行后安装了postcss.config.js和tailwind.config.js</p>
<p>然后根据官方文档更新我们的tailwind.config.js</p>
<pre><code class="lang-js">module.exports = {
    content: [&quot;./pages/**/*.{js,ts,jsx,tsx}&quot;, &quot;./components/**/*.{js,ts,jsx,tsx}&quot;],
    theme: {
        extend: {},
    },
    plugins: [],
}
</code></pre>
<p>content后的内容表示了pages文件夹下的和components文件夹下的内容都可以使用Tailwind库</p>
<p>接下把Tailwind指令添加到我们的globals.CSS文件当中。</p>
<p><img src="img/image-20221115153355446.png" alt="image-20221115153355446"></p>
<p>然后在vscode中安装PostCSS Language Support扩展和Tailwind扩展</p>
<p><img src="img/image-20221115153530429.png" alt="image-20221115153530429"></p>
<p><img src="img/image-20221115154525209.png" alt="image-20221115154525209"></p>
<p>接下来就可以正常的运行yarn run dev了</p>
<h3 id="-">托管网站简介</h3>
<p>我们要把我们的合约部署到Goerli测试网上,然后把我们的网站部署到托管服务提供商。</p>
<p>我们可以选择地托管服务提供商有Vercel,Google cloud或Aws,但是这些都是中心化部署场所。</p>
<p>Eherscan也是一个数据末端的中心化应用程序,但是它仍然是我们最常用的区块链浏览器。</p>
<p>如果我们想要一个去中心化的前端,这有点难.</p>
<p>对我们来说更重要的是我们的后端,我们的智能合约是去中心化的,因为这将使用户能够以分散的方式与我们的逻辑进行交互,虽然我们也希望我们的前端能够去中心化,但是现在我们只能使用像Vercel这样的中心化服务去部署应用程序</p>
<p>现在有一些功能，如果没有真正可靠的中心化后端，它们真的很难实现，重要的是记住我们的合约逻辑在去中心化的区块链上，所以即使我们将前端托管在使用某种中心化数据库的中心化托管服务提供商使得我们的前端更易于使用。</p>
<p>应用程序的逻辑被去中心化,这是最重要的部分。</p>
<p>所以我稍后会给你一些工具，以及如何引入更多这些丰富的功能。</p>
<p>如果您选择这样做，那么将在您的前端添加一个中心化组件，并且需要牢记这一点，具体取决于您希望您的架构如何。因此，在这样做时，请绝对确保后端的智能合约已部署并分散在这些区块链之一上。</p>
<p>现在，我们将在后面的部分中了解其中的一些中心化方法。现在，让我们学习如何以去中心化的方式部署此前端。</p>
<h3 id="ipfs">IPFS</h3>
<p>IPFS是分布式去中心化数据结构,它不完全是区块链,但它类似于区块链，尽管不能挖矿,但是它存储着固定的数据，我们也可以往里面添加数据。</p>
<p>IPFS是如何工作的呢？</p>
<p>IPFS会对我们的数据进行哈希处理以获得唯一的哈希(仅指向该数据的哈希)，IPFS节点会为我们进行hash计算,地球上的每一个IPFS节点具有完全相同的哈希函数，这种计算可以把我们的数据固定到节点上,然后发布这些数据并拥有这些哈希值。我们的节点连接到其他IPFS节点的网络，所以说地球上有一个运行IPFS节点的庞大网络，它们比任何区块链节点都要轻量，它们互相交谈然后交换各自的哈希，其他节点可以固定我们的数据作为副本，这样我们就可以在去中心化的集合当中轻松复制任何代码或任何数据。</p>
<p>IPFS与区块链截然不同的是,它们不能部署智能合约,不可以执行合约,只能进行去中心化的存储。</p>
<p>为了让我们的数据真正去中心化,需要有其他节点固定我们的数据，因为如果我们是唯一的IPFS节点，哈希会集中在我们的节点上，如果我们的节点宕机的话，数据就不见了。</p>
<p>故IPFS是我们托管数据的一种方式,我们可以发送代码并让它处于去中心化的环境中，和区块链不同的是,区块链上的每一个节点都拥有整个区块链的副本，IPFS节点可以选择它们想要固定哪些数据，它们不能做任何执行，所以我们可以有一个0.5MB字节的IPFS节点也可以有一个几TB的IPFS节点，由节点接线员决定他们想要固定多少数据，想要固定哪些数据。</p>
<h3 id="hosting-on-ipfs">Hosting on IPFS</h3>
<p>将我们的应用部署在IPFS上,这样只要我们的节点还在，那么任何人都可以使用它,连接它。</p>
<p>有很多方法可以安装和使用IPFS,我们可以获得它的桌面应用程序,通过终端命令行获取它,也可以把IPFS作为插件添加到我们的浏览器(Brave浏览器内置IPFS,Chrome浏览器需要安装插件)，我们可以使用IPFS节点处理数据所得到的唯一哈希作为网站的url，所以我们希望能够将该 url 放入我们的浏览器并连接到该节点或那段代码。</p>
<p>将IPFS安装在本地后,首先就要导入next.config.js文件</p>
<p><img src="img/image-20221115201146106.png" alt="image-20221115201146106"></p>
<p>ipfs://+cid复制到浏览器中可以访问这个文件的数据</p>
<p><img src="img/image-20221115201816119.png" alt="image-20221115201816119"></p>
<p>还可以使用网关的方法来在浏览器中访问这个文件的数据(不需要借助插件和内置的IPFS)</p>
<p><a href="https://ipfs.io/ipfs/QmPCkom6iS8BELeZRmE4mMfqSB7Xw5yxJY7MYYxQZoVomP">https://ipfs.io/ipfs/QmPCkom6iS8BELeZRmE4mMfqSB7Xw5yxJY7MYYxQZoVomP</a></p>
<p><img src="img/image-20221115202221522.png" alt="image-20221115202221522"></p>
<p>所以我们想要把我们的网站部署到IPFS上,这样任何人都可以固定这个网站，现在我们有能力拥有一个简洁并且可以下载的网站.</p>
<p>我们将首先学习如何以原始方式执行此操作</p>
<p>NextJS具有创建静态网站的能力,我们不希望我们的网站与任何服务器纠缠在一起,因为如果我们的网站上有服务器在运行的话把它们部署到IPFS上的话,IPFS没有能力运行任何代码,IPFS只能托管代码。</p>
<p>如果我们的前端有任何服务器的东西,IPFS无法正常工作。因为IPFS不会做yarn dev这样的指令,所以我们要把代码放在该命令的静态等价之中。</p>
<p>运行yarn build,这个命令将像产品一样构建我们的代码,在这里创建优化的产品。</p>
<p><img src="img/image-20221115204351117.png" alt="image-20221115204351117"></p>
<p>NextJS附带了一些基于服务器的应用程序,如果我们使用它们,我们的静态构建将无法工作。</p>
<p>运行</p>
<pre><code>yarn next export
</code></pre><p>如果文件夹中有任何非静态的东西,这行命令将会失败</p>
<p><img src="img/image-20221115211406422.png" alt="image-20221115211406422"></p>
<p>运行成功后会建立一个out文件夹,这个文件夹下都是我们可以在IPFS上使用的静态代码</p>
<p><img src="img/image-20221115211334138.png" alt="image-20221115211334138"></p>
<p>然后我们就可以回到IPFS文件夹下导入out文件夹</p>
<p>导入后把out文件夹固定到本地节点上</p>
<p>通过out文件的cid我们就可以在浏览器上进入我们的彩票项目</p>
<p><img src="img/image-20221115212049423.png" alt="image-20221115212049423"></p>
<h3 id="-ipfs-host-fleek">在IPFS上host&amp;使用Fleek</h3>
<p>上面使用out文件夹的方法是将我们的代码添加到IPFS的手动方式,下面我们会学习将代码添加到IPFS中的更简单的方法。</p>
<p>我们首先去到Fleek.co网站,注意关闭IPFS插件,因为和该网站存在冲突。</p>
<p>Fleek 使在新的开放网络上构建网站和应用程序变得容易：无需许可、无需信任、抗审查，并且没有中心化 gateKeepers。</p>
<p>这个网站可以帮助我们解决如何让其他节点固定我们的数据的问题</p>
<p><img src="img/image-20221115221526709.png" alt="image-20221115221526709"></p>
<p>使用Github注册好Fleek后添加new site然后我们可以使用Fleek来自动部署网站(只要我们把代码推送到Github上面)</p>
<p><img src="img/image-20221115221833088.png" alt="image-20221115221833088"></p>
<p>运行以下命令把代码推送到Github上</p>
<pre><code>git add .
git commit -m &#39;initial commit&#39;
git remote add origin https://github.com/LoopLove-Ether/nextjs-smartcontract-lottery-fcc
git push origin main
</code></pre><p>然后在Fleek上面连接Github上的仓库,接着我们就可以写入我们的信息。</p>
<p><img src="img/image-20221115222853218.png" alt="image-20221115222853218"></p>
<p>部署时如果命令写错的话可以在General里面修改然后重置部署</p>
<p><img src="img/image-20221115223652382.png" alt="image-20221115223652382"></p>
<p>Fleek将在IPFS上为我们部署一个站点,它会给出一个我们可以使用的常规网址</p>
<p>Filecoin Deal ID: 帮助我们的区块链固定我们的数据并且使用去中心化存储来做到这一点(Fleek帮助我们创建这些交易并且帮助我们固定数据)</p>
<p>Deal Proposal CID:其他人托管我们节点时所使用</p>
<p>部署结束了</p>
<p>那个spring-bonus-4389.on.fleek.co就是我们可以使用的常规网址,里面是我们彩票合约的全部功能。</p>
<p><img src="img/image-20221115224502269.png" alt="image-20221115224502269"></p>
<p>Current IPFS Hash可以当作CID一样去使用。</p>
<p><img src="img/image-20221115230802493.png" alt="image-20221115230802493"></p>
<p>如果此时想要对智能合约/前端做一些改变的话.</p>
<p>我们可以在代码中修改后重新push到Gith上进行自动修改</p>
<p>运行这些命令</p>
<pre><code>git add .
git commit -m &#39;added dot&#39;
git push origin main
</code></pre><p>added dot是最新添加的</p>
<p><img src="img/image-20221115230026693.png" alt="image-20221115230026693"></p>
<p>回到Fleek中我们会发现有一个新的部署正在执行,因此Fleek会自动部署我们的新站点，它会创建一个新的IPFS Hash，但是输出的常规网址仍是原来的</p>
<p><img src="img/image-20221115230350881.png" alt="image-20221115230350881"></p>
<p>接着我们会发现change已经被部署好了</p>
<p><img src="img/image-20221115230709094.png" alt="image-20221115230709094"></p>
<h3 id="filecoin-">Filecoin 概述</h3>
<p>Filecoin 是一个去中心化存储网络，旨在存储人类最重要的信息。</p>
<p>Filecoin 不会成为一项我们自己会深入使用的技术。</p>
<p>IPFS 确实有这个限制它没有数据持久性你必须让人们固定你的数据以使其保持分布性和去中心化。</p>
<p>Filecoin 是一个区块链，致力于保持这些数据的分散性和持久性。</p>
<p>数据、信息和知识是我们互联时代最重要的资产之一，对人类发展与合作至关重要。</p>
<p>因此，目前的中心化模式基本上是由于互联网上缺乏身份层，只有少数大公司提供存储，只有少数实体持有我们的数据用于授权目的。</p>
<p>这是一个明显的问题，无论是作为数据挖掘的攻击媒介，还是没有数据，通过不安全的服务泄露给第三方，同时也造成数据弹性问题。</p>
<p>所以每次这些公司的服务器出现故障时，整个服务都会停止，这一点我们很少看到。所以这真的引出了一个问题，为什么我们不首先为我们需要的自动性和弹性设计网络呢？</p>
<p>我们如何以既符合互联网作为知识共享和协作的开放场所的原始愿景，又符合Web3使命的方式存储数据？</p>
<p>因此，这些是我们使用IPFS和Filecoin解决的核心问题。</p>
<p>首先，IPFS是一个分布式系统，用于存储和访问文件、文件夹、网站、应用程序和数据，它被设计成即使在行星之间的网络也能工作，因此它是一个分布式的设计，它没有中央化服务器，而且它被设计为离线模式以用来恢复。它不仅仅是另一个对等网络以太的华丽名称，因为IPFS协议的优点是它用于在网络上寻址内容的标准。IPFS是独一无二的，因为它不是使用我们可能从网络上熟悉的传统方法，比如那些指向特定HTTP地址的位置部分，在那里您的内容可能可用或不可用并存储。IPFS使用内容寻址，因此内容寻址意味着每一条数据甚至整个文件系统都有自己独特的可加密指纹。例如，如果您更改了主图像的一个像素，那么与之相关联的内容ID或CID也会更改。所以重要的是，这个哈希函数也是可升级的。所以，假设量子计算打破了我们目前的安全哈希算法，我们可以升级我们使用的标准。这意味着您将始终获得IPFS返回的相同内容。CID如您所期望。因此，这一点非常重要，因为当您不必关心数据来自何处时，您可以向大规模分布式存储系统开放网络。因此，现在我们有了一个非常重要和有价值的协议，可以实现大规模分发。它还提供了数据的可验证性，以服务和检索web上的内容。不仅适用于web3、ether，也适用于所有web或技术用例。</p>
<p>问题是，这也是早期互联网也面临的问题，谁来确保网络上所有这些数据的持久性。因此，除非您全天候运行自己的节点，或者您的内容非常流行，或者其他节点决定无私地存储您的数据,因为我认为这很重要，所以这些数据可能变得不可靠，因为它们不再活跃地托管在网络上的任何节点上。<strong>因此，为了避免这种情况，你也可以求助于一个固定服务，你可以付费保存你的内容副本。不幸的是，这方面的问题是，我们正朝着数据中心化的方向前进</strong>。我们正在用这个解决方案创建新的数据仓库，并失去我们所寻求的无信任和恢复能力。</p>
<p>在Filecoin之前，这是一个糟糕的解决方案，这也是它们最初出现的原因，但我们需要一个更好的解决方案。因此，这就是Filecoin的用武之地。因此，<strong>Filecoin架构旨在利用加密经济激励模型和加密证明，以确保数据持久、高度可靠和可验证地存储</strong>。它基于智能合约的永久性实现这些加密证明。它也是为了实现互联网规模的容量而设计的。它是目前世界上最大的分布式存储网络，可用容量超过1800万TB，这显然是欧盟核计划的135份副本，CERN的数据，这是一个有趣的事实。由于其市场经济性，Filecoins 也被设计为在定价上保持高度竞争力。这归结为存储交易。因此，为了使这个网络可行，Filecoin 使用存储交易。这些包括确保两种奖励的主要共识机制对于系统中的好行为者，以及对坏行为者的惩罚。因此，当您与一个或多个存储提供商达成交易以存储您的重要数据时，提供商会生成复制证明。因此，这证明存储提供商正在存储一个独特的随着时间的推移复制您的原始数据，以确保该数据被持久化。这些存储提供商必须证明他们仍然拥有此客户端数据的随机子集，并且他们创建了时空证明。这些时空证明是存储在区块链上的东西。所以任何人在任何时候也可以检查这是真的.它还构成了矿工获得奖励或惩罚的机制，因为<strong>你必须在网络上抵押 Filcoin 才能成为存储提供商</strong>。因此，当存储交易结束时，或者用户可以选择让它过期或续订交易。如果您选择续订，则提供商再次出价托管此内容。因此，这为定价创建了一个有效的市场持续有效的定价市场也是如此。它甚至可以变为负值。因此，由于 Filecoin Foundation 也提供了一些区块奖励，因此存储提供商甚至可以付钱给你来存储你的数据，如果它可以是重要的数据集。所以这些机制不仅是内置的数据永久性，数据时间框架，主权，也是如此；您可以决定要将数据存储五分钟或 500 年。您还可以选择希望拥有该数据的弹性程度，或者您希望拥有该数据的多少副本，以及将哪些数据存储给提供商。因此，这允许您遵守 GDPR 等法规。并且生态系统中有越来越多的工具，例如 murmurations bit screen 允许您执行此过滤。但它也为您提供了一些保证，如果您知道，如果一个存储供应商出现故障，你知道，肯定不会有 10 个存储供应商出现故障。所以这也是你在那里的恢复能力的保证。</p>
<p>这就是为什么 IPFS 和 Filecoin 是彼此很好的补充.<strong>因此 IPFS 为您提供了内容寻址的好处 ，Filecoin 为您提供了持久的保证</strong>，如果您的计算机或您最喜欢的 IPFS 固定服务离开了哪里，内容仍然存在。就像这些概念的最后一个快速节点一样，IPFS 和 Filecoin 是单独的项目，正如我提到的。所以 I<strong>PFS 是一个很像 HTTP 的协议，而 Filecoin 是一个区块链。</strong></p>
<p>所以 IPFS 也是存储层不可知的，你可以将它与你选择的存储层结合起来。虽然 Filecoin 是专门设计来补充它的，我们认为这是一个很好的选择，你也可以将你的 IPFS 数据存储在云端或其他存储解决方案。因此，希望您对为什么要使用 IPFS 和 Filecoin 有一个很好的基线。</p>
<p>对于那些喜欢挑战，并且有兴趣研究 IPFS 和 Filecoin 的基本协议和代码的工程师，这对普通用户来说并不总是那么容易，我鼓励你去看看在项目文档和 githubs 以及一些可用于扩展这些开源项目的相关赠款。如果您想了解更多信息并真正深入了解 IPFS 和 Filecoin 背后的代码，这是一个很棒的网站。并扩展其中的一些。(<a href="https://bit.ly/PL-Launchpad">https://bit.ly/PL-Launchpad</a>)</p>
<p>对于想要开箱即用的话推荐下面这些</p>
<p><strong>Fleek</strong>是最好的IPFS开发工具和项目之一，Fleek使用IPFS来托管我们的网站或应用程序,它甚至为它们平台上的主路由提供NS。因此如果我们想要部署前端的话,可以使用Fleek来让我们的前端项目更加去中心化。</p>
<p><strong>NFT.Storage</strong>.正如您可能已经知道的那样，永久地存储NFT元数据对于保持NFT的主要价值主张是不可或缺的。然后是可替换性，所以如果你不将这些数据存储在链上，那么对于大型文件来说，这显然在财务上是不可行的。这正是NFT存储的用武之地。因此，它被专门创建为一种公共产品，用于归档和保存NFT数据。所以它是免费的。它还考虑了首先为该元数据创建IPFS CID，然后与Filecoin存储提供商进行自动交易的复杂性。因此，它至少使用八个存储提供商来实现这一点。因此，8倍的冗余，它在多代人的时间框架内实现。因此，它会自动续签这些交易。因为这是一种公共产品，所以它也是免费的。它也非常容易使用，因为它是一个JavaScript服务。因此，您只需要将其作为NPM包或JavaScript库导入，然后调用API,NFT.storage负责其余部分。</p>
<p>对于非 NFT 元数据的数据，我们构建了 <strong>Web3.Storage</strong>，Web3.storage 旨在为您提供相同的 Web2 优势。与 NFT.storage 非常相似，让您超级容易使用。它有JavaScript和客户端库。在让您了解分散存储和IPFS内容寻址的IPFS和Filecoin的强大功能的同时，它还拥有一个又一个TB，一个TB的免费存储空间。所以，如果你不只是想存储和获取元数据，请尝试一下。</p>
<p>下一个工具更高级一点。它叫做 <strong>Textile Powergate</strong>，它是为更高级的开发人员或那些寻求更灵活地与 IPFS 实时点对点和 Filecoin 交互的开发人员准备的。它是一个围绕Filecoin和IPFS节点的Docker容器。它为您提供了很多配置选项，这只是一个小的选择和扩展功能。它还为开发人员可能感兴趣的几个层提供了一些桥梁。这里还有一个，我会先说你需要邀请ESRI技术人员参加。因此，它适用于希望存储真正有意义的公共数据的人。它目前处于alpha模式，正如我所说，它需要邀请，因为它是专门为存储重要信息而构建的公共产品。</p>
<p>我要提到的另一个工具是<strong>OrbiDB</strong>。许多从 Web2 进入 Web3 空间的人通常都在寻找我们在传统计算中习惯使用的同一种关系数据库，而不是去中心化或分布式格式的数据库。这不是一个简单的问题。所以 OrbitDB 目前正在积极开发中。而且因为这不是一个容易解决的问题，对于那些寻求开箱即用体验的人来说，这不是一个理想的解决方案。但是 如果你正在寻找类似的东西，试试 OrbitDB。生态系统中还有其他几种工具利用 IPFS 和 Filecoin，包括ceramic，它类似于 textil power gate，除了它使用去中心化的身份。Lighthouse 是文件驱动器，并且有 甚至 Morales 也有一个 IPFS API，所以也请检查一下。</p>
<p>因此，storage确实是一个技术系统的基本组成部分。所以，这里有很多用例可以深入研究。因此，我希望能为您提供一些知识和工具，帮助您开始使用IPFS和Filecoin并真正实现强大的分布式应用程序。现在还有一个工具也在积极开发中。所以，如果你仔细看这张图，你会发现逻辑层末尾可能有一个不熟悉的标志。这是filecoin虚拟机的徽标。因此，FBM将于今年年底推出。我们对此非常兴奋。它将允许智能合约、合约使用以及存储数据、负载等的托管，从而使计算能力与存储能力相结合，并且还将与EVM兼容。所以，正如我所说，我们对这个项目中即将出现的各种用例感到非常兴奋。你也可以在这里的网站上关注。所以，希望我已经为您提供了开始使用IPFS和Filecoin所需的工具。</p>
<p><img src="img/{3C4050EA-95F4-BE0E-0286-6D7451D2FA3B}.png" alt="img"></p>
<h3 id="-">总结</h3>
<p>首先我们了解了NextJS,我们知道我们可以有一个使用NextJS的应用程序，这个框架用来构建前端和全栈应用程序真的很容易。</p>
<p>我们了解到了NextJS项目的布局，我们在conponents文件夹中添加组件(这些组件基本上是JavaScript和HTML块)，我们可以用组件来模块化和创建我们的网站；constans文件夹下添加常量变量；node_modules文件夹是已知模块。out文件夹是我们导出的静态代码。pages文件夹是我们网站的不同页面，一切都通过_app.js(我们所有的页面都通过这个文件运行,所以_app.js文件还被认为是我们整个应用程序的切入点)。public文件夹下只是一些公共的东西。styles文件夹下是适用于我们应用程序的CSS样式。其余的都是一些基础文件。</p>
<p><img src="img/image-20221116182813987.png" alt="image-20221116182813987"></p>
<p>有了MoralisProvider包裹着我们的NotificationProvider和Component，意味着我们不必在我们的组件之间传递参数，我们的彩票只需要知道我们的ChainId是什么,因为我们的Header.js会将其传递给MoralisProvider，然后MoralisProvider会通过它确认后进入我们的彩票。</p>
<p>我们的ManualHeader.js中写了连接按钮是如何在幕后工作的，它会做一些本地存储键值对的操作。我们在这里学习了useEffect和useState以及我们前端的这些不同的钩子，我们使用钩子的主要原因之一是我们希望我们的网站在内容发生变化时重新渲染,我们想要让我们的组件能够查看区块链的状态，它对于建立我们的React来说非常强大;useEffect是最受欢迎的钩子之一,如果我们没有依赖数组,我们useEffect中的函数将时刻运行重新渲染的效果(循环渲染)，useState钩子也附带重新渲染能力。</p>
<p>我们学会了如何书写带有Moralis的合约函数,不仅发送交易还可以调用数据(view)；</p>
<p>我们添加了一个按钮,使用了onSuccess，当我们的交易成功时调用updateUI，我们为通知添加了弹出窗口。</p>
<p>我们学习了如何将我们的代码直接部署到IPFS(out文件夹)，并且使用IPFS哈希交互并查看我们的代码。</p>
<p>我们也学到了如何使用Fleek和Github将我们的代码自动部署到IPFS，这使得我们对我们网站的实时更新变得容易，它还为我们提供了一个常规的规范网址。</p>
<p>最后我们了解了IPFS和去中心化的数据库存储(在以太坊,雪崩链上存储这些数据的话花费非常大，并且以太坊,雪崩链这些并不是真正的数据存储层，它们是真正的逻辑层)</p>
<h2 id="11-hardhat-">11.Hardhat入门套件(已)</h2>
<p>我们已经学习了智能合约的基础知识和很多前端的知识,并为应用程序构建前端。</p>
<p>SmartContract仓库装满了我们可以使用的入门套件</p>
<p><img src="img/image-20221116210213180.png" alt="image-20221116210213180"></p>
<p>hardhat-starter-kit是我们最受欢迎的入门套件。</p>
<p>这个仓库带有大量框架(比实际展示出来的要多),例如solona，foundry，truffle当我们用到这些框架的时候都可以到这个仓库当中复制模板拿来构建自己的项目。</p>
<p>下面以hardhat-starter-kit作为范例来演示如何复制构建项目</p>
<p>首先使用该模板创建一个新的仓库</p>
<p><img src="img/image-20221116222416696.png" alt="image-20221116222416696"></p>
<p><img src="img/image-20221116222518906.png" alt="image-20221116222518906"></p>
<p>接着在vscode终端里输入以下命令</p>
<pre><code>git clone https://github.com/LoopLove-Ether/hardhat-play-fcc
</code></pre><p><img src="img/image-20221116223015158.png" alt="image-20221116223015158"></p>
<p>我们可以跟着Github存储库中的Readme.md一步步入门，Chainlink的SmartContract仓库中的框架是时刻保持更新的，不断有一些最佳实践在真正专业的环境中构建我们的智能合约。</p>
<p>接着运行yarn命令安装所有依赖，安装后运行yarn hardhat test测试一下示例合约，这将向我们展示如何交互以及如何在这里使用所有这些不同的合约</p>
<p><img src="img/image-20221116223826605.png" alt="image-20221116223826605"></p>
<p>然后就可以跟着Readme.md一步步部署这个框架以及交互合约了</p>
<h2 id="12-hardhat-erc-20-">12.使用Hardhat开发ERC-20智能合约(已)</h2>
<p><strong>什么是EIP？</strong></p>
<p>EIP被称为<strong>以太坊改进提案</strong>(avalanche,polygon这些区块链都有其各自的改进提案)，以太坊改进提案 (EIP) 描述了以太坊平台的标准，包括核心协议规范、客户端 API 和合约标准。在一些Github或一些开源存储库上,它们会添加这些新的EIP，这些是整个以太坊社区的最佳实践。当EIP获得足够的影响力,它们也会创建一个ERC。</p>
<p><strong>什么是ERC？</strong></p>
<p>ERC被称为<strong>以太坊征求意见</strong>，ERC20是第二十个以太坊征求意见，ERCs和EIPs共享相同的编号和网站，ERCs将成为ERC20或智能合约标准代币，ERC-20是一个改进提案，讨论了如何实际创建代币和创建这些智能合约代币。</p>
<h3 id="-erc-20">什么是ERC-20</h3>
<p>ERC20s是使用ERC-20代币标准部署在链上的代币，这其实是一个代表代币的智能合约，所以它既是代币又是智能合约。</p>
<p>Chainlink，Uni等代币都是ERC-20标准的例子，从技术上讲，Chainlink是ERC-677，因为在ERC升级之后仍然向后兼容ERC-20。所以基本上我们可以把它们想象成带有一点额外功能的ERC20s。</p>
<p>为什么要制作一个ERC-20</p>
<p><img src="img/image-20221117091325068.png" alt="image-20221117091325068"></p>
<p>无论如何，我们在构建ERC-20之前要明白我们要做的是建立一个遵循代币的智能合约标准，我们所要做的就是构建具有ERC20各种函数的智能合约(name函数,symbol函数,decimals函数等等/名称函数,符号函数,小数函数等)</p>
<h3 id="-erc-20-">手动创建ERC-20通证</h3>
<p><img src="img/image-20221117092044802.png" alt="image-20221117092044802"></p>
<p><strong>无论是EIP-20还是ERC-20它所需要的只是在其代币标准中包含这些函数,以便我们可以转移代币,</strong>我们可以在ERC-20合约中完成所有这些工作，它只是在跟踪每种代币有多少。</p>
<pre><code class="lang-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

contract ManualToken {
    uint256 initialSupply; //该智能合约初始token供应数量.
    mapping(address =&gt; uint256) public balanceOf; //通过地址映射余额.
    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance; //Loop的地址允许Love的地址使用25个代币.

    //转移代币
    //从一个地址(from)中减去余额然后把余额加到另一个地址(to)当中
    //当调用者发送钱的时候该函数工作直接把钱汇入另一个地址
    function _transfer(
        address from,
        address to,
        uint256 amount
    ) public {
        balanceOf[from] = balanceOf[from] - amount;
        balanceOf[to] = balanceOf[to] + amount;
    }

    //我们希望其他人使用我们的代币并将其存入协议然后用代币调用更多的函数,下方就是批准该操作的函数
    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    ) public returns (bool success) {
        //从用户那里获取资金
        require(_value &lt;= allowance[_from][msg.sender]); //检查allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
}
</code></pre>
<h3 id="-openzeppelin-erc-20-">通过OpenZeppelin创建ERC-20通证</h3>
<p>我们可以使用像OpenZeppelin这样的开源库来得到一些可以使用的样板代码，OpenZeeplin几乎被认为是Solidity的一种标准库，它有一个开放的清单，任何人都可以使用和导入源合约进入他们的合约，这样就不必手动写出所有内容，我们可以在OpenZeppelin的Github仓库中看到他们所有的代码。</p>
<p>在vscode终端中运行下述命令导入OpenZeppelin所需要的依赖</p>
<pre><code>yarn add --dev @openzeppelin/contracts
</code></pre><pre><code>// SPDX-License-Identifier:MIT

pragma solidity ^0.8.7;

//OpenZeppelin所拥有的代码片段之一就是我们可以使用的ERC-20合约
import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;

//我们会发现这里被标记上了abstract的错误,因为我们必须使用ERC20.sol的构造函数
contract OurToken is ERC20 {
    //如果我们说initialSupply是50(也就是50Wei的意思)
    //intila supply 50e18(decimals函数设置的小数位数是18位)
    //50 * 10**18
    //构造函数的参数是代币名字和代币符号
    constructor(uint256 initialSupply) ERC20(&quot;OurToken&quot;, &quot;OT&quot;) {
        _mint(msg.sender, initialSupply); //铸造初始数量的代币,然后决定谁(msg.sender)拥有这些初始代币
    }
}
</code></pre><p>下面就要我们自己编写deploy脚本和运行测试脚本了.我们需要配置hardhat.config.js，然后建立helper-hardhat-config.js并进行配置,同时安装deploy的库</p>
<h3 id="-">总结</h3>
<p>ERC-20代币,EIP-20代币改进提案就是所谓的代币标准。而代币标准，这些链上的代币实际上只是智能合约的代币。这些代币明显不同于以太坊、pologon 或 Avalanche 等第一层代币(<strong>这些代币称为区块链原生代币</strong>)。与这些原生代币相比，这些 ERC20，这些智能合约代币，它们只是智能合约。它们只是这些函数的组合，表示每个地址有多少代币，我们可以创建自己的代币并添加所有规范。或者我们可以使用 openzeppelin 这个最流行的Solidity标准库导入代币合约。<strong>这些代币合约比较特殊的一点是其中存在着allowance映射(运行其他地址的用户访问我们的token的地址转移池子里的代币)</strong>，当我们与Defi合作的时候，这个映射将会发挥至关重要的作用，当我们想让一些智能合约访问我们的代币时，可以将其输入到它们的Defi协议中，这有点困难，因为想要确保恶意合约无法与我们的代币进行交互。我们也会看到当我们与这些代币进行更多交互的时候，<strong>在任何合约可以与我们的代币交互之前，我们需要批准它们与我们的代币进行交互</strong>。</p>
<h2 id="13-hardhat-defiaave-">13.Hardhat DeFi&amp;AAVE(已)</h2>
<p>我们将学习DeFi并用编程的方式与DeFi协议交互</p>
<h3 id="-defi">什么是DeFi</h3>
<p>DeFi是智能合约最好的应用之一，DeFi代表去中心化金融，我们通过DeFi远离传统协议领域，这同时也是智能合约的全部意义所在。他们要移除金融世界里中心化的实体，尤其是说这些金融机构拥有利益冲突，他们做生意是为了赚钱而不是为了保证我们的钱安全，我们想使用一个一切都是透明的系统，尤其是在我们的金融服务方面，所以我们想进入这个智能合约的世界，在我看来，DeFi将成为最快影响群众的行业，因为它很公平，平均收益也高于中心化金融，我们将远离中心化协议，去中心化协议的一切基于密码学的保证，而不必相信那些公司的鬼话。</p>
<p>并且,Chainlink预言机也越来越完善,预言机网络将与这些智能合约平台(比如Ethereum,Polygon和Avalanche)一起工作，我们可以做越来越复杂的金融产品。</p>
<p><img src="img/image-20221117145350449.png" alt="image-20221117145350449"></p>
<p>下面这个图片按规模显示了不同的市场(图片上的数据略有过时,以文字为准)</p>
<p>DeFi是一个价值2000亿美元的市场</p>
<p>加密货币是一个价值1.8万亿美元的市场</p>
<p>黄金是一个价值10万亿美元的市场</p>
<p>股市接近100万亿美元</p>
<p>全球房地产接近300万亿美元</p>
<p>衍生品接近4500万亿美金</p>
<p>所以DeFi现在是一个非常微小的市场。</p>
<p><img src="img/image-20221117150936580.png" alt="image-20221117150936580"></p>
<p>DeFi如果想要快速发展的话,取决于我们制定其中一些协议，让人们更容易进入财务更加公平、更加负责、更加透明、收益率更高的领域</p>
<p><img src="img/image-20221117152355385.png" alt="image-20221117152355385"></p>
<p>事实上，我们可以在这个名为DiFi LIama的网站上看到DeFi正在发生的事情的一个很好的总结</p>
<p><img src="img/image-20221117153315019.png" alt="image-20221117153315019"></p>
<h3 id="-aave">什么是AAVE</h3>
<p>AAVE曾经是总市值第一的协议，AAVE是一个借贷协议，它允许我们借加密货币版贷款，因此，我们实际上可以将代币作为抵押品，这有点类似于将钱存入银行，并通过<strong>其他人向我们借款获得收益</strong>，同时我们向AAVE借贷时，也会产生利息，这几乎与银行的做法完全相同，但是银行是托管者，在该协议中没有托管者。所以AAVE团队从来不碰他们的钱，没有人碰过他们的钱，这一切都是智能合约控制的，所以我们可以放心没有人会卷钱跑路的，没人会做坏事，我们也获得了更高的产量。借贷是创建真正有趣的金融应用的关键。</p>
<p>现在我们在AAVA的测试网站上演示如何进行售卖和保证金的交易,我们要做的第一件事是存入一些抵押品，我们需要存入一些抵押品才能借款，这样的话如果我们永远不偿还我们借出去的贷款，AAVE将拿走我们放在这里的抵押品，它会执行清算调用，这就是为什么这实际上比传统市场的交易更安全一点，因为如果你的抵押品少于你借出的金额，你会立即被清算，所以只要你不想损失一大笔钱，一定要避免被清算。稳定币的回报率一般都是4%。</p>
<p>为了让AAVE了解并确定基础抵押品的价格，从而知道它可以贷款多少，AAVE其中的另一个协议，它使用“Chainlink”喂价来为基础抵押品定价，许多上亿美元市值的Defi协议在后端使用Chainlink来做他们的定价机制。</p>
<p>AAVE的功能基本就是这样，我们可以偿还我们的债务，可以借更多的资产，可以交换资产以及处置我们通过资产获得的利息回报。</p>
<p>AAVE的UI托管在IPFS上，学会以编程方式借贷我们可以成为量化DeFi工程师。</p>
<h3 id="-">可编程借贷</h3>
<p>我们将使用AAVE V2协议</p>
<p>另一种我们所讨论的DeFi协议是UniSwap,UniSwap是交易的天堂,这是一个去中心化的应用程序,允许我们在自动化交易市场上相互交易资产和代币,它基本相当于代币们的去中心化证券交易所,并且代币不完全是股票,因此当你希望在主网上获得其中一些资产时,比如Ethereum或DAI或Link代币，都会使用像UniSwap这样的去中心化交易所，这样的交易所更加公平,因为发生在他们身上的一切都是透明的,比中心化金融公平得多。</p>
<p><img src="img/image-20221117193859566.png" alt="image-20221117193859566"></p>
<p>在VSCode中使用，我们在建立scripts文件夹，因为在这个项目中我们实际上不会自己创建任何合约，我们只是要学习如何与这些协议交互，如果想要构建关于协议的一些合约的话，上Github吧。</p>
<h3 id="weth-wrapped-eth">WETH Wrapped ETH</h3>
<p>在很多这些协议上,当我们在Ethereum或Polygon这些区块链上存储时,实际发生的是他们通过WETH 网关发送你的ETH并且把它换成WETH(它相当于ERC20合约下的ETH)</p>
<p>编译脚本运行的命令是yarn hardhat compile。</p>
<h3 id="-">分叉主网</h3>
<p>之前我们都是创建一个模拟WETH代币合约地址，我们先部署模拟然后继续使用我们这段时间一直在做的相同设置</p>
<p>现在我们可以先分叉主网然后运行本地假装成主网络节点的Hardhat节点，我们所要做的就是更新我们的Hardhat.config来做这件事。</p>
<p>聊聊分叉吧。</p>
<p>左边我们有一个区块链示例,这类似于测试网或主网,这将是我们部署到的区块链,现在这上面有一大堆区块,我们有一个可以在上面工作运行的巨大链条,区块链上的所有信息都是公共信息,正因为如此<strong>我们可以复制这些信息到我们的本地环境之并自己做一些模拟</strong>(<strong>这正是分叉的作用</strong>),分叉的区块链从字面上获取现有区块链的副本并将其带到我们的本地计算机上,我们实际上可以控制我们在本地运行的区块链,因为它将运行在我们的本地计算机上(类似于Hardhat),现在我们在这个本地所做的一切,分叉的区块链不会影响主网,因为它是一个模拟区块链,它只是在我们的本地环境中运行,所以我们实际上可以与这种类似于模仿实际区块链的本地区块链进行交互；</p>
<p>现在这是分叉不做的事情，它不会在我们引用地址的时候将整个区块链下载到我们的本地设置中。在特定地址有一些东西，我们对我们的以太坊节点进行 api 调用，我们再次使用Alchemy,Alchemy会告诉我们这个地址是什么,它只会为我们返回那个特定的合约,这样我们就不必下载整个区块链并且速度上快得多。</p>
<p><img src="img/image-20221118112343481.png" alt="image-20221118112343481"></p>
<p>我们也可以用分叉来运行我们的测试,运行我们的脚本来做所有事情。</p>
<p><strong>分叉的优点:</strong>速度很快,很容易,并且测试网和主网的内容类似。</p>
<p><strong>分叉的缺点:</strong>我们需要一个API(我们不能在本地做所有事情),一些合约处理起来很复杂。</p>
<p><strong>但是使用分叉网络可能是运行测试的好方法,它是原来使用模拟合约的一个很好的替代方案,这取决于哪种方式更适合你的项目。</strong></p>
<p>Hardhat分叉还会给我们一堆假账户,所以我们仍然会在主网上得到一堆假帐户。</p>
<p>所以接下来的时间我们将使用分叉运行我们的脚本并运行我们的测试。</p>
<p>我们回到我们的Alchemy仪表盘,我们将创建一个新的APP,这个将用于Ethereum主网络.</p>
<p><img src="img/image-20221118153907314.png" alt="image-20221118153907314"></p>
<p>从Alchemy中读取出Mainnet的RPC和URL放于环境变量和Hardhat的配置当中</p>
<p>然后在AAVE借贷脚本中引入获得WETH的脚本</p>
<pre><code class="lang-js">const { getWeth } = require(&quot;../scripts/getWeth&quot;) //引入获得WETH代币的脚本

async function main() {
    //该协议将所有内容视为ERC20代币(因为该标准发送交易以及交互容易得多)
    //我们将跳过使用WETH的方式,我们将自己得到WETH代币并将它作为抵押品
    await getWeth() //调用获得WETH代币的函数
}

main()
    .then(() =&gt; process.exit(0))
    .catch((error) =&gt; {
        console.error(error)
        process.exit(1)
    })
</code></pre>
<p><img src="img/image-20221118160436060.png" alt="image-20221118160436060"></p>
<p>我们有办法将 ETH 分叉到主网上并运行我们的脚本和某种测试来查看和模拟实际运行的这些交易的情况。</p>
<p>接下来我们仍旧会模块化我们的getWeth函数然后把它放在helper-hardhat-config.js当中</p>
<h3 id="-aave-">往AAVE中存款</h3>
<p>现在开始我们要与AAVE协议交互</p>
<p>我们也选择使用AAVE V2中的协议，运行该命令进行导包</p>
<pre><code>yarn add --dev @aave/protocol-v2
</code></pre><p>在这里我们需要与借贷池提供者地址交互也需要与借贷池交互</p>
<p>需要获得它们各自的ABI和合约地址</p>
<p><img src="img/image-20221119093927184.png" alt="image-20221119093927184"></p>
<p>这里的LendingPool address实际上是以太坊主网的借贷池地址。</p>
<p><img src="img/image-20221119103451363.png" alt="image-20221119103451363"></p>
<p>aaveBorrow.js</p>
<pre><code class="lang-js">const { getNamedAccounts, ethers } = require(&quot;hardhat&quot;)
const { getWeth, AMOUNT } = require(&quot;../scripts/getWeth&quot;) //引入获得WETH代币的脚本

async function main() {
    //该协议将所有内容视为ERC20代币(因为该标准发送交易以及交互容易得多)
    //我们将跳过使用WETH的方式,我们将自己得到WETH代币并将它作为抵押品
    await getWeth() //调用获得WETH代币的函数
    const { deployer } = await getNamedAccounts() //从getNamedAccounts中拉取deployer函数
    //从现在开始我们要与AAVE协议进行交互
    //我们需要ABI和Address
    //ABI
    //Lending Pool Address Provider:0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5
    //将从上述地址中得到Lending Pool(借贷池)
    const lendingPool = await getLendingPool(deployer)
    console.log(`LendingPool address ${lendingPool.address}`) //输出借贷池日志

    //得到借贷池地址和WETH代币后我们就要存款了
    //在我们存款之前我们需要appreve AAVE合约得到我们的WETH代币
    const wethTokenAddress = &quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;
    //approve
    await approveErc20(wethTokenAddress, lendingPool.address, AMOUNT, deployer) //批准借贷池从我们的账户中提取WETH
    console.log(&quot;Depositing...&quot;)
    //deposit
    //存入资产的地址,存入资产的数量,deployer,参考代码(永远是0)
    await lendingPool.deposit(wethTokenAddress, AMOUNT, deployer, 0)
    console.log(&quot;Deposited!&quot;)
}

//现在与Lending Pool Adderess Provider(借贷池地址提供者)交互
//获得借贷池
async function getLendingPool(account) {
    //借贷池地址提供者
    const lendingPoolAddressesProvider = await ethers.getContractAt(
        &quot;ILendingPoolAddressesProvider&quot;,
        &quot;0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5&quot;,
        account
    ) //获取我们合约的ABI,借贷池地址提供者的地址,通过account变量获得借贷池(我们要通过的account当然会成为我们的deployer)
    const lendingPoolAddress = await lendingPoolAddressesProvider.getLendingPool() //获得借贷池地址
    //借贷池
    const lendingPool = await ethers.getContractAt(&quot;ILendingPool&quot;, lendingPoolAddress, account) //获得借贷池的ABI,借贷池地址,将account连接至部署脚本
    return lendingPool
}

//批准AAVE合约获得我们的WETH代币
//合约地址,花钱者的地址,批准花费的金额,账户
async function approveErc20(erc20Address, spenderAddress, amountToSpend, account) {
    const erc20Token = await ethers.getContractAt(&quot;IERC20&quot;, erc20Address, account) //获得批准ERC20代币的ABI,合约地址,并将account连接至部署脚本
    const tx = await erc20Token.approve(spenderAddress, amountToSpend) //批准花钱者地址进行交易
    await tx.wait(1)
    console.log(&quot;Approved!&quot;)
}

main()
    .then(() =&gt; process.exit(0))
    .catch((error) =&gt; {
        console.error(error)
        process.exit(1)
    })

</code></pre>
<p>此刻我们已经完成了第一步,我们已经存入了抵押品</p>
<h3 id="-aave-">从AAVE借贷</h3>
<p>现在我们有了一些抵押品可以用来借其他的资产</p>
<p><img src="img/image-20221119145638429.png" alt="image-20221119145638429"></p>
<p>关于DAI的喂价来了</p>
<p><img src="img/image-20221119152542517.png" alt="image-20221119152542517"></p>
<p>DAI的availableBorrowsETH</p>
<p><img src="img/image-20221119161336541.png" alt="image-20221119161336541"></p>
<pre><code class="lang-js">const { getNamedAccounts, ethers } = require(&quot;hardhat&quot;)
const { getWeth, AMOUNT } = require(&quot;../scripts/getWeth&quot;) //引入获得WETH代币的脚本

async function main() {
    //该协议将所有内容视为ERC20代币(因为该标准发送交易以及交互容易得多)
    //我们将跳过使用WETH的方式,我们将自己得到WETH代币并将它作为抵押品
    await getWeth() //调用获得WETH代币的函数
    const { deployer } = await getNamedAccounts() //从getNamedAccounts中拉取deployer函数
    //从现在开始我们要与AAVE协议进行交互
    //我们需要ABI和Address
    //ABI
    //Lending Pool Address Provider:0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5
    //将从上述地址中得到Lending Pool(借贷池)
    const lendingPool = await getLendingPool(deployer)
    console.log(`LendingPool address ${lendingPool.address}`) //输出借贷池日志

    //得到借贷池地址和WETH代币后我们就要存款了
    //在我们存款之前我们需要appreve AAVE合约得到我们的WETH代币
    const wethTokenAddress = &quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;
    //approve
    await approveErc20(wethTokenAddress, lendingPool.address, AMOUNT, deployer) //批准借贷池从我们的账户中提取WETH
    console.log(&quot;Depositing...&quot;)
    //deposit
    //存入资产的地址,存入资产的数量,deployer,参考代码(永远是0)
    await lendingPool.deposit(wethTokenAddress, AMOUNT, deployer, 0)
    console.log(&quot;Deposited!&quot;)

    //借贷时间到!
    //我们需要知道我们借了多少钱,我们有多少抵押品,我们可以借多少钱
    //AAVE中有一个函数getUserAccountData()可以返回用户在所有存储中的账户数据
    //这个账户数据会告诉我们有多少抵押品,我们有多少债务以及我们有多少可用借款,可以看到清算门槛,贷款的价值以及healthFactor
    //示例:对于DAI代币来说,如果你有一个ETH的抵押品,只能借75%等价值的DAI代币,这是为了降低抵押品的风险并降低人们的风险
    //如果你借出80%等价值的DAI代币的话就会被清算(其他用户将会拿走你的抵押品,作为回报他们支付你的贷款),这使得AAVE协议中借款永远不会多于抵押品
    //同时如果healthFactor低于1,你就会被清算
    //我们还可以构建一个收费的清算机器人,清算那些有偿付能力的用户
    let { availableBorrowsETH, totalDebtETH } = await getBrrowUserData(lendingPool, deployer)
    //DAI代币的转化率是多少?DAI的availableBorrowsETH是多少?
    //要做到这一点的话我们需要DAI代币的价格,我们将使用Chainlink喂价
    const daiPrice = await getDaiPrice()
    const amountDaiToBorrow = availableBorrowsETH.toString() * 0.95 * (1 / daiPrice.toNumber()) //我们只从能借的数量里借了95%
    console.log(`You can borrow ${amountDaiToBorrow} DAI`)
    const amountDaiToBorrowWei = ethers.utils.parseEther(amountDaiToBorrow.toString()) //以Wei为单位
    console.log(`You can borrow ${amountDaiToBorrowWei} DAI`)
    const daiTokenAddress = &quot;0x6B175474E89094C44Da98b954EedeAC495271d0F&quot; //从DAI代币的Etherscan上获得
    await borrowDai(daiTokenAddress, lendingPool, amountDaiToBorrowWei, deployer)
    await getBrrowUserData(lendingPool, deployer)
}

//开始借贷
async function borrowDai(daiAddress, lendingPool, amountDaiToBorrowWei, account) {
    //资产地址,想借的金额,利率模式(可变2/稳定1),参看代码(永远是0),代表地址
    const borrowTx = await lendingPool.borrow(daiAddress, amountDaiToBorrowWei, 1, 0, account)
    await borrowTx.wait(1)
    console.log(&quot;You&#39;ve borrowed!&quot;)
}

//喂价,这里需要 Chianlink 聚合器合约的abi和地址
async function getDaiPrice() {
    const daiEthPriceFeed = await ethers.getContractAt(
        &quot;AggregatorV3Interface&quot;,
        &quot;0x773616E4d11A78F511299002da57A0a94577F1f4&quot;
    ) //不需要将其连接到deployer账户,因为我们不会发送任何交易,我们只是阅读这份合约
    const price = (await daiEthPriceFeed.latestRoundData())[1] //使用的是聚合器合约里的函数,answer是这个合约中的1号索引数据
    console.log(`The DAI/ETH price is ${price.toString()}`)
    return price
}

//获得借贷用户数据
//借贷池合约,为其获取数据的账户
async function getBrrowUserData(lendingPool, account) {
    const { totalCollateralETH, totalDebtETH, availableBorrowsETH } =
        await lendingPool.getUserAccountData(account) //提取抵押品数量,欠债数量,可用借款数量
    console.log(`You have ${totalCollateralETH} worth of ETH deposited.`)
    console.log(`You have ${totalDebtETH} worth of ETH borrowed.`)
    console.log(`You can borrow ${availableBorrowsETH} worth of ETH.`)
    return { availableBorrowsETH, totalDebtETH }
}

//现在与Lending Pool Adderess Provider(借贷池地址提供者)交互
//获得借贷池
async function getLendingPool(account) {
    //借贷池地址提供者
    const lendingPoolAddressesProvider = await ethers.getContractAt(
        &quot;ILendingPoolAddressesProvider&quot;,
        &quot;0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5&quot;,
        account
    ) //获取我们合约的ABI,借贷池地址提供者的地址,通过account变量获得借贷池(我们要通过的account当然会成为我们的deployer)
    const lendingPoolAddress = await lendingPoolAddressesProvider.getLendingPool() //获得借贷池地址
    //借贷池
    const lendingPool = await ethers.getContractAt(&quot;ILendingPool&quot;, lendingPoolAddress, account) //获得借贷池的ABI,借贷池地址,将account连接至部署脚本
    return lendingPool
}

//批准AAVE合约获得我们的WETH代币
//合约地址,花钱者的地址,批准花费的金额,账户
async function approveErc20(erc20Address, spenderAddress, amountToSpend, account) {
    const erc20Token = await ethers.getContractAt(&quot;IERC20&quot;, erc20Address, account) //获得批准ERC20代币的ABI,合约地址,并将account连接至部署脚本
    const tx = await erc20Token.approve(spenderAddress, amountToSpend) //批准花钱者地址进行交易
    await tx.wait(1)
    console.log(&quot;Approved!&quot;)
}

main()
    .then(() =&gt; process.exit(0))
    .catch((error) =&gt; {
        console.error(error)
        process.exit(1)
    })

</code></pre>
<h3 id="-aave-">向AAVE还款</h3>
<p>我们已经在上面以编程方式借了一笔钱,我们现在编写还款代码</p>
<p><img src="img/image-20221119171836229.png" alt="image-20221119171836229"></p>
<p>可以看到在归还过DAI代币后我们还有一点点DAI代币处于已借状态,这部分DAI代币是怎么回事呢?</p>
<p>原因是因为当我们借 DAI 时，我们实际上产生了利息，所以说归还之后我们有一点已借的DAI代币.</p>
<p>现在我们可以尝试UniSwap这样的协议来真正交换我们的以太坊，实际将我们的以太坊换成 DAI，以在这里偿还我们剩余的 DAI。</p>
<p>我们可以像上述编程AAVE协议那样编程UniSwap协议.</p>
<h3 id="-">交易可视化</h3>
<p>当我们存入抵押品时,你会看到我们实际上取回了aWETH代币(计息代币),这些代币记录了我们存入AAVE协议的抵押品价值多少WETH,当我们想要收回我们的WETH时,我们燃烧掉这些aWETH代币并删除它们,可以看到我们的第一笔交易是存款(deposit)也就是代码中的lendingPool.deposit</p>
<p><img src="img/image-20221119173358612.png" alt="image-20221119173358612"></p>
<p>我们将WETH发送到AAVE合约,为了保持对账户抵押品利息的跟踪更新,AAVE会给我们发送aWETH(计息代币),随着我们存款越来越多，欠款时间越来越长,借出去的代币越来越多，计息代币会越来越多。</p>
<p><img src="img/image-20221120171232590.png" alt="image-20221120171232590"></p>
<h3 id="-">总结</h3>
<p>首先我们学习了WETH代币,这种代币象征以太坊(或Layer1)原生代币,然后我们稍微了解了AAVE协议以及它是如何用于借贷资产的，我们可以通过将我们的代币或资产存入AAVE来获得利息,我们也了解了一些关于UniSwap的知识(这是另一个非常重要的DeFi协议)，该协议允许我们在去中心化的背景下彼此之间交换代币。</p>
<p>然后我们知道我们实际上可以把我们的一些代币存入AAVE协议，AAVE是一个去中心化借贷平台，和银行类似，实际上会对我们存入的代币产生利息，起初我们必须批准AAVE合约获得我们的ERC20代币,因为任何时候我们都想要一个与我们的代币交互的合约,必须经过我们的批准合约才能这样做;</p>
<p>然后我们继续存款，一旦我们把抵押品存起来，我们就得到了DAI的价格，然后我们了解到我们实际上可以借DAI(我们基于抵押品的数量借入资产);</p>
<p>然后我们学会了如何还款我们了解到分叉区块链时要知道我们使用的主网RPC_URL(从Alchemy中获得).</p>
<p>DeFi绝对是区块链的巨大动力。</p>
<h2 id="14-hardhat-nft">14.使用Hardhat开发NFT</h2>
<p>什么是NFT？</p>
<p>NFTs也被称为ERC-721，是在以太坊平台上创建的代币标准。</p>
<p>NFT代表不可替代的代币,而且是类似于ERC-20的代币标准，ERC-20就像Link，AAVE，MAKER这些以太坊链上的优质项目一样。</p>
<p>NFT代币们互相之间完全不同，并且NFT之间不能直接进行互换(类似于宝可梦之间不能直接进行互换一样，世界上没有一模一样的宝可梦，同样也没有一模一样的NFT)，NFT就像交易卡，独特的艺术品一样。</p>
<p>NFT实际上就是一种代币标准，也就是部署在智能合约上的代币，所以他们不仅仅可以代表艺术，还可以用来统计数据等，但是目前最流行的应用就是数字艺术藏品。</p>
<p>我们可以在不同的NFT平台查看他们,例如：OpenSea和Rarible，这些都是NFT的交易平台。</p>
<p>NFTs可以像去中心化审计跟踪一样解决艺术家们的版税追踪，并且完全透明，不需要任何中心化服务，ERC-721标准或NFT标准是这一切的基础。还有一个标准是半可替代代币，被称为ERC-1155(这里不做详谈,仅作了解)。</p>
<p>ERC-721标准和ERC-20标准最大的区别是，在ERC-20标准上，合约代码有一个非常简单的映射，一个地址(address)以及该地址持有多少代币(uint256)；ERC-721也有一个很特殊的映射，ERC-721具有唯一的代币ID，每个代币ID(uint256)都有唯一的所有者(address)，除此之外，他们还有一个名叫tokenURI的函数(下方会讲)。</p>
<p>每个代币都是唯一的，每个代币ID代表一个独特的资产，因为这些资产是独一无二的，我们希望能够将它们可视化并展示它们的实际外观，我们需要定义对象的属性，这就是NFT当中Metadata和代币崛起的地方。</p>
<p>但是如果我们将艺术品/游戏的图像都推送到以太坊区块链上的话，汽油费将非常昂贵，所以要解决这个问题的话我们要将所谓的 把tokenUri函数放入合约中，tokenURI是一个独特的，普遍唯一的指标，表明该资产或该代币的外观以及该代币的属性是什么。</p>
<p>tokenURI只是一个简单的 API 调用，我们可以使用中心化API或IPFS之类的东西来实际获取tokenURL。</p>
<p><img src="img/image-20221120171112668.png" alt="image-20221120171112668"></p>
<p>典型的tokenURI必须返回下面这种格式返回属性，像这样它有名称，图像位置，描述以及下面的任何属性</p>
<p>图片 URI 是指向图片的独一无二的URI。</p>
<p><img src="img/image-20221120172025557.png" alt="image-20221120172025557"></p>
<p>人们经常谈论链上Metadata与链下Metadata，因为在链下存储所有Metadata更加容易和便宜，所以很多人会使用像 IPFS 这样去中心化的东西，但确实需要一点中心性来保持持久性，但是他们也可以使用他们自己的中心化API。然而，很明显，如果这一切都没法运行的话，那么你就失去了你的图片，失去了与NFT相关的一切。因此，大多数NFT市场实际上不能也不会读取链上属性或链上Metadata，因为他们习惯于查找tokenURI。</p>
<p>显然，如果你使用链下元数据的话，你不能做任何真正酷或真正有趣的事情，也不能从你的 NFTs 中获得任何收益。</p>
<p>例如，如果你想创建一个链上口袋妖怪游戏，你的所有属性都需要放在链上，以便你的口袋妖怪能够相互交互。因为如果它是链下的，那么密码证明就变得更难了。</p>
<p>如果你正在寻找渲染图像和 NFT，请将你的图像添加到IPFS，在 IPFS 上添加一个指向该图像文件的Meta文件。然后获取该tokenURI并将其设置到你的 NFT。</p>
<p>1.获得IPFS</p>
<p>2.将 tokenURI json 文件添加到 IPFS</p>
<p>3.将 IPFS URI 添加到您的 NFT URI</p>
<p>Chainlink DND 文章很好地引导您完成了这一点，并向您展示了如何做到这一点。</p>
<p><img src="img/image-20221120174743045.png" alt="image-20221120174743045"></p>
<p>我们将部署具有某些链上属性的第一个NFT。同样，将你的属性放在链上真的可以让你构建真正有创意的NFT，这些NFT可以构建游戏或具有有趣的属性，并确保你的NFT的真实性，因为这些属性永远都是在链上的。</p>
<h3 id="-">代码概述</h3>
<p><img src="img/image-20221120195705727.png" alt="image-20221120195705727"></p>
<p>EIP-721:不可替代代币标准。</p>
<p>我们要做的代码目前都在hardhat-nft-fcc当中，我们要遍历所有代码部署和创建我们自己定制的NFT。</p>
<p>我们要创建三种不同的NFT</p>
<p>1.一个基础NFT。</p>
<p>2.IPFS托管的NFT(它使用随机性来生成唯一NFT，这样我们就可以拥有可证明的稀有NFTs)。</p>
<p>3.SVG NFT(100%托管在链上)不需要IPFS和链下数据库，使用动态喂价。</p>
<h3 id="hardhat-">Hardhat配置</h3>
<p>这次安装NFT后其他的配置和项目都是复用之前的,并没有使用yarn hardhat</p>
<h3 id="-nft">基础NFT</h3>
<p>首先我们要安装@openzeppelin/contracts这个库</p>
<p>然后将ERC-721.sol这个文件导入到合约当中，接着重写构造函数，铸币函数和tokenURI函数</p>
<p>然后编写我们的部署脚本01-deploy-basic-nft.js，验证脚本verify.js，helper-hardhat-config.js自定义配置依赖(在这时候还暂时不需要用到这里面的依赖参数，只是提前导入)</p>
<p><strong>BasicNft.sol</strong></p>
<pre><code>const { network } = require(&quot;hardhat&quot;)
const { developmentChains } = require(&quot;../helper-hardhat-config&quot;)
const { verify } = require(&quot;../utils/verify&quot;)

module.exports = async function ({ getNamedAccounts, deployments }) {
    const { deploy, log } = deployments
    const { deployer } = await getNamedAccounts()

    log(&quot;----------------------&quot;)
    //我们的BasicNft合约不接受任何的构造函数参数
    const args = []
    //部署合约
    const basicNft = await deploy(&quot;BasicNft&quot;, {
        from: deployer,
        args: args,
        log: true,
        waitConfirmations: network.config.blockConfirmations || 1,
    })
    //验证合约
    if (!developmentChains.includes(network.name) &amp;&amp; process.env.ETHERSCAN_API_KEY) {
        log(&quot;Verifying...&quot;)
        await verify(basicNft.address, args)
    }
    log(&quot;----------------------&quot;)
}
module.exports.tags = [&quot;all&quot;, &quot;basicnft&quot;, &quot;main&quot;]
</code></pre><p>接下来书写测试脚本basicNft.test.js</p>
<pre><code>const { network, deployments, ethers } = require(&quot;hardhat&quot;)
const { developmentChains } = require(&quot;../../helper-hardhat-config&quot;)
const { assert } = require(&quot;chai&quot;)

!developmentChains.includes(network.name)
    ? describe.skip
    : describe(&quot;Basic NFT Unit Tests&quot;, function () {
          let basicNft, deployer
          beforeEach(async function () {
              accounts = await ethers.getSigners()
              deployer = accounts[0]
              await deployments.fixture([&quot;basicnft&quot;]) //fixture的作用是它允许我们使用basicnft标签来运行我们的整个部署文件夹
              basicNft = await ethers.getContract(&quot;BasicNft&quot;)
          })
          describe(&quot;构造函数&quot;, function () {
              it(&quot;正确初始化NFT&quot;, async function () {
                  const name = await basicNft.name() //NFT名字
                  const symbol = await basicNft.symbol() //NFT代号
                  const tokenCounter = await basicNft.getTokenCounter() //NFT id
                  assert.equal(name, &quot;Dogie&quot;)
                  assert.equal(symbol, &quot;DOG&quot;)
                  assert.equal(tokenCounter.toString(), &quot;0&quot;)
              })
          })
          describe(&quot;铸造NFT&quot;, function () {
              beforeEach(async function () {
                  const txResponse = await basicNft.mintNft() //确保每次测试是都是一个新的铸币函数交易(也就是说铸造了一枚NFT)
                  await txResponse.wait(1) //等待一个区块再书写该交易
              })
              it(&quot;允许用户创建NFT,并适当更新&quot;, async function () {
                  const tokenURI = await basicNft.tokenURI(0) //tokenURI返回代币的通用资源
                  const tokenCounter = await basicNft.getTokenCounter() //获得代币ID

                  assert.equal(tokenCounter.toString(), &quot;1&quot;) //铸造的第一枚代币的id是1
                  assert.equal(tokenURI, await basicNft.TOKEN_URI())
              })
              it(&quot;显示NFT的正确余额和所有者&quot;, async function () {
                  const deployerAddress = deployer.address //所有者
                  const deployerBalance = await basicNft.balanceOf(deployerAddress) //余额
                  const owner = await basicNft.ownerOf(&quot;0&quot;)

                  assert.equal(deployerBalance.toString(), &quot;1&quot;)
                  assert.equal(owner, deployerAddress)
              })
          })
      })

</code></pre><h3 id="-ipfs-nft">随机的IPFS NFT</h3>
<h4 id="-randomipfsnft">初步编写RandomIpfsNft</h4>
<p>创建新的合约RandomIpfsNft.sol。</p>
<p>要使用Chainlink的开箱即用函数,需要先运行yarn add --dev @chainlink/contracts添加Chainlink的合约库。</p>
<p>编写了构造函数和requestNft函数。</p>
<h4 id="-chainlink-vrf-">映射 Chainlink VRF 请求</h4>
<pre><code>//我们想要在requestId和调用它的人之间创建一个映射,这样当我们调用fulfillRandomWords函数时我们可以正确地将狗的品种分配给他们
    //VRF 助手
    mapping(uint256 =&gt; address) public s_requestIdToSender;

    //为了让用户成功使用这个映射,我们将创建tokenCounter
    //NFT 变量
    uint256 public s_tokenCounter;
</code></pre><p>同时我们又继承了ERC-721合约,在fulfillRandomWords函数的调用中使用了铸币函数</p>
<pre><code>    //重写Chanlink VRF合约中的这个函数
    //Chainlink节点调用此函数,通过随机数获得随机的NFT
    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {
        address dogOwner = s_requestIdToSender[requestId]; //狗主人等于调用者
        uint256 newTokenId = s_tokenCounter; //tokenId
        _safeMint(dogOwner, newTokenId); //从ERC-721继承而来的铸币函数
    }
</code></pre><h4 id="-nfts">创造稀有的NFTs</h4>
<p>首先便是创建机会数组,让每一种狗都有不同概率被铸造</p>
<pre><code>//机会数组,代表每一种狗的稀有度也就是说被铸造的机会
    //获得机会数组
    function getChanceArray() public pure returns (uint256[3] memory) {
        return [10, 30, MAX_CHANCE_VALUE]; //三种狗的铸造机会分别是10%(索引0),20%(索引1),70%(索引2)
    }
</code></pre><p>然后在铸造前就对这些品种狗的铸造机会进行分解</p>
<pre><code>      //类型声明
    enum Breed {
        PUG, //0
        SHIBA_INU, //1
        ST_BERNARD //2
    }

      //重写Chanlink VRF合约中的这个函数
    //Chainlink节点调用此函数,通过随机数获得随机的NFT
    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {
        address dogOwner = s_requestIdToSender[requestId]; //狗主人等于调用者
        uint256 newTokenId = s_tokenCounter; //tokenId
        //铸造出来的代币是什么样子的
        //我们可以使用Modulo函数从我们的机会数组中获取一个随机数
        //Modulo函数的原理是什么样子的呢?
        //假设s_player数组的长度大小是10,随机数是202
        // 202 % 10 = 2,我们使用索引2作为胜利者索引
        uint256 moddedRng = randomWords[0] % MAX_CHANCE_VALUE; //对100求余,这样我们可以得到一个介于0-99的随机数
        //moddedRng 0-10 Pug(哈巴狗)
        //moddedRng 10-30 Shiba Inu(柴犬)
        //moddedRng 30-99 St.Bernard(圣伯纳犬)

        Breed dogBreed = getBreedFromModdedRng(moddedRng);
        _safeMint(dogOwner, newTokenId); //从ERC-721继承而来的铸币函数
    }

    //通过Modulo函数计算过的随机数
    //通过moddedRng来获得狗的品种(Breed)
    function getBreedFromModdedRng(uint256 moddedRng) public pure returns (Breed) {
        uint256 cumulativeSum = 0; //累计总和
        uint256[3] memory chanceArray = getChanceArray(); //获得机会数组的对象
        for (uint256 i = 0; i &lt; chanceArray.length; i++) {
            if (moddedRng &gt;= cumulativeSum &amp;&amp; moddedRng &lt; cumulativeSum + chanceArray[i]) {
                return Breed(i);
            }
            cumulativeSum += chanceArray[i];
        }
        //如果在某种原因下我们没有返回Breed的话就恢复错误
        revert RandomIpfsNft__RangeOutOfBounds();
    }
</code></pre><h4 id="-nft-">设置NFT图像</h4>
<p>首先继承ERC721URIStorage的合约,然后重写自动更新URI的函数。</p>
<p>接着设置newTokenId到tokenURI数组的映射，这样不同的品种狗更新不同的tokenURI，设置不同的图像给NFT代币.</p>
<h4 id="-nft-">设置NFT铸币价格</h4>
<p>定义铸币价格变量,并在requestNft()函数中添加约束,如果部署函数所发送的ETH小于铸币价格时记得返回错误。</p>
<p>设置好后还需定义取款函数</p>
<pre><code>  //只有合约的所有者可以取钱,我们可以自己设置modifier,也可以导入其他合约里的onlyOwner()
    function withdraw() public onlyOwner {
        uint256 amount = address(this).balance; //
        //提取资金
        (bool success, ) = payable(msg.sender).call{value: amount}(&quot;&quot;);
        if (!success) {
            revert RandomIpfsNft__TransferFailed();
        } //如果调用不成功的话
    }
</code></pre><p>同时在我们的函数写好后我们还需要发送一些事件</p>
<h4 id="-ipfs-nft-">随机IPFS NFT合约回顾</h4>
<p>我们又requestNft()函数，人们必须付足够的费用才能调用，并且该函数编写了一个request到Chainlink节点获取随机数，一旦我们的合约得到那个随机数，它将会使用chanceArray数组来随机计算出我们实际该使用哪一个NFT用来铸造，同时我们也需要设置相应NFT的对应tokenUri，所以我们要存储图像数据到IPFS上。</p>
<h4 id="-">部署脚本</h4>
<p>我们既要部署随机IPFS NFT合约,还要部署模拟VRF Coordinator合约</p>
<pre><code>const { network, ethers } = require(&quot;hardhat&quot;)
const { developmentChains, networkConfig } = require(&quot;../helper-hardhat-config&quot;)
const { verify } = require(&quot;../utils/verify&quot;)

module.exports = async function ({ getNamedAccounts, deployments }) {
    const { deploy, log } = deployments
    const { deployer } = await getNamedAccounts()
    const chainId = network.config.chainId
    let vrfCoordinatorV2Address, subscriptionId
    //如果我们在开发链上
    if (developmentChains.includes(network.name)) {
        const vrfCoordinatorV2Mock = await ethers.getContract(&quot;VRFCoordinatorV2Mock&quot;) //部署模拟合约的对象
        vrfCoordinatorV2Address = vrfCoordinatorV2Mock.address //模拟合约地址
        const tx = await vrfCoordinatorV2Mock.createSubscription() //模拟合约创建订阅交易
        const txReceipt = await tx.wait(1) //等待一个区块后再把交易写到区块上
        subscriptionId = txReceipt.events[0].args.subId //获取订阅ID
    } else {
        //不在开发链上的话就强行把开发链上的配置传给他们
        vrfCoordinatorV2Address = networkConfig[chainId].vrfCoordinatorV2
        subscriptionId = networkConfig[chainId].subscriptionId
    }

    log(&quot;-----------------------------------------&quot;)
    const args = [
        vrfCoordinatorV2Address,
        subscriptionId,
        networkConfig[chainId].gasLane,
        networkConfig[chainId].mintFee,
        networkConfig[chainId].callbackGasLimit,
        //tokenUris
        networkConfig[chainId].mintFee,
    ]
}
</code></pre><h4 id="-pinata-tokenid">使用 Pinata 上传tokenId</h4>
<p>由于我们不可能7*24h开启我们的电脑(打开IPFS节点),所以我们也经常使用Pinata作为我们的默认设置。</p>
<p>首先要在项目中建立images文件夹,然后把图像传进去。</p>
<p>专门为tokenUri编写部署脚本(通过编程方式把图像上传到IPFS上)</p>
<p>并且我们在部署脚本中需要调用外部函数,外部函数都写在utils文件夹下uploadToPinata.js</p>
<p>首先在Pinata上创建账号</p>
<p><img src="img/image-20221129110450885.png" alt="image-20221129110450885"></p>
<p>Pinata本质上就是一个由别人经营的IPFS节点</p>
<p>在项目中安装pinata/sdk</p>
<pre><code>yarn add --dev @pinata/sdk@^1.1.23
</code></pre><p>帮助我们在项目中处理文件路径,我们运行以下命令</p>
<pre><code>yarn add --dev path
</code></pre><p><img src="img/image-20221129114713927.png" alt="image-20221129114713927"></p>
<p><img src="img/image-20221129150226812.png" alt="image-20221129150226812"></p>
<p>运行上述命令成功以代码方式将图片上传至Pinata中</p>
<p><img src="img/image-20221129150256697.png" alt="image-20221129150256697"></p>
<h4 id="-pinata-token-uris-metadata-">通过Pinata上传token URIs(metadata)</h4>
<p>现在开始存储tokenURI的metadata,</p>
<p><img src="img/image-20221129193037500.png" alt="image-20221129193037500"></p>
<p>成功上传tokenURI</p>
<h4 id="-">继续部署脚本</h4>
<p>我们将部署合约的参数和tokenUri都准备好后我们就开始正式部署合约,并且可以不再使用handleTokenUris函数了。</p>
<h4 id="-ipfs-nft-">随机IPFS NFT 测试</h4>
<p>代码有问题,可能后续课程会解决问题。</p>
<h3 id="-svg-nft">动态SVG链上NFT</h3>
<p>我们其实不需要在IPFS上托管我们的数据,我们实际上可以在链上托管我们的数据</p>
<h4 id="-svg-">什么是SVG？</h4>
<p>SVG代表可缩放矢量图形,SVG 以 XML 格式定义基于矢量的图形。XML格式的文件要简约得多,我们可以将其上传到区块链。</p>
<p>这就是我们使用它的原因，因为它足够简约，所以上传到区块链上时的花费比较便宜。</p>
<p>因为我们上传到区块链上的数据越多，费用就越贵。</p>
<p>无论我们制作多大的SVG，质量总是完全相同的，因为SVG只是解释了如何绘制它。</p>
<h4 id="-">初始代码</h4>
<p>创建DynamicSvgNft.sol文件</p>
<pre><code>//SPDX-License-Identifier:MIT
pragma solidity ^0.8.7;
//导入ERC721合约
import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;;

contract DynamicSvgNft is ERC721 {
    //mint函数
    //store SVG 信息的函数
    //一些逻辑代码,用来切换&quot;X Image&quot;或&quot;Y Image&quot;

    uint256 private s_tokenCounter; //每次铸币的时候都要计数然后产生新的tokenId

    //我们希望SVG基于某些资产的价格而动态改变
    constructor(string memory lowSvg, string memory highSvg) ERC721(&quot;Dynamic SVG NFT&quot;, &quot;DSN&quot;) {
        s_tokenCounter = 0;
    }

    function mintNft() public {
        _safeMint(msg.sender, s_tokenCounter); //从ERC721继承而来的铸币函数
        s_tokenCounter = s_tokenCounter + 1;
    }
}
</code></pre><h4 id="base64-">Base64编码</h4>
<p><img src="img/image-20221130134300869.png" alt="image-20221130134300869"></p>
<p>这个Base64编码代表我们刚刚得到的SVG，我们可以在浏览器地址中以下面这样的形式查看图像。</p>
<pre><code>data:image/svg+xml;base64,编码
</code></pre><p>运行下面的命令导入Base64编码的合约</p>
<pre><code>yarn add --dev base64-sol
</code></pre><pre><code>       string private constant base64EncodedSvgPrefix = &quot;data:image/svg+xml;base64,&quot;; //Base64编码的前缀,相当于ipfs://

   //将SVG代码转化为Base64编码形式的ImageURI
    function svgToImageURI(string memory svg) public pure returns (string memory) {
        //创建svg经过Base64编码后的对象
        string memory svgBase64Encoded = Base64.encode(bytes(string(abi.encodePacked(svg)))); //base64合约的编码函数
        return string(abi.encodePacked(base64EncodedSvgPrefix, svgBase64Encoded)); //将Base64编码的前缀附上去
    }
</code></pre><h4 id="-">进阶部分:编码、操作码和调用</h4>
<p>对于我们大的大多数基本项目，我们不会需要这些信息，只是一旦我们做一些高级的项目时，知道这些信息可以让我们成为一个了不起的Solidity开发者</p>
<p>在这一部分我们所编写的代码都在sublesson文件夹下</p>
<h5 id="abi-encodeabi-encodepacked">abi.encode&amp;abi.encodePacked</h5>
<p>abi.encode和abi.encodePacked是Solidity全局可用的方法，在Solidity文档中都可以查到。</p>
<p>在0.8.12版本以上的Solidity中我们可以使用下面这行代码来取代abi.encodePacked</p>
<pre><code>string.concat(stringA,stringB);
</code></pre><p><strong>在我们深入了解这两个方法之前我们要先知道我们发送交易时会发生什么</strong></p>
<p><img src="img/image-20221130145122790.png" alt="image-20221130145122790"></p>
<p>当我们编译代码时，所有这些图片都将出现在github仓库中。</p>
<p>当我们回到ethers.js中时,编译我们的代码会出现一个abi文件和一个二进制文件。</p>
<p>同时在Remix中编译代码也是出现这两个文件。</p>
<p>所以说当我们向区块链发送我们的合约时,我们实际上发送的是二进制文件</p>
<p><strong>下图是ethers项目中我们的交易属性</strong></p>
<p><img src="img/image-20221130150448532.png" alt="image-20221130150448532"></p>
<p><strong>下图是我们实际部署合约时的交易属性</strong></p>
<p><img src="img/image-20221130150700042.png" alt="image-20221130150700042"></p>
<p>我们会注意到To是空的,因为我们实际上不会把这个合约发送到任何地址。</p>
<p><strong>Encoding.sol</strong></p>
<pre><code>//SPDX-License-Identifier:MIT
pragma solidity ^0.8.7;

contract Encoding {
    //连接字符串函数
    function combineStrings() public pure returns(string memory){
        return string(abi.encodePacked(&quot;Hi Mom!&quot;,&quot;Miss you!&quot;));//string()括号里面是bytes对象
    }//abi.encodePacked()是Solidity全局可用的方法之一
    //当我们发送交易时，它被“编译”为字节码并在交易的“data”对象中发送。
    //该data对象现在控制着未来的交易如何与它交互。
    //为了让区块链理解data对象中的字节码是什么意思,我们需要一个特殊的阅读器
    //这个阅读器需要将所有这些随机数字和字母映射为它们实际的意义

    //data对象中的字节码代表使我们合约发生的简单的计算机指令,所有这些数字和字母代表一种字母表(也被称为opcode操作码)
    //任何可以编译成这种操作码的语言，都可以编译成一组特定的ethereum操作码或evm操作码，这就是所谓的evm(以太坊虚拟机)
    //evm基本上代表了计算机必须能够读取的所有指令，以便与ethereum(或类似以太坊的应用程序)交互
    //这也就是为什么如此多的区块链可以通过Solidity运行,因为Solidity把不同区块链上的代码都编译成相同类型的二进制文件(它们有完全相同的阅读器)

    //将数字编码为它的abi或二进制格式,这样我们的合约就可以与其交互
    function encodeNumber() public pure returns(bytes memory){
        bytes memory number = abi.encode(1);
        return number;
    }

    //将字符串编码为它的abi或二进制格式,这样我们的合约就可以与其交互
    function encodeString() public pure returns(bytes memory){
        bytes memory someString = abi.encode(&quot;some string&quot;);
        return someString;
    }

    //encodePacked有点像压缩器,如果我们想编码一些字符串但我们想节省空间那么我们就不需要让它的二进制格式这么冗余(这种方式更加节省汽油费)
    function encodeStringPacked() public pure returns(bytes memory){
        bytes memory someString = abi.encodePacked(&quot;some string&quot;);
        return someString;
    }

    //这个类型转换的效果和encodePacked一模一样
    function encodeStringBytes() public pure returns(bytes memory){
        bytes memory someString = bytes(&quot;some string&quot;);
        return someString;
    }


    //对字符串进行解码
    function decodeString() public pure returns(string memory){
        string memory someString = abi.decode(encodeString(),(string));//encodedData是解码函数的第一个参数,解码后的参数类型是解码函数的第二个参数
        return someString;
    }
    //多重编码
    function multiEncode() public pure returns(bytes memory){
        bytes memory someString =  abi.encode(&quot;some string&quot;,&quot;it&#39;s bigger!&quot;);
        return someString;
    }
    //多重解码
    function multiDecode() public pure returns(string memory,string memory){
        (string memory someString,string memory someOtherString) = abi.decode(multiEncode(),(string,string));
        return (someString,someOtherString);
    }
    //进阶多重编码
    function multiEncodePacked() public pure returns(bytes memory){
        bytes memory someString = abi.encodePacked(&quot;some string&quot;,&quot;it&#39;s bigger!&quot;);
        return someString;
    }

    //普通解码对于进阶多重编码是行不通的
    // function multiDecodePacked() public pure returns(string memory){
    //     string memory someString = abi.decode(multiEncodePacked(),(string));
    //     return someString;
    // } 

    //进阶多重解码
    function multiStringCastPacked() public pure returns(string memory){
        string memory someString = string(multiEncodePacked());//通过类型转换的逆用巧妙形成解码
        return someString;
    }
}
</code></pre><h5 id="-encoding-">直接Encoding函数调用介绍</h5>
<p><strong>下图是函数调用时的交易属性</strong></p>
<p><img src="img/image-20221130212314836.png" alt="image-20221130212314836"></p>
<p>这里的data字段比较特别,是十六进制版本的二进制byte代码</p>
<pre><code>    //1.ABI
    //2.Contract Address
    //我们如何发送仅填充data字段的调用函数的交易?
    //我们如何填充data字段?

    // Solidity实际上有一些更底层的关键字,即&quot;staticcall&quot; 和&quot;call&quot;.我们过去曾经使用过call,但是没有解释过我们是如何运行的
    // call: 我们通过调用函数来改变区块链的状态.
    // staticcall: 在底层我们调用&quot;view&quot;或&quot;pure&quot;函数,我们并没有改变区块链的状态
    function withdraw(address recentWinner) public {
        //我们不仅可以在前方的括号里更新value,还可以更新gas price和gas limit；后方的小括号是我们粘贴数据的地方(我们可以填充特定数据来实际调用特定函数)
        (bool success,) = recentWinner.call{value:address(this).balance}(&quot;&quot;);
        require(success,&quot;Transfer Failed&quot;);
    }

    //记住以下几个方面
    //——在我们的花括号中我们可以传递交易的特定字段,例如value.
    //——在我们的小括号中我们能够传递数据以调用特定的函数 - 但是上述代码中没有我们想要调用的函数!
    //我们只需要发送ETH,所以我们不需要调用函数!
    //如果我们想要调用函数或者发送一些数据,我们会用这些(&quot;&quot;)来做!
</code></pre><h5 id="-encoding-">直接调用Encoding函数</h5>
<p>让我们学习如何填充调用函数的后一个括号内的数据字段，使得我们可以调用任何函数。</p>
<p>无合约调用函数</p>
<pre><code>//SPDX-License-Identifier:MIT
pragma solidity ^0.8.7;

// 为了仅使用 call 的数据字段来调用函数，我们需要编码：1.函数名称;2.我们想要添加的参数;
// 将以上编码为二进制级别,以便EVM或者这些基于以太坊的Solidity智能合约可以理解实际发生的事情

// 现在，每个合约为每个函数分配一个函数ID.这被称为“函数选择器”.
// “函数选择器”是函数签名编码的前 4 个字节.
// “函数签名”是定义函数名称和参数的字符串.

contract CaLLAnything{
    address public s_someAddress;//合约地址
    uint256 public s_amount;//传送金额

    //函数签名示例
    function transfer(address someAddress,uint256 amount) public {
        s_someAddress = someAddress;
        s_amount = amount;
    }

    //函数选择器示例1
    function getSelectorOne() public pure returns(bytes4 selector){
        selector = bytes4(keccak256(bytes(&quot;transfer(address,uint256)&quot;)));//以太坊使用的是keccak256算法
    }

    //我们需要将所有数据放入交易的data字段中，以发送给该合约，让该合约知道“使用transefer函数，传入一些地址，然后传入一个金额”
    function getDataToCallTransfer(address someAddress,uint256 amount) public pure returns(bytes memory){
        return abi.encodeWithSelector(getSelectorOne(),someAddress,amount);
    }

    //上述都是为了使用call来调用函数而提前做的准备,“函数选择器”是函数签名编码的前 4 个字节所以这里只返回前四个byte
    //这个函数会让我们通过传递这些参数来直接调用transfer函数,我们只需更改调用的地址就可以跨多个合约执行此操作(不需要继承合约也可以调用其他合约里的函数)
    function callTransferFunctionDirectly(address someAddress,uint256 amount) public returns(bytes4,bool){
        (bool success,bytes memory returnData) = address(this).call(
            //getDataToCallTransfer(someAddress,amount) 这一行代码和下面这行的作用一样
            abi.encodeWithSelector(getSelectorOne(),someAddress,amount)
        );
        return(bytes4(returnData),success);
    }
    //我们也可以使用签名进行编码调用而不是选择器
    function callTransferFunctionDirectlySig(address someAddress,uint256 amount) public returns(bytes4,bool){
        (bool success,bytes memory returnData) = address(this).call(
                          abi.encodeWithSignature(&quot;transfer(address,uint256)&quot;,someAddress,amount)
        );
        return(bytes4(returnData),success);
    }
}
</code></pre><h4 id="-nft-tokenuri">在链上创建 NFT TokenURI</h4>
<pre><code>//重写继承自ERC721合约的_baseURI函数,返回json文件Base64编码前缀
    function _baseURI() internal pure override returns (string memory) {
        return &quot;data:application/json;base64,&quot;;
    }

    //重写继承自ERC721合约的tokenURI函数,在这里我们将把我们提供给合约的一些 json 文本编码转换为Base64编码格式的tokenURI
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        //先添加约束
        require(_exists(tokenId), &quot;URI Query for nonexistent token&quot;); //tokenId如果不存在的话返回错误语句
        string memory imageURI = &quot;hi!&quot;; //imageURI是上面的函数中得到的
        //svg图像Base64编码前缀---data:image/svg+xml;base64,
        //json文件Base64编码前缀---data:application/json;base64,
        //连接字符串(从ERC721继承而来的name函数)并转换为Base64编码格式
        return
            string(
                abi.encodePacked(
                    _baseURI(),
                    Base64.encode(
                        bytes(
                            abi.encodePacked(
                                &#39;{&quot;name&quot;:&quot;&#39;,
                                name(), // You can add whatever name here
                                &#39;&quot;, &quot;description&quot;:&quot;An NFT that changes based on the Chainlink Feed&quot;, &#39;,
                                &#39;&quot;attributes&quot;: [{&quot;trait_type&quot;: &quot;coolness&quot;, &quot;value&quot;: 100}], &quot;image&quot;:&quot;&#39;,
                                imageURI,
                                &#39;&quot;}&#39;
                            )
                        )
                    )
                )
            );
        //我们正在创建一个json字符串，我们以字节为单位对其进行编码，而后在base64中对其进行了编码
    }
</code></pre><h4 id="-nft-">使NFT动态变化</h4>
<p>在我们你的构造函数中我们传递了lowSvg和highSvg,分别代表了哭脸和笑脸。</p>
<p>运行下面的命令添加Chainlink喂价所需要的合约</p>
<pre><code>yarn add --dev @chainlink/contracts@0.4.0
</code></pre><h4 id="-nft-">动态链上NFT部署脚本</h4>
<pre><code>const { network, ethers } = require(&quot;hardhat&quot;)
const { developmentChains, networkConfig } = require(&quot;../helper-hardhat-config&quot;)
const { verify } = require(&quot;../utils/verify&quot;)
const fs = require(&quot;fs&quot;)

module.exports = async function ({ getNamedAccounts, deployments }) {
    const { deploy, log } = deployments
    const { deployer } = await getNamedAccounts()

    const chainId = network.config.chainId
    let ethUsdPriceFeedAddress //喂价地址

    if (developmentChains.includes(network.name)) {
        const EthUsdAggregator = await ethers.getContract(&quot;MockV3Aggregator&quot;) //获取模拟Chainlink合约对象
        ethUsdPriceFeedAddress = EthUsdAggregator.address
    } else {
        ethUsdPriceFeedAddress = networkConfig[chainId].ethUsdPriceFeed //强制性地把开发链的相关配置给他
    }
    log(&quot;-----------------------------------------&quot;)
    const lowSVG = await fs.readFileSync(&quot;./images/dynamicNft/frown.svg&quot;, { encoding: &quot;utf-8&quot; }) //读取哭脸文件
    const highSVG = await fs.readFileSync(&quot;./images/dynamicNft/happy.svg&quot;, { encoding: &quot;utf-8&quot; }) //读取笑脸文件
    //部署合约所需要的参数
    args = [ethUsdPriceFeedAddress, lowSVG, highSVG]
    //部署合约
    const dynamicSvgNft = await deploy(&quot;DynamicSvgNft&quot;, {
        from: deployer, //部署者
        args: args, //我们将把所有参数传递给构造函数
        log: true, //自定义日志,这样我们就不必做所有的console.log
        waitConfirmations: network.config.blockConfirmations || 1, //块确认
    })
    log(&quot;-----------------------------------------&quot;)
    //验证合约
    if (!developmentChains.includes(network.name) &amp;&amp; process.env.ETHERSCAN_API_KEY) {
        log(&quot;Verifying...&quot;)
        await verify(dynamicSvgNft.address, args)
    }
}

module.exports.tags = [&quot;all&quot;, &quot;dynamicsvg&quot;, &quot;main&quot;]

</code></pre><h4 id="-">编写测试脚本</h4>
<pre><code>const { assert, expect } = require(&quot;chai&quot;)
const { network, deployments, ethers } = require(&quot;hardhat&quot;)
const { developmentChains } = require(&quot;../../helper-hardhat-config&quot;)

const lowSVGImageuri =
    &quot;data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8c3ZnIHdpZHRoPSIxMDI0cHgiIGhlaWdodD0iMTAyNHB4IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxwYXRoIGZpbGw9IiMzMzMiIGQ9Ik01MTIgNjRDMjY0LjYgNjQgNjQgMjY0LjYgNjQgNTEyczIwMC42IDQ0OCA0NDggNDQ4IDQ0OC0yMDAuNiA0NDgtNDQ4Uzc1OS40IDY0IDUxMiA2NHptMCA4MjBjLTIwNS40IDAtMzcyLTE2Ni42LTM3Mi0zNzJzMTY2LjYtMzcyIDM3Mi0zNzIgMzcyIDE2Ni42IDM3MiAzNzItMTY2LjYgMzcyLTM3MiAzNzJ6Ii8+CiAgPHBhdGggZmlsbD0iI0U2RTZFNiIgZD0iTTUxMiAxNDBjLTIwNS40IDAtMzcyIDE2Ni42LTM3MiAzNzJzMTY2LjYgMzcyIDM3MiAzNzIgMzcyLTE2Ni42IDM3Mi0zNzItMTY2LjYtMzcyLTM3Mi0zNzJ6TTI4OCA0MjFhNDguMDEgNDguMDEgMCAwIDEgOTYgMCA0OC4wMSA0OC4wMSAwIDAgMS05NiAwem0zNzYgMjcyaC00OC4xYy00LjIgMC03LjgtMy4yLTguMS03LjRDNjA0IDYzNi4xIDU2Mi41IDU5NyA1MTIgNTk3cy05Mi4xIDM5LjEtOTUuOCA4OC42Yy0uMyA0LjItMy45IDcuNC04LjEgNy40SDM2MGE4IDggMCAwIDEtOC04LjRjNC40LTg0LjMgNzQuNS0xNTEuNiAxNjAtMTUxLjZzMTU1LjYgNjcuMyAxNjAgMTUxLjZhOCA4IDAgMCAxLTggOC40em0yNC0yMjRhNDguMDEgNDguMDEgMCAwIDEgMC05NiA0OC4wMSA0OC4wMSAwIDAgMSAwIDk2eiIvPgogIDxwYXRoIGZpbGw9IiMzMzMiIGQ9Ik0yODggNDIxYTQ4IDQ4IDAgMSAwIDk2IDAgNDggNDggMCAxIDAtOTYgMHptMjI0IDExMmMtODUuNSAwLTE1NS42IDY3LjMtMTYwIDE1MS42YTggOCAwIDAgMCA4IDguNGg0OC4xYzQuMiAwIDcuOC0zLjIgOC4xLTcuNCAzLjctNDkuNSA0NS4zLTg4LjYgOTUuOC04OC42czkyIDM5LjEgOTUuOCA4OC42Yy4zIDQuMiAzLjkgNy40IDguMSA3LjRINjY0YTggOCAwIDAgMCA4LTguNEM2NjcuNiA2MDAuMyA1OTcuNSA1MzMgNTEyIDUzM3ptMTI4LTExMmE0OCA0OCAwIDEgMCA5NiAwIDQ4IDQ4IDAgMSAwLTk2IDB6Ii8+Cjwvc3ZnPgo=&quot;
const highSVGImageuri =
    &quot;data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAwIDIwMCIgd2lkdGg9IjQwMCIgIGhlaWdodD0iNDAwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxjaXJjbGUgY3g9IjEwMCIgY3k9IjEwMCIgZmlsbD0ieWVsbG93IiByPSI3OCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIzIi8+CiAgPGcgY2xhc3M9ImV5ZXMiPgogICAgPGNpcmNsZSBjeD0iNjEiIGN5PSI4MiIgcj0iMTIiLz4KICAgIDxjaXJjbGUgY3g9IjEyNyIgY3k9IjgyIiByPSIxMiIvPgogIDwvZz4KICA8cGF0aCBkPSJtMTM2LjgxIDExNi41M2MuNjkgMjYuMTctNjQuMTEgNDItODEuNTItLjczIiBzdHlsZT0iZmlsbDpub25lOyBzdHJva2U6IGJsYWNrOyBzdHJva2Utd2lkdGg6IDM7Ii8+Cjwvc3ZnPg==&quot;

const highTokenUri =
    &quot;data:application/json;base64,eyJuYW1lIjoiRHluYW1pYyBTVkcgTkZUIiwgImRlc2NyaXB0aW9uIjoiQW4gTkZUIHRoYXQgY2hhbmdlcyBiYXNlZCBvbiB0aGUgQ2hhaW5saW5rIEZlZWQiLCAiYXR0cmlidXRlcyI6IFt7InRyYWl0X3R5cGUiOiAiY29vbG5lc3MiLCAidmFsdWUiOiAxMDB9XSwgImltYWdlIjoiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCMmFXVjNRbTk0UFNJd0lEQWdNakF3SURJd01DSWdkMmxrZEdnOUlqUXdNQ0lnSUdobGFXZG9kRDBpTkRBd0lpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaVBnb2dJRHhqYVhKamJHVWdZM2c5SWpFd01DSWdZM2s5SWpFd01DSWdabWxzYkQwaWVXVnNiRzkzSWlCeVBTSTNPQ0lnYzNSeWIydGxQU0ppYkdGamF5SWdjM1J5YjJ0bExYZHBaSFJvUFNJeklpOCtDaUFnUEdjZ1kyeGhjM005SW1WNVpYTWlQZ29nSUNBZ1BHTnBjbU5zWlNCamVEMGlOakVpSUdONVBTSTRNaUlnY2owaU1USWlMejRLSUNBZ0lEeGphWEpqYkdVZ1kzZzlJakV5TnlJZ1kzazlJamd5SWlCeVBTSXhNaUl2UGdvZ0lEd3ZaejRLSUNBOGNHRjBhQ0JrUFNKdE1UTTJMamd4SURFeE5pNDFNMk11TmprZ01qWXVNVGN0TmpRdU1URWdOREl0T0RFdU5USXRMamN6SWlCemRIbHNaVDBpWm1sc2JEcHViMjVsT3lCemRISnZhMlU2SUdKc1lXTnJPeUJ6ZEhKdmEyVXRkMmxrZEdnNklETTdJaTgrQ2p3dmMzWm5QZz09In0=&quot;
const lowTokenUri =
    &quot;data:application/json;base64,eyJuYW1lIjoiRHluYW1pYyBTVkcgTkZUIiwgImRlc2NyaXB0aW9uIjoiQW4gTkZUIHRoYXQgY2hhbmdlcyBiYXNlZCBvbiB0aGUgQ2hhaW5saW5rIEZlZWQiLCAiYXR0cmlidXRlcyI6IFt7InRyYWl0X3R5cGUiOiAiY29vbG5lc3MiLCAidmFsdWUiOiAxMDB9XSwgImltYWdlIjoiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJ6ZEdGdVpHRnNiMjVsUFNKdWJ5SS9QZ284YzNabklIZHBaSFJvUFNJeE1ESTBjSGdpSUdobGFXZG9kRDBpTVRBeU5IQjRJaUIyYVdWM1FtOTRQU0l3SURBZ01UQXlOQ0F4TURJMElpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaVBnb2dJRHh3WVhSb0lHWnBiR3c5SWlNek16TWlJR1E5SWswMU1USWdOalJETWpZMExqWWdOalFnTmpRZ01qWTBMallnTmpRZ05URXljekl3TUM0MklEUTBPQ0EwTkRnZ05EUTRJRFEwT0MweU1EQXVOaUEwTkRndE5EUTRVemMxT1M0MElEWTBJRFV4TWlBMk5IcHRNQ0E0TWpCakxUSXdOUzQwSURBdE16Y3lMVEUyTmk0MkxUTTNNaTB6TnpKek1UWTJMall0TXpjeUlETTNNaTB6TnpJZ016Y3lJREUyTmk0MklETTNNaUF6TnpJdE1UWTJMallnTXpjeUxUTTNNaUF6TnpKNklpOCtDaUFnUEhCaGRHZ2dabWxzYkQwaUkwVTJSVFpGTmlJZ1pEMGlUVFV4TWlBeE5EQmpMVEl3TlM0MElEQXRNemN5SURFMk5pNDJMVE0zTWlBek56SnpNVFkyTGpZZ016Y3lJRE0zTWlBek56SWdNemN5TFRFMk5pNDJJRE0zTWkwek56SXRNVFkyTGpZdE16Y3lMVE0zTWkwek56SjZUVEk0T0NBME1qRmhORGd1TURFZ05EZ3VNREVnTUNBd0lERWdPVFlnTUNBME9DNHdNU0EwT0M0d01TQXdJREFnTVMwNU5pQXdlbTB6TnpZZ01qY3lhQzAwT0M0eFl5MDBMaklnTUMwM0xqZ3RNeTR5TFRndU1TMDNMalJETmpBMElEWXpOaTR4SURVMk1pNDFJRFU1TnlBMU1USWdOVGszY3kwNU1pNHhJRE01TGpFdE9UVXVPQ0E0T0M0Mll5MHVNeUEwTGpJdE15NDVJRGN1TkMwNExqRWdOeTQwU0RNMk1HRTRJRGdnTUNBd0lERXRPQzA0TGpSak5DNDBMVGcwTGpNZ056UXVOUzB4TlRFdU5pQXhOakF0TVRVeExqWnpNVFUxTGpZZ05qY3VNeUF4TmpBZ01UVXhMalpoT0NBNElEQWdNQ0F4TFRnZ09DNDBlbTB5TkMweU1qUmhORGd1TURFZ05EZ3VNREVnTUNBd0lERWdNQzA1TmlBME9DNHdNU0EwT0M0d01TQXdJREFnTVNBd0lEazJlaUl2UGdvZ0lEeHdZWFJvSUdacGJHdzlJaU16TXpNaUlHUTlJazB5T0RnZ05ESXhZVFE0SURRNElEQWdNU0F3SURrMklEQWdORGdnTkRnZ01DQXhJREF0T1RZZ01IcHRNakkwSURFeE1tTXRPRFV1TlNBd0xURTFOUzQySURZM0xqTXRNVFl3SURFMU1TNDJZVGdnT0NBd0lEQWdNQ0E0SURndU5HZzBPQzR4WXpRdU1pQXdJRGN1T0MwekxqSWdPQzR4TFRjdU5DQXpMamN0TkRrdU5TQTBOUzR6TFRnNExqWWdPVFV1T0MwNE9DNDJjemt5SURNNUxqRWdPVFV1T0NBNE9DNDJZeTR6SURRdU1pQXpMamtnTnk0MElEZ3VNU0EzTGpSSU5qWTBZVGdnT0NBd0lEQWdNQ0E0TFRndU5FTTJOamN1TmlBMk1EQXVNeUExT1RjdU5TQTFNek1nTlRFeUlEVXpNM3B0TVRJNExURXhNbUUwT0NBME9DQXdJREVnTUNBNU5pQXdJRFE0SURRNElEQWdNU0F3TFRrMklEQjZJaTgrQ2p3dmMzWm5QZ289In0=&quot;

!developmentChains.includes(network.name)
    ? describe.skip
    : describe(&quot;Dynamic SVG NFT Unit Tests&quot;, function () {
          let dynamicSvgNft, deployer, MockV3Aggregator

          beforeEach(async function () {
              accounts = await ethers.getSigners()
              deployer = accounts[0]
              await deployments.fixture([&quot;mocks&quot;, &quot;dynamicsvg&quot;])
              dynamicSvgNft = await ethers.getContract(&quot;DynamicSvgNft&quot;)
              mockV3Aggregator = await ethers.getContract(&quot;MockV3Aggregator&quot;)
          })

          describe(&quot;constructor&quot;, function () {
              it(&quot;正确设置起始值&quot;, async function () {
                  const lowSVG = await dynamicSvgNft.getLowSVG()
                  const highSVG = await dynamicSvgNft.getHighSVG()
                  const priceFeed = await dynamicSvgNft.getPriceFeed()
                  assert.equal(lowSVG, lowSVGImageuri)
                  assert.equal(highSVG, highSVGImageuri)
                  assert.equal(priceFeed, mockV3Aggregator.address)
              })
          })
          describe(&quot;mintNft&quot;, function () {
              it(&quot;发出事件并创建NFT&quot;, async function () {
                  const highValue = ethers.utils.parseEther(&quot;1&quot;) //1美元/以太坊
                  await expect(dynamicSvgNft.mintNft(highValue)).to.emit(
                      dynamicSvgNft,
                      &quot;CreatedNFT&quot;
                  )
                  const tokenCounter = await dynamicSvgNft.getTokenCounter() //获取tokenId
                  assert.equal(tokenCounter.toString(), &quot;1&quot;)
                  const tokenURI = await dynamicSvgNft.tokenURI(0) //获取tokenURI
                  assert.equal(tokenURI, highTokenUri)
              })
              it(&quot;当价格未超过最高值时,将tokenURI转换为low&quot;, async function () {
                  const highValue = ethers.utils.parseEther(&quot;100000000&quot;) //100000000美元/以太坊。也许在遥远的将来，这个测试会失败。
                  const txResponse = await dynamicSvgNft.mintNft(highValue)
                  await txResponse.wait(1)
                  const tokenURI = await dynamicSvgNft.tokenURI(0)
                  assert.equal(tokenURI, lowTokenUri)
              })
          })
      })
</code></pre><h4 id="-nft">在测试网上部署NFT</h4>
<p>首先部署铸币脚本</p>
<pre><code>const { ethers, network } = require(&quot;hardhat&quot;)
const { developmentChains } = require(&quot;../helper-hardhat-config&quot;)
module.exports = async function ({ getNamedAccounts }) {
    const { deployer } = await getNamedAccounts()

    //Basic NFT
    const basicNft = await ethers.getContract(&quot;BasicNft&quot;, deployer) //获得合约对象
    const basicMintTx = await basicNft.mintNft() //获取铸币函数交易
    await basicMintTx.wait(1)
    console.log(`Basic NFT 0号索引的tokenURI:${await basicNft.tokenURI(0)}`)

    //Random IPFS NFT
    const randomIpfsNft = await ethers.getContract(&quot;RandomIpfsNft&quot;, deployer) //获得合约对象
    const mintFee = await randomIpfsNft.getMintFee() //获得铸币价格
    //监听
    await new Promise(async (resolve, reject) =&gt; {
        setTimeout(resolve, 300000) //设置最长等待时间为5分钟
        randomIpfsNft.once(&quot;NftMinted&quot;, async function () {
            resolve()
        })
        const randomIpfsNftMintTx = await randomIpfsNft.requestNft({ value: mintFee.toString() }) //获得铸币函数交易
        const randomIpfsNftMintTxReceipt = await randomIpfsNftMintTx.wait(1)
        if (developmentChains.includes(network.name)) {
            const requestId = randomIpfsNftMintTxReceipt.events[1].args.requestId.toString()
            const vrfCoordinatorV2Mock = await ethers.getContract(&quot;VRFCoordinatorV2Mock&quot;, deployer) //Chainlink VRF的模拟合约对象
            await vrfCoordinatorV2Mock.fulfillRandomWords(requestId, randomIpfsNft.address) //模拟合约对象调用fulfillRandomWords函数
        }
    })
    console.log(`Random IPFS NFT 0号索引的tokenURI:${await randomIpfsNft.tokenURI(0)}`)

    //Dynamic SVG NFT
    const highValue = ethers.utils.parseEther(&quot;4000&quot;) //先设定铸币价格为4000Wei ETH
    const dynamicSvgNft = await ethers.getContract(&quot;DynamicSvgNft&quot;, deployer) //获得合约对象
    const dynamicSvgNftMintTx = await dynamicSvgNft.mintNft(highValue.toString()) //获得铸币函数交易
    await dynamicSvgNftMintTx.wait(1)
    console.log(`Dynamic SVG NFT 0号索引的tokenURI:${await dynamicSvgNft.tokenURI(0)}`)
}

</code></pre><p>然后在hardhat.config.js中添加如下配置</p>
<pre><code>  etherscan: {
        apiKey: ETHERSCAN_API_KEY,
        customChains: [
            {
                network: &quot;goerli&quot;,
                chainId: 5,
                urls: {
                    apiURL: &quot;http://api-goerli.etherscan.io/api&quot;, //https =&gt; http
                    browserURL: &quot;http://goerli.etherscan.io&quot;,
                },
            },
        ],
    },
</code></pre><p>然后运行下面这个命令在测试网上部署NFT合约脚本</p>
<pre><code>yarn hardhat deploy --network goerli --tags main
</code></pre><p>部署成功!</p>
<p><img src="img/image-20221202084132807.png" alt="image-20221202084132807"></p>
<p>然后将RandomIpfsNft的合约地址添加为Chainlink VRF中的consumer.</p>
<p>再次运行命令在测试网上部署NFT铸币脚本</p>
<pre><code>yarn hardhat deploy --network goerli --tags mint
</code></pre><p>铸造成功!</p>
<p><img src="img/image-20221202090959805.png" alt="image-20221202090959805"></p>
<p><img src="img/image-20221202091953526.png" alt="image-20221202091953526"></p>
<p>复制铸币合约的地址到opensea的测试网中</p>
<p><img src="img/image-20221202092316982.png" alt="image-20221202092316982"></p>
<h3 id="-14-">第14课总结</h3>
<p>首先我们通过BasicNft.sol学习nft的基础知识,我们了解到这些NFTs是基于tokenURI的，tokenURI中有name,description,image的url,还会有属性attributes,整个tokenURI中的内容被称为NFT的元数据。同时我们可以在链上拥有metadata,在链上定制它。</p>
<p>然后我们了解到了更多关于IPFS的细节,我们还写了一个脚本uploadToPinata.js,我们还写了很多部署脚本和测试脚本，不仅如此，我们还学到了如何使用函数选择器和函数签名来调用任何函数，我们了解到了更多关于abi编码的细节(encode和encodePacked)</p>
<h2 id="15-nextjs-nft-">15.使用NextJS开发NFT交易所前端</h2>
<p>这是一个巨大的课程,如果你完成它,你就能获得端到端制作Web3应用程序的技能。</p>
<p><strong>智能合约-&gt;网站</strong></p>
<p><strong>我们会了解到events的重要性，尤其是对于链下服务来说。</strong></p>
<p>在过去人们扩展项目的时候都是采取更为中心化的方法,这种方法更加简单快捷。</p>
<p>我们可以为我们的网站添加更多的功能，并且仍然有很多协议具有去中心化的后端和中心化的前端。</p>
<p>一个很好的例子就是OpenSea,OpenSea有能力真正展示不同的nft，OpenSea的NFT存储在某个数据库中。</p>
<p>在之前我们已经学到了很多关于如何使NFT成为他们的样子,我们要建立自己的完全去中心化的NFT市场。</p>
<p><strong>这个NFT市场项目将基于Artion项目,这是一个完全开源的去中心化智能合约NFT市场</strong></p>
<h3 id="nft-">NFT交易市场合约</h3>
<h4 id="hardhat-">Hardhat配置</h4>
<p>配置format所需要的文件和solhint所需要的文件,hardhat.config.js,utils文件夹,.env以及各项依赖</p>
<pre><code>1.创建一个去中心化的NFT市场
  -`listItem函数(列表项)`:在市场上列出NFT
  -`buyItem函数`:购买NFT
  -`cancleItem函数`:取消出售列表
  -`updateListing`:更新价格
  -`withdrawProceeds`:提取我出售的NFT的钱款
</code></pre><h4 id="nftmarketplace-sol">NftMarketplace.sol</h4>
<pre><code>//SPDX-License-Identifier:MIT
pragma solidity ^0.8.7;

import &quot;@openzeppelin/contracts/token/ERC721/IERC721.sol&quot;;

error NftMarketplace__PriceMustBeAboveZero();
error NftMarketplace__NotApprovedForMarketplace();
error NftMarketplace__AlreadyListed(address nftAddress, uint256 tokenId);
error NftMarketplace__NotOwner();
error NftMarketplace__NotListed(address nftAddress, uint256 tokenId);
error NftMarketplace__PriceNotMet(address nftAddress, uint256 tokenId, uint256 price);

//  -`listItem函数(列表项)`:在市场上列出NFT
//  -`buyItem函数`:购买NFT
//  -`cancleItem函数`:取消出售列表
//  -`updateListing`:更新价格
//  -`withdrawProceeds`:提取我出售的NFT的钱款
contract NftMarketplace {
    struct Listing {
        uint256 price; //NFT代币价格
        address seller; //NFT卖家地址
        address tokenPayment; //Chainlink喂价:将原生代币的价格转换为他们实际花了多少钱
    }
    //映射
    //NFT Contract address -&gt; NFT TokenId -&gt; Listing
    mapping(address =&gt; mapping(uint256 =&gt; Listing)) private s_listings;
    //用户地址 -&gt; 出售NFT所赚的钱
    mapping(address =&gt; uint256) private s_proceeds;

    //事件
    event ItemListed(
        //列表清单
        address indexed seller,
        address indexed nftAddress,
        uint256 indexed tokenId,
        uint256 price
    );

    event ItemBought(
        //购买清单
        address indexed buyer,
        address indexed nftAddress,
        uint256 indexed tokenId,
        uint256 price
    );

    ///////////////
    // Modifiers //
    ///////////////
    //我们需要确保我们只列出那些还未被列出的NFT,我们可以写一个modifier来实现这一切
    modifier notListed(
        address nftAddress,
        uint256 tokenId,
        address owner
    ) {
        Listing memory listing = s_listings[nftAddress][tokenId]; //获取NFT列表
        if (listing.price &gt; 0) {
            revert NftMarketplace__AlreadyListed(nftAddress, tokenId); //恢复列表数组错误,传入NFT地址和tokenId
        }
        _; //没有被列出的NFT的价格一定等于0
    }

    //还需要确保只有NFT的主人可以在市场上列出NFT
    modifier isOwner(
        address nftAddress,
        uint256 tokenId,
        address spender
    ) {
        IERC721 nft = IERC721(nftAddress); //获得IERC721合约对象
        address owner = nft.ownerOf(tokenId); //获得NFT持有者的地址
        //如果发布者不是NFT的主人
        if (spender != owner) {
            revert NftMarketplace__NotOwner();
        }
        _;
    }

    //我们需要确保购买列表实际上已经被列出
    modifier isListed(address nftAddress, uint256 tokenId) {
        Listing memory listing = s_listings[nftAddress][tokenId]; //获取NFT列表
        if (listing.price &lt;= 0) {
            revert NftMarketplace__NotListed(nftAddress, tokenId); //恢复错误,传入NFT地址和tokenId
        }
        _;
    }

    ////////////////////
    // Main Functions //
    ////////////////////

    /*
     * @notice 在市场上列出NFT的方法
     * @param nftAddress: NFT的地址
     * @param tokenId: NFT的TokenId
     * @param price:上市NFT的销售价格
     * @dev 从技术上讲,我们可以将合约作为NFT的托管,但这样人们在上市时仍然可以持有NFT
     */
    //在市场上列出NFT
    //需要传入NFT的合约地址,tokenId,代币价格price作为参数
    function listItem(
        address nftAddress,
        uint256 tokenId,
        uint256 price
    )
        external
        //Challenge:让这个合约也接受代币子集的付款
        //Hint:使用Chainlink喂价在彼此之间转换代币的价格
        notListed(nftAddress, tokenId, msg.sender)
        isOwner(nftAddress, tokenId, msg.sender)
    {
        if (price &lt;= 0) {
            revert NftMarketplace__PriceMustBeAboveZero();
        }
        //列出NFT有以下两种方法
        //1.Send the NFT to the contract(让合约市场持有NFT)
        //2.所有者仍然可以持有他们的NFT，并向市场批准为他们出售NFT。
        //我们会使用第二种方式,我们需要确保市场获得批准与NFT合作,我们可以传入tokenId作为参数来调用getApproved函数
        //为了调用此函数我们需要继承IERC721合约.
        IERC721 nft = IERC721(nftAddress); //获得IERC721合约对象
        //是否获得批准
        if (nft.getApproved(tokenId) != address(this)) {
            revert NftMarketplace__NotApprovedForMarketplace();
        }
        //我们需要映射来列出这些项目
        s_listings[nftAddress][tokenId] = Listing(price, msg.sender);
        //发出事件,要注意在这个项目当中事件很重要
        emit ItemListed(msg.sender, nftAddress, tokenId, price);
    }

    //购买NFT的函数
    //需要传入NFT的合约地址和tokenId
    //本合约以外的人员调用buyItem函数时用户可以支付ETH或任何Layer1的原生代币
    function buyItem(
        address nftAddress,
        uint256 tokenId
    ) external payable isListed(nftAddress, tokenId) {
        Listing memory listedItem = s_listings[nftAddress][tokenId]; //获取NFT列表
        //如果其他人付款的钱小于标注的价格
        if (msg.value &lt; listedItem.price) {
            revert NftMarketplace__PriceNotMet(nftAddress, tokenId, listedItem.price);
        }
        //我们为了转移风险,并不会直接把钱发给卖家,而是让他们自己去取
        //我们需要映射我们跟踪人们出售其NFT所赚的钱
        s_proceeds[listedItem.seller] = s_proceeds[listedItem.seller] + msg.value; //将售出的钱加到卖家余额里
        delete (s_listings[nftAddress][tokenId]); //在映射列表中删除掉已经售出的NFT
        //将NFT从卖家地址里转移到买家地址里
        IERC721(nftAddress).safeTransferFrom(listedItem.seller, msg.sender, tokenId);
        //检查以确保NFT已转移
        emit ItemBought(msg.sender, nftAddress, tokenId, listedItem.price);
    }
}

</code></pre><h4 id="-">重入攻击</h4>
<p>我们平时最常见的两种攻击方式就是重入攻击和预言机攻击(这个攻击通常发生在协议不使用去中心化预言机时)</p>
<p><img src="img/image-20221203083306482.png" alt="image-20221203083306482"></p>
<p>safeTransferFrom函数可以防止重入攻击。(使用的是互斥锁的方法)</p>
<p>重入攻击示例:</p>
<p><strong>ReentrantVulnerable.sol</strong></p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

// Based on https://solidity-by-example.org/hacks/re-entrancy

/*
ReentrantVulnerable 是一个可以存入和提取 ETH 的合约。
该合约容易受到重入攻击。
让我们看看为什么。
1.部署ReentrantVulnerable
2. 从账户 1（Alice）和账户 2（Bob）各存入 1 个以太币到 ReentrantVulnerable
3.部署地址为ReentrantVulnerable的Attack
4. 调用 Attack.attack 发送 1 个以太币（使用账户 3 (Eve)）。
    您将取回 3 个以太币（从Alice和Bob那里偷来的 2 个以太币，
    加上从该合约发送的 1 个以太币）。
发生了什么？
攻击之前能够多次调用 ReentrantVulnerable.withdraw
ReentrantVulnerable.withdraw 执行完毕。
这是调用函数的方式
- Attack.attack
- ReentrantVulnerable.deposit
- ReentrantVulnerable.withdraw
- fallback攻击（接收 1 个以太币）
- ReentrantVulnerable.withdraw
- fallback攻击（接收 1 个以太币）
- ReentrantVulnerable.withdraw
- fallack攻击（接收 1 个以太币）
*/

contract ReentrantVulnerable {
    mapping(address =&gt; uint256) public balances;//当前合约调用者的地址-&gt;账户余额

    //存款函数
    function deposit() public payable {
        balances[msg.sender] += msg.value;//往协议中存钱
    }

    //取款函数
    //有一种方法可以攻击这个函数,取出这个函数中的所有钱
    //有两种方法可以防止这种攻击
    //1.简单方法:在合约调用者取钱之前先将调用者账户余额在数值上清零:
    //2.复杂方法:使用互斥锁(mutex lock),这是openzeppelin的修饰符之一(使用这种方法,我们的Withdraw函数只能够被调用一次)
    bool locked;

    function withdraw() public payable {
        require(!locked,&quot;revert&quot;); //locked为假则恢复错误
        locked = true;
        uint256 bal = balances[msg.sender];//首先获取调用者账户余额
        require(bal &gt; 0);//确保余额大于0


        (bool sent, ) = msg.sender.call{value: bal}(&quot;&quot;);//合约调用者取钱
        require(sent, &quot;Failed to send Ether&quot;);

        balances[msg.sender] = 0;//将调用者账户余额在数值上清零
        locked = false;
    }

    // 用于检查此合约余额的Helper函数
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}

//发动攻击的合约
contract Attack {
    ReentrantVulnerable public reentrantVulnerable;//创建重入合约对象

    constructor(address _reentrantVulnerableAddress) {
        reentrantVulnerable = ReentrantVulnerable(_reentrantVulnerableAddress);//传入特定地址构建重入合约对象
    }

    // 当EtherStore将Ether发送到此合约时，将调用fallback函数。
    //恶意取款(相当于是重入合约给attack合约转账,只要是合约之间转账就默认隐性调用fallback函数)
    fallback() external payable {
        //如果重入合约中的余额大于等于1以太坊,就调用重入合约的取款函数
        if (address(reentrantVulnerable).balance &gt;= 1 ether) {
            reentrantVulnerable.withdraw();
        }
    }

    //因为当我们取款的时候,(bool sent, ) = msg.sender.call{value: bal}(&quot;&quot;);实际上在调用Attack合约
    function attack() external payable {
        require(msg.value &gt;= 1 ether);//查询合约地址中余额是否大于一个以太坊
        reentrantVulnerable.deposit{value: 1 ether}();//向合约中存入一个以太坊
        reentrantVulnerable.withdraw();
    }

    // 用于检查此合约余额的Helper函数
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}
</code></pre><p>如果不使用safeTransferFrom函数的话我们可以导入互斥锁modifier来防止重入攻击</p>
<pre><code>import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;; //互斥锁modifier来自这个合约


contract NftMarketplace is ReentrancyGuard{

     function buyItem(
        address nftAddress,
        uint256 tokenId
    ) external payable nonReentrant isListed(nftAddress, tokenId) {

    }

}
</code></pre><h4 id="nftmarketplace-sol-">NftMarketplace.sol继续</h4>
<pre><code>//SPDX-License-Identifier:MIT
pragma solidity ^0.8.7;

import &quot;@openzeppelin/contracts/token/ERC721/IERC721.sol&quot;;

error NftMarketplace__PriceMustBeAboveZero();
error NftMarketplace__NotApprovedForMarketplace();
error NftMarketplace__AlreadyListed(address nftAddress, uint256 tokenId);
error NftMarketplace__NotOwner();
error NftMarketplace__NotListed(address nftAddress, uint256 tokenId);
error NftMarketplace__PriceNotMet(address nftAddress, uint256 tokenId, uint256 price);
error NftMarketplace__NoProceeds();
error NftMarketplace__TransferFailed();

//  -`listItem函数(列表项)`:在市场上列出NFT ✔️
//  -`buyItem函数`:购买NFT  ✔️
//  -`cancleItem函数`:取消出售列表 ✔️
//  -`updateListing`:更新价格 ✔️
//  -`withdrawProceeds`:提取我出售的NFT的钱款 ✔️
contract NftMarketplace {
    struct Listing {
        uint256 price; //NFT代币价格
        address seller; //NFT卖家地址
        // address tokenPayment; //Chainlink喂价:将原生代币的价格转换为他们实际花了多少钱
    }
    //映射
    //NFT Contract address -&gt; NFT TokenId -&gt; Listing
    mapping(address =&gt; mapping(uint256 =&gt; Listing)) private s_listings;
    //用户地址 -&gt; 出售NFT所赚的钱
    mapping(address =&gt; uint256) private s_proceeds;

    //事件
    event ItemListed(
        //列表清单
        address indexed seller,
        address indexed nftAddress,
        uint256 indexed tokenId,
        uint256 price
    );

    event ItemBought(
        //购买清单
        address indexed buyer,
        address indexed nftAddress,
        uint256 indexed tokenId,
        uint256 price
    );

    event ItemCanceled(
        address indexed seller,
        address indexed nftAddress,
        uint256 indexed tokenId
    );

    ///////////////
    // Modifiers //
    ///////////////
    //我们需要确保我们只列出那些还未被列出的NFT,我们可以写一个modifier来实现这一切
    modifier notListed(
        address nftAddress,
        uint256 tokenId,
        address owner
    ) {
        Listing memory listing = s_listings[nftAddress][tokenId]; //获取NFT列表
        if (listing.price &gt; 0) {
            revert NftMarketplace__AlreadyListed(nftAddress, tokenId); //恢复列表数组错误,传入NFT地址和tokenId
        }
        _; //没有被列出的NFT的价格一定等于0
    }

    //还需要确保只有NFT的主人可以在市场上列出NFT
    modifier isOwner(
        address nftAddress,
        uint256 tokenId,
        address spender
    ) {
        IERC721 nft = IERC721(nftAddress); //获得IERC721合约对象
        address owner = nft.ownerOf(tokenId); //获得NFT持有者的地址
        //如果发布者不是NFT的主人
        if (spender != owner) {
            revert NftMarketplace__NotOwner();
        }
        _;
    }

    //我们需要确保购买列表实际上已经被列出
    modifier isListed(address nftAddress, uint256 tokenId) {
        Listing memory listing = s_listings[nftAddress][tokenId]; //获取NFT列表
        if (listing.price &lt;= 0) {
            revert NftMarketplace__NotListed(nftAddress, tokenId); //恢复错误,传入NFT地址和tokenId
        }
        _;
    }

    ////////////////////
    // Main Functions //
    ////////////////////

    /*
     * @notice 在市场上列出NFT的方法
     * @param nftAddress: NFT的地址
     * @param tokenId: NFT的TokenId
     * @param price:上市NFT的销售价格
     * @dev 从技术上讲,我们可以将合约作为NFT的托管,但这样人们在上市时仍然可以持有NFT
     */
    //在市场上列出NFT
    //需要传入NFT的合约地址,tokenId,代币价格price作为参数
    function listItem(
        address nftAddress,
        uint256 tokenId,
        uint256 price
    )
        external
        //Challenge:让这个合约也接受代币子集的付款
        //Hint:使用Chainlink喂价在彼此之间转换代币的价格
        notListed(nftAddress, tokenId, msg.sender)
        isOwner(nftAddress, tokenId, msg.sender)
    {
        if (price &lt;= 0) {
            revert NftMarketplace__PriceMustBeAboveZero();
        }
        //列出NFT有以下两种方法
        //1.Send the NFT to the contract(让合约市场持有NFT)
        //2.所有者仍然可以持有他们的NFT，并向市场批准为他们出售NFT。
        //我们会使用第二种方式,我们需要确保市场获得批准与NFT合作,我们可以传入tokenId作为参数来调用getApproved函数
        //为了调用此函数我们需要继承IERC721合约.
        IERC721 nft = IERC721(nftAddress); //获得IERC721合约对象
        //是否获得批准
        if (nft.getApproved(tokenId) != address(this)) {
            revert NftMarketplace__NotApprovedForMarketplace();
        }
        //我们需要映射来列出这些项目
        s_listings[nftAddress][tokenId] = Listing(price, msg.sender);
        //发出事件,要注意在这个项目当中事件很重要
        emit ItemListed(msg.sender, nftAddress, tokenId, price);
    }

    //购买NFT的函数
    //需要传入NFT的合约地址和tokenId
    //本合约以外的人员调用buyItem函数时用户可以支付ETH或任何Layer1的原生代币
    function buyItem(
        address nftAddress,
        uint256 tokenId
    ) external payable isListed(nftAddress, tokenId) {
        Listing memory listedItem = s_listings[nftAddress][tokenId]; //获取NFT列表
        //如果其他人付款的钱小于标注的价格
        if (msg.value &lt; listedItem.price) {
            revert NftMarketplace__PriceNotMet(nftAddress, tokenId, listedItem.price);
        }
        //我们为了转移风险,并不会直接把钱发给卖家,而是让他们自己去取
        //我们需要映射我们跟踪人们出售其NFT所赚的钱
        s_proceeds[listedItem.seller] = s_proceeds[listedItem.seller] + msg.value; //将售出的钱加到卖家余额里
        delete (s_listings[nftAddress][tokenId]); //在映射列表中删除掉已经售出的NFT
        //将NFT从卖家地址里转移到买家地址里
        IERC721(nftAddress).safeTransferFrom(listedItem.seller, msg.sender, tokenId);
        //检查以确保NFT已转移
        emit ItemBought(msg.sender, nftAddress, tokenId, listedItem.price);
    }

    //取消购买列表函数(确保NFT的主人可以取消出售,确保购买列表已经被列出)
    function cancelListing(
        address nftAddress,
        uint256 tokenId
    ) external isOwner(nftAddress, tokenId, msg.sender) isListed(nftAddress, tokenId) {
        delete (s_listings[nftAddress][tokenId]); //删除购买列表的映射
        emit ItemCanceled(msg.sender, nftAddress, tokenId); //发送事件--删除的列表是哪一个
    }

    //更新购买列表函数(确保NFT的主人可以更新购买,确保购买列表已经被列出)---只能更新价格
    function updateListing(
        address nftAddress,
        uint256 tokenId,
        uint256 newPrice
    ) external isListed(nftAddress, tokenId) isOwner(nftAddress, tokenId, msg.sender) {
        s_listings[nftAddress][tokenId].price = newPrice; //更新价格
        emit ItemListed(msg.sender, nftAddress, tokenId, newPrice); //发出更新后的列表清单
    }

    //卖家提取自己出售NFT所得到的钱
    function withdrawProceeds() external {
        uint256 proceeds = s_proceeds[msg.sender]; //通过映射获得用户的收益
        //如果收益小于等于0要返回错误
        if (proceeds &lt;= 0) {
            revert NftMarketplace__NoProceeds();
        }
        s_proceeds[msg.sender] = 0; //先将用户的收益在数值上清零
        (bool success, ) = payable(msg.sender).call{value: proceeds}(&quot;&quot;); //把钱转给卖家
        if (!success) {
            revert NftMarketplace__TransferFailed();
        }
    }

    //////////////////////
    // Getter Functions //
    //////////////////////

    // view/pure 函数

    //返回出售列表
    function getListing(
        address nftAddress,
        uint256 tokenId
    ) external view returns (Listing memory) {
        return s_listings[nftAddress][tokenId];
    }

    //返回卖家的收益
    function getProceeds(address seller) external view returns (uint256) {
        return s_proceeds[seller];
    }
}

</code></pre><h4 id="nftmarketplace-sol-">NftMarketplace.sol部署脚本</h4>
<p>创建01-deploy-nft-marketplace.js文件</p>
<pre><code>const { network } = require(&quot;hardhat&quot;)
const { developmentChains } = require(&quot;../helper-hardhat-config&quot;)
const { verify } = require(&quot;../utils/verify&quot;)

module.exports = async ({ getNamedAccounts, deployments }) =&gt; {
    const { deploy, log } = deployments
    const { deployer } = await getNamedAccounts()

    //我们的NFT市场合约中没有构造函数,所以参数是空白的
    args = []

    //部署NFT市场合约
    const nftMarketplace = await deploy(&quot;NftMarketplace&quot;, {
        from: deployer,
        args: args,
        log: true,
        waitConfirmations: network.config.blockConfirmations || 1,
    })

    //在浏览器上验证合约
    if (!developmentChains.includes(network.name) &amp;&amp; process.env.ETHERSCAN_API_KEY) {
        log(&quot;Verifying...&quot;)
        await verify(nftMarketplace.address, args)
    }

    log(&quot;--------------------------------&quot;)
}

module.exports.tags = [&quot;all&quot;, &quot;nftmarketplace&quot;]
</code></pre><p>因为这是一个NFT市场,我们需要一些铸造NFT的合约,并部署它们</p>
<p><strong>重复是一切技巧之母</strong></p>
<pre><code>const { network } = require(&quot;hardhat&quot;)
const { developmentChains } = require(&quot;../helper-hardhat-config&quot;)
const { verify } = require(&quot;../utils/verify&quot;)

module.exports = async ({ getNamedAccounts, deployments }) =&gt; {
    const { deploy, log } = deployments
    const { deployer } = await getNamedAccounts()

    const args = []

    //部署basicNft合约
    const basicNft = await deploy(&quot;BasicNft&quot;, {
        from: deployer,
        args: args,
        log: true,
        waitConfirmations: network.config.blockConfirmations || 1,
    })

    //在浏览器上验证合约
    if (!developmentChains.includes(network.name) &amp;&amp; process.env.ETHERSCAN_API_KEY) {
        log(&quot;Verifying...&quot;)
        await verify(basicNft.address, args)
    }

    log(&quot;--------------------------------&quot;)
}

module.exports.tags = [&quot;all&quot;, &quot;basicNft&quot;]
</code></pre><h4 id="nftmarketplace-sol-">NftMarketplace.sol测试脚本</h4>
<p>测试脚步初步编写</p>
<pre><code>const { assert, expect } = require(&quot;chai&quot;)
const { network, deployments, ethers, getNamedAccounts } = require(&quot;hardhat&quot;)
const { developmentChains } = require(&quot;../../helper-hardhat-config&quot;)

!developmentChains.includes(network.name)
    ? describe.skip
    : describe(&quot;Nft Marketplace Tests&quot;, function () {
          let nftMarketplace, basicNft, deployer, player
          const PRICE = ethers.utils.parseEther(&quot;0.1&quot;)
          const TOKEN_ID = 0
          beforeEach(async function () {
              deployer = (await getNamedAccounts()).deployer //合约部署者(相当于NFT市场的卖家)
              //player = (await getNamedAccounts()).player
              const accounts = await ethers.getSigners()
              player = accounts[1] //玩家(相当于NFT市场的买家)
              await deployments.fixture([&quot;all&quot;]) //我们将遍历运行deploy文件夹下的所有部署脚本
              nftMarketplace = await ethers.getContract(&quot;NftMarketplace&quot;) //创建NFT市场合约对象
              //如果我们想调用NFT市场合约上的函数,同时让player是调用函数的人(这个代码只是让我们知道如何自由切换不同的账户和用户来部署合约)
              //nftMarketplace = await nftMarketplace.connect(player)
              basicNft = await ethers.getContract(&quot;BasicNft&quot;) //创建BasicNft合约对象
              await basicNft.mintNft() //铸造NFT代币
              await basicNft.approve(nftMarketplace.address, TOKEN_ID) //批准市场与NFT交互
          })
          it(&quot;购买清单列出并且可以进行购买&quot;, async function () {
              await nftMarketplace.listItem(basicNft.address, TOKEN_ID, PRICE) //调用listItem函数在市场上列出NFT
              const playerConnectedNftMarketplace = nftMarketplace.connect(player) //将玩家接入NFT市场合约
              await playerConnectedNftMarketplace.buyItem(basicNft.address, TOKEN_ID, {
                  value: PRICE,
              }) //调用buyItem函数购买NFT
              //检查player是否真的买到了NFT
              const newOwner = await basicNft.ownerOf(TOKEN_ID)
              //检查部署者是否真的会获得报酬
              const deployerProceeds = await nftMarketplace.getProceeds(deployer)
              assert(newOwner.toString() == player.address)
              assert(deployerProceeds.toString() == PRICE.toString())
          })
      })

</code></pre><h4 id="-">写测试</h4>
<p>我们创建scripts文件夹,写一些脚本来铸造NFT和购买NFT。</p>
<p><strong>mint-and-list.js</strong></p>
<pre><code>const { ethers } = require(&quot;hardhat&quot;)

const PRICE = ethers.utils.parseEther(&quot;0.1&quot;)

//这个脚本将铸造NFT并再NFT市场上上市
async function mintAndList() {
    const nftMarketplace = await ethers.getContract(&quot;NftMarketplace&quot;) //创建NFT市场对象
    const basicNft = await ethers.getContract(&quot;BasicNft&quot;) //创建basicNft合约对象
    console.log(&quot;Minting...&quot;)
    const mintTx = await basicNft.mintNft() //发送铸币交易
    const mintTxReceipt = await mintTx.wait(1)
    const tokenId = mintTxReceipt.events[0].args.tokenId //由于铸币交易后会发送事件,可以通过事件索引的参数得到tokenId
    console.log(&quot;Approving Nft...&quot;)
    const approvalTx = await basicNft.approve(nftMarketplace.address, tokenId) //批准NFT市场与NFT进行交互
    await approvalTx.wait(1)
    console.log(&quot;Listing NFT...&quot;)
    const tx = await nftMarketplace.listItem(basicNft.address, tokenId, PRICE) //调用函数在市场上列出NFT
    await tx.wait(1)
    console.log(&quot;Listed!&quot;)
}

mintAndList()
    .then(() =&gt; process.exit(0))
    .catch((error) =&gt; {
        console.error(error)
        process.exit(1)
    })

</code></pre><h3 id="moralis-">Moralis前端</h3>
<p>在这之前我们已经完成了所有链端的工作,现在我们要构建用户可以与之交互的前端。</p>
<h4 id="nextjs-">NextJS配置</h4>
<p>首先运行该命令</p>
<pre><code>yarn create next-app .
</code></pre><p>运行后添加format文件。</p>
<p>现在我们有了一个简约的React项目。</p>
<p>运行命令yarn dev来进入我们的前端页面。</p>
<p>在我们的index.js中我们要做的第一件事就是添加连接按钮,我们需要我们的用户连接到Web3钱包,从而连接到区块链。这个连接按钮是我们每一个前端项目必备的组件。</p>
<p>运行该命令添加web3uikit样式库和React中的Moralis钩子包</p>
<pre><code>yarn add web3uikit moralis react-moralis
</code></pre><p>我们不会在我们的项目中使用Moralis服务器,但是会使用Moralis图表</p>
<p>然后初步编写Header.js和_app.js</p>
<p><img src="img/image-20221204172652364.png" alt="image-20221204172652364"></p>
<h4 id="-tailwind">添加Tailwind</h4>
<p>Tailwind是一个我们很常用的样式库</p>
<p>运行下面的命令添加Tailwind包</p>
<pre><code>yarn add --dev tailwindcss postcss autoprefixer
</code></pre><p>运行下面的命令为Tailwind制作配置文件</p>
<pre><code>yarn tailwindcss init -p
</code></pre><p>照着官网文档的初始配置一步步来就可以了。</p>
<p>然后调整header.js中各条属性的样式</p>
<h4 id="web3-">Web3索引说明</h4>
<p>Graph(图表)是一个关于索引的协议，这是一种将事件索引到链外并将其粘贴到Graph中的协议,这种协议以去中心化的方式进行。</p>
<p>Etherscan和OpenSea都是中心化协议</p>
<h4 id="-moralis">什么是Moralis</h4>
<p>我们一直在使用Moralis的开源包和工具,然后Moralis也有一个服务器供我们选择,这个服务器可以给我们的Web3服务器提供更多的功能。</p>
<p>我们要知道当我们构建应用程序时要需要确保应用程序是可扩展的,因为我们的Dapp可能会走向全球,如果不能扩展的话,面对新功能我们可能要重新开始构建程序。</p>
<p>Marolis可以提供让让我们走得快又能做大的工具和服务。</p>
<p>Moralis 提供用于构建高性能 dapp 的单一工作流程，和我们最喜欢的 web3 工具和服务器完全兼容。</p>
<p>这样可以节省我们的时间,如果我们有一个单一的工作流程来做事，并且Web3中的工作流实际上意味着你必须有一个智能合约(无论是代币,NFT游戏还是Defi,它都将在链上)。</p>
<p>我们必须把Moralis连接到我们的后端，因为当链上发生某些变化时，我们需要监控它，所以我们可以创建Web钩子，我们可以创建电子邮件，我们可以创建推送通知等等，我们还可以运行一些自定义代码，可以运行一些计算，可以将某些内容保存到数据库中，一切都在链上，当Moralis进入到我们的后端时，如果我们的后端发生变化，它需要到前端去进行改变(例如当链上发生某些变化时，我们会更改UI或者当我们的用户收到高于特定阈值的转换要求时我们更改UI)</p>
<p>总的来说Moralis为我们提供全套工具，他是Web3世界里最受欢迎的技术栈，这一切都源于Moralis的身份机制，它可以确保我们写一段代码，可以跨越不同的区块链/钱包来登录我们的账户，并且在Moralis的仪表板上我们将获得用户个人资料，网络会话等。因此Moralis可以让我们管理自己的身份，因为一个用户的身份可以有许多不同的钱包(连接到不同的区块链上)，所有交易将从对该用户同步进行。</p>
<p><strong>Moralis的工作流程</strong></p>
<ul>
<li><p><strong>Moralis Identity</strong></p>
<p>&quot;<strong>使用一行代码跨链跨钱包登录用户。Moralis 帮助您管理跨链身份和用户会话</strong>&quot;</p>
<p>通过Moralis我们确保可以拥有安全的，经过身份验证的Web会话，并且Moralis会为我们提供会话管理，所以我们的后端一旦拥有Moralis，会话身份管理，无效化会话，登录用户等所有的操作都可以用一行代码去完成。</p>
</li>
<li><p><strong>Moralis Real-Time</strong></p>
<p>&quot;<strong>在用户执行交易或智能合约发出事件时获取实时网络钩子和警报</strong>&quot;</p>
<p>Moralis的更新是实时的，这意味着当我们拥有一个用户的时候，我们能够知道实时发生的变化。</p>
</li>
<li><p><strong>Moralis SDKs</strong></p>
<p>&quot;<strong>使用 Moralis SDKs，您可以轻松地将您的网站、游戏或移动应用程序连接到所有 Moralis 功能。</strong>&quot;</p>
<p>因此，无论您是在构建网站，还是在构建游戏，我们都与游戏引擎完全集成，哪怕您是在为其他平台构建，我们都有易于使用的广泛 sdk，可让你在其中完成所有工作，可以让你与Moralis连接起来，并且非常非常容易地做到这一点。(Moralis是跨链的，这意味着当我们登录用户时，我们可以在在区块链地址中中创建用户配置文件，然后我们就可以很轻松地连接到相应的区块链，所以一个用户的个人资料可以让我们获得不同的钱包，不同的链)，并且我们也可以使用Nodejs sdk把Moralis连接到我们的后端。</p>
</li>
<li><p><strong>Moralis APIs</strong></p>
<p>&quot;<strong>Moralis APIs可用于查询与NFT、代币、账户、交易等相关的任何数据。</strong>&quot;</p>
<p>API 是您可以从任何类型的体系结构的任何编程语言发出的原生请求。</p>
</li>
</ul>
<p>总结下来,使用这个工作流程,我们可以轻松且快速地实现任何我们想要的功能。</p>
<h4 id="-moralis-hardhat-">将Moralis连接到本地Hardhat节点</h4>
<p>Moralis已经更新到了V2版本，没办法再托管服务器了，只能我们自己搭建一个了，所以说这部分视频暂时搁置吧，Patrick说他会更新这一切。</p>
<p><img src="img/image-20221205151302764.png" alt="image-20221205151302764"></p>
<h3 id="graph-">Graph前端</h3>
<p>Graph是一个去中心化的事件索引器。</p>
<p>使用Graph首先要把我们的智能合约部署到测试网上。</p>
<p><img src="img/image-20221205162844269.png" alt="image-20221205162844269"></p>
<p>一旦完成这些部署，我们就可以开始更新我们的前端代码以使用Graph。</p>
<p>我们首先就要删除Moralis项目里遗留的几个文件夹。</p>
<p>删除cloudFunctions文件夹，因为我们不再使用服务器了，不会有任何云函数在后端运行。</p>
<p>删除frp文件夹，因为我们不会连接我们的本地区块链到Graph，我们在这里只会使用测试网</p>
<h4 id="-graph-">什么是Graph?</h4>
<p>Graph是用于存储事件数据的去中心化层，</p>
<p><strong>Graph是一个索引协议，用于查询以太坊和IPFS等网络。任何人都可以建立和发布开放的API，称为Subgraph，使数据易于访问。</strong></p>
<p>所以所有这些区块链和所有这些不同的存储网络以及 TheGraph 是一个由不同节点组成的网络，这些节点从区块链读取并索引这些数据并且 TheGraph 公开了一个 API 供我们调用我们可以读取的数据。</p>
<p><img src="img/image-20221205171005004.png" alt="image-20221205171005004"></p>
<p>综上所述我们可以知道Graph是用于查询以太坊和 IPFS 等区块链网络(还有数十个其他的EVM兼容网络)的索引协议。</p>
<p>使用Graph，开发人员可以构建和发布开放apis(被称为Subgraph)，然后开发人员可以在他们的应用程序中使用，以实现对存储在这些网络上的数据的更好的查询功能。(包括过滤功能，排序关系数据功能和搜索功能)</p>
<p>SubGraph位于区块链和用户界面之间，提供重要的软件基础架构、灵活的性能和去中心化的 api 层。</p>
<p>在传统的 textac 数据库服务器和 api 查询过滤器中排序分页组并在数据返回到应用程序之前加入数据，通常通过某种类型的 http 请求。当直接从以太坊或其他区块链读取数据时，这些类型的数据转换是不可能的。</p>
<p><strong>如何构建一个Subgraph?</strong></p>
<ol>
<li><p>前往The Graph的官网创建一个新的Subgraph</p>
</li>
<li><p>使用 Graph CLI 初始化一个新的 Graph 项目</p>
<pre><code>graph init --contract-name Token
</code></pre></li>
<li><p>在本地定义数据模型、网络、合约地址等其他特定的配置</p>
<p>对于我们的数据模型，我们使用Graphql模式定义语言，设置类型级别和这些类型中的字段</p>
</li>
<li><p>部署我们的Subgraph</p>
<pre><code>graph deploy --studio &lt;subgraph-name&gt;
</code></pre><p>当我们准备好部署我们的子图时，我们可以开始使用内部应用程序对其进行测试，我们可以使用运行部署命令的 graphcli</p>
</li>
<li><p>在Graph官网测试这一切</p>
<p>一旦Subgraph被部署开始对数据进行索引，我们就可以开始测试了。</p>
<p>我们可以直接在Graph仪表板中使用Graph界面开始对其进行测试</p>
</li>
</ol>
<p><strong>如何查询Subgraph?</strong></p>
<p>当我们准备好开始从我们的应用程序查询我们的Sub时，我们可以使用 api url(这是Graph给我们的)</p>
<h4 id="-subgraph">开发一个Subgraph</h4>
<p>首先创建一个Subgraph</p>
<p><img src="img/image-20221205195404132.png" alt="image-20221205195404132"></p>
<p>然后创建Graph的NFT市场文件</p>
<p><img src="img/image-20221205195742148.png" alt="image-20221205195742148"></p>
<p>在这个文件中我们将构建我们的Subgraph，然后把这个文件推送到Subgraph Studio中.</p>
<p>在Subgraph Studio中有一大堆我们可以遵循的指令，我们可以遵循这些指令继续开发Subgraph。</p>
<p>我们要做的第一件事就是安装Graph命令行界面，运行下面这个命令在新文件中安装包</p>
<pre><code>npm install -g @graphprotocol/graph-cli
</code></pre><p>这个命令行界面可以帮助我们构建Graph并为Graph构建说明以实际开始指示我们的事件</p>
<p>然后运行下面这个命令初始化我们的Graph代码</p>
<pre><code>graph init --studio nft-marketplace
</code></pre><p><img src="img/image-20221205211718450.png" alt="image-20221205211718450"></p>
<p>下面我们讲解我们创建的这些文件都是什么?</p>
<p><img src="img/image-20221205212123241.png" alt="image-20221205212123241"></p>
<p>我们的第一个文件夹是abis，为了让Graph索引和阅读我们的合约，在索引我们的事件的过程中，它需要我们事件的 abi，所以它得到了我们整个市场的abi(来自etherscan)，如果我们没有在合约中验证etherscan，我们可以自己创建这个abis文件夹并且在文件夹里添加NftMarketplace.json。</p>
<p>generated文件夹，这是一个自动生成的文间，它在顶部注释了说不要直接编辑这个文件，我们可以将其视为构建文件夹(或者预构建，因为我们稍后会获得一个构建文件夹)。</p>
<p><img src="img/image-20221205213533490.png" alt="image-20221205213533490"></p>
<p>node_modules文件夹仍然是依赖项存放的文件夹。</p>
<p>src文件夹将是我们定义的地方,我们将告诉Graph如何实际映射以及如何实际使用我们的合约，并且这个文件夹下的文件是type脚本文件。</p>
<p>network.json文件给了我们所有关于网络的信息，例如网络的地址这样的信息。</p>
<p>package.json中内置了一些Graph脚本。</p>
<p>schema.graphql将成为我们的GraphQL提纲，所以这也将是我们告诉图表如何实际处理我们的事件和索引我们的事件(也就是说我们将定义我们合约中的那些事件)。</p>
<p>这个schema文件遵循GraphQL语法，GraphQL将是我们的API查询语言而不是一种关系数据库，这种语言可以用Graph的方式进行查询。</p>
<p>subgraph.yaml将告诉我们的Subgraph如何将所有文件组合在一起。</p>
<p>tsconfig.json是一个特定于type脚本的配置文件。</p>
<p>总的来说，我们更新上述文件中的代码来告诉The Graph 开始为我们的事件建立索引，这样我们就可以在去中心化的上下文中从Graph中读取我们的事件，而不是从中心化数据库中读取。</p>
<p>首先我们就编写我们的schema.graphql文件</p>
<pre><code>type ActiveItem @entity {
  id: ID!
  buyer: Bytes! #Address 0x0000...(如果没有人买的话)
  seller: Bytes! #Address
  nftAddress: Bytes!
  tokenId: BigInt!
  price: BigInt! #price可以为空
}

type ItemBought @entity(immutable: true) {
  id: ID!
  buyer: Bytes! # address
  nftAddress: Bytes! # address
  tokenId: BigInt! # uint256
  price: BigInt! # uint256
}

type ItemCanceled @entity(immutable: true) {
  id: ID!
  seller: Bytes! # address
  nftAddress: Bytes! # address
  tokenId: BigInt! # uint256
}

type ItemListed @entity(immutable: true) {
  id: ID!
  seller: Bytes! # address
  nftAddress: Bytes! # address
  tokenId: BigInt! # uint256
  price: BigInt! # uint256
}
</code></pre><p>然后我们需要去告诉Subgraph如何监听这些事件，这时候我们就要前往src文件夹下的mapping.ts文件了。</p>
<p>先运行下面这个命令抓取我们在schema.graphql中的所有内容然后将抓取到的schema.ts文件放置到generated文件夹下</p>
<pre><code>graph codegen
</code></pre><p>所以说当我们更新schema.graphql代码后我们都要运行<strong>graph codegen</strong>来同步更新schema.ts文件</p>
<p>然后回到我们的mapping.ts文件中,我们会发现该文件从自动生成的NftMarketplace文件中导依赖。</p>
<pre><code>import { BigInt, Address } from &quot;@graphprotocol/graph-ts&quot;//从Graph中导入数据类型
import {
    ItemBought as ItemBoughtEvent,
    ItemCanceled as ItemCanceledEvent,
    ItemListed as ItemListedEvent,
} from &quot;../generated/NftMarketplace/NftMarketplace&quot;
import { ItemListed, ActiveItem, ItemBought, ItemCanceled } from &quot;../generated/schema&quot;//导入原生事件


// 这几个函数的参数都是事件,收到什么事件就执行什么函数
// 所有这些代码都在我们的subgraph.yaml中定义,我们可以该文件里看到不同的事件以及事件处理程序
export function handleItemBought(event: ItemBoughtEvent) : void {
    //每当我们列出NFT出售列表时,我们需要做什么?
    //1.将该事件保存到我们的Graph中
    //2.更新我们的activeItems

    //获取或创建itemlisted对象
    //每一个item需要一个唯一的Id

    //ItemBoughtEvent:只是原生事件
    //ItemBoughtObject:我们保存的地方
    let itemBought = ItemBought.load(getIdFromEventParams(event.params.tokenId,event.params.nftAddress)) //创建ItemBought事件对象
    //每次我们列出一个item,也会在activeItem中列出它
    let activeItem = ActiveItem.load(getIdFromEventParams(event.params.tokenId,event.params.nftAddress))
    if(!itemBought){
        itemBought = new ItemBought(
            getIdFromEventParams(event.params.tokenId,event.params.nftAddress)
        )
    }
    //更新所有的参数
    itemBought.buyer = event.params.buyer
    itemBought.nftAddress = event.params.nftAddress
    itemBought.tokenId = event.params.tokenId
    activeItem!.buyer = event.params.buyer
    //保存对象
    itemBought.save()
    activeItem!.save()
    //当有人购买NFT时,我们会更新一个新的ItemBought对象,我们会更新我们的activeItem成为新卖家
}

export function handleItemListed(event: ItemListedEvent): void {
    let itemListed = ItemListed.load(getIdFromEventParams(event.params.tokenId,event.params.nftAddress))
    let activeItem = ActiveItem.load(getIdFromEventParams(event.params.tokenId,event.params.nftAddress))
    if(!itemListed){
        itemListed = new ItemListed(
            getIdFromEventParams(event.params.tokenId,event.params.nftAddress)
        )
    }
    if(!activeItem){
        activeItem = new ActiveItem(
            getIdFromEventParams(event.params.tokenId,event.params.nftAddress)
        )
    }
    itemListed.seller = event.params.seller
    activeItem.seller = event.params.seller

    itemListed.nftAddress = event.params.nftAddress
    activeItem.nftAddress = event.params.nftAddress

    itemListed.tokenId = event.params.tokenId
    activeItem.tokenId = event.params.tokenId

    itemListed.price = event.params.price
    activeItem.price = event.params.price

    itemListed.save()
    activeItem.save()
}

export function handleItemCanceled(event: ItemCanceledEvent): void {
    let itemCanceled = ItemCanceled.load(getIdFromEventParams(event.params.tokenId,event.params.nftAddress))
    let activeItem = ActiveItem.load(getIdFromEventParams(event.params.tokenId,event.params.nftAddress))
    if(!itemCanceled){
        itemCanceled = new ItemCanceled(
            getIdFromEventParams(event.params.tokenId,event.params.nftAddress)
        )
    }
    if(!activeItem){
        activeItem = new ActiveItem(
            getIdFromEventParams(event.params.tokenId,event.params.nftAddress)
        )
    }

    itemCanceled.seller = event.params.seller
    itemCanceled.nftAddress = event.params.nftAddress
    itemCanceled.tokenId = event.params.tokenId
    activeItem!.buyer = Address.fromString(&quot;0x000000000000000000000000000000000000dEaD&quot;)//死地址 
    //如果我们有死地址作为它的买家,意味着这个item已经被取消了
    //空地址代表item还在市场上,实际的真实地址意味着item实际上是被某人买的

    itemCanceled.save()
    activeItem!.save()
}

//从事件参数中获取Id
function getIdFromEventParams(tokenId: BigInt,nftAddress: Address): string {
    return tokenId.toHexString() + nftAddress.toHexString()
}
</code></pre><p>在我们构建完所有东西之后，我们将运行这个末端部署代码，这是为了验证我们自己的合约然后将我们的代码部署到Graph中、</p>
<p><img src="img/image-20221206105848541.png" alt="image-20221206105848541"></p>
<h4 id="-subgraph">部署我们的Subgraph</h4>
<p>首先运行下面这条命令，这是我们如何部署的关键。</p>
<pre><code>graph auth --studio 12308d6bf23b4811f2ed766be6a505ce
</code></pre><p>这样设置的话,每次我们推送代码的时候,我们的代码都能够被推送到Subgraph配置当中,Subgraph会帮我们自动部署。</p>
<p>然后运行下面这条命令，自动更新我们项目中的配置文件</p>
<pre><code>graph codegen
</code></pre><p>然后运行下面这条命令</p>
<pre><code>graph build
</code></pre><p>这个命令将编译并运行我们所有的Subgraph内容,然后把编译后的代码放到build文件夹中。</p>
<p>这个bulid文件夹是我们实际想要部署和发送到Graph中的内容。</p>
<p>最后运行下面这个命令来部署我们的Subgraph</p>
<pre><code>graph deploy --studio nft-marketplace
</code></pre><p><img src="img/image-20221206134122755.png" alt="image-20221206134122755"></p>
<p>我们可以发现Subgtaph Studio的状态已经变成了DEPLOYED，现在我们有一些节点正在监听我们要在此处发出的事件。Logs页面处我们可以看到。Subgraph通过遍历区块链上所有的不同区块来监听并索引我们的事件。在Playground页面处我们可以运行一些查询来查看来自我们的GraphQL不同的事件和不同的反应。</p>
<p>然后回到我们的NftMarketplace智能合约项目中,运行下面这条命令部署我们的scripts文件</p>
<pre><code>yarn hardhat run scripts/mint-and-list-item.js --network goerli
</code></pre><p>我们要铸造一个NFT并在NftMarketplace中上市,这是两个交易。</p>
<p><img src="img/image-20221206145046065.png" alt="image-20221206145046065"></p>
<p>一旦上市成功，它就会触发一个ItemListed事件</p>
<p>左边的是GraphQL查询，右边的是查询到的结果.</p>
<p><img src="img/image-20221206142934249.png" alt="image-20221206142934249"></p>
<h2 id="16-hardhat-">16.使用Hardhat对合约进行升级</h2>
<p>在链上部署智能合约时,我们都知道部署上去的智能合约是不可变的(Immutable),从技术上讲，智能合约是不可变的，但是智能合约实际上可以一直在改变，当人们转移代币等其他操作时，智能合约必须更新他们的余额，映射以及变量来作出反应。智能合约不可变的原因是逻辑本身永远不会改变，永远挂在区块链上。但是如果我们先要升级我们的智能合约或协议来做更多的事情(或者修改我们遇到的错误和问题)，即使我们无法改变已经部署到地址的特定代码，我们实际上可以做的事情仍有很多。</p>
<p>但是我们可以思考的是,如果我们可以升级智能合约，那么智能合约的特性就不再是不可变(Immutable)的了。在某种程度上的确是这样，所以在解释不同的体系和我们在这里使用的模式，我们确实需要记住:体系和去中心化，这些模式中的每一种所具有的意义，他们都有不同的优点和缺点，这里的一些缺点将影响去中心化，我们需要记住这一点。</p>
<p><strong>我们要讨论三种不同的方式来升级我们的智能合约</strong></p>
<p>升级智能合约有Not Really/Parameterize方法，社交迁移方法(Social YEET/Migration)，然后是您可能听说过的方法，即代理，它有大量子类别，如变形合约、透明可升级代理和通用可升级代理。</p>
<p><strong>第一种:</strong>我们来讨论Not Really/Parameterize方法，这是升级我们的智能合约的最简单的方法，我们无法真正改变智能合约的逻辑，我们也不能添加新的存储或状态变量，所以这并不是真正的升级，这种升级只是参数化所有内容。</p>
<p>所以说这种方法的<strong>优势</strong>是实现起来非常容易，<strong>缺点</strong>是如果我们第一次部署智能合约时没有想到某种逻辑或某种函数的话是没办法解决的，我们不能更新逻辑或真正更新任何东西(Simple but not flexible)。我们需要考虑的另一件事是管理员是谁，谁有权使用这些函数，我们可以您可以添加一份governance合约，成为我们协议的admin合约，这将是一种去中心化的方式。另一个例子是合约注册表(Registry),这实际上是AAVE所使用的早期版本，在我们调用函数之前，我们实际上检查一些更新的合约注册表作为参数,然后我们把这些参数发送到合约，在合约处进行调用，这个真的不允许我们在此处拥有更新的全部函数，同样这种方法也是简单但不灵活的。</p>
<p>有些人可能会认为更新我们的智能合约是在破坏去中心化，并且智能合约这么强大的原因主要就来自于它们是不可变的(Immutable)。所以说有些人不允许我们添加任何定制或任何可升级性。(他们的想法是如果你部署你的合约，那么你需要一点额外的时间确保你做对了一切。)</p>
<p><strong>第二种:</strong>我们来讨论Social YEET/Migration这种方法，这种方法其实就是在我们部署新合约后，立刻斩断和旧合约的联系，然后按照社会惯例告诉其他人你与这份旧合约没有任何联系,AAVE就是这样干的。</p>
<p><img src="img/image-20221206170650073.png" alt="image-20221206170650073"></p>
<p>这种方法的<strong>优点</strong>是：</p>
<p>——最符合区块链价值观</p>
<p>——最容易审核</p>
<p><strong>缺点</strong>是：</p>
<p>——需要在用户的迁移上耗费很大的功夫(有大量的社会公约工作需要去做)</p>
<p>——我们必须有一个全新的合约地址(打个比方说我们的合约是一个ERC20代币，我们必须说服所有交易所上市我们的新合约地址作为实际地址，并且我们的新合约必须把旧合约的所有映射都迁移过来，我们需要用到很多移动存储的步骤，并将我们的状态变量转移到新合约。)</p>
<p><strong>第三种:</strong>我们必须学会一种方法可以用简单的方式更新我们的状态，保留我们的合约地址并允许我们更新任何类型的逻辑在我们的智能合约当中。</p>
<p>这种方法就是Proxies(代理)。</p>
<p>Proxies是最真实的程序升级方式，因为用户可以通过这些代理保持与协议的交互，甚至用户们都发现不了协议的更新(但这同时也是我们容易搞糟的地方)。</p>
<p>Proxies使用了很多低级函数，最主要的函数就是delegatecall(委托调用)，delegatecall是一个低级函数，目标合约中的代码在调用合约的上下文中执行，消息中心和消息值也不变。</p>
<p><img src="img/image-20221206174032224.png" alt="image-20221206174032224"></p>
<p>如上图所示，如果我从合约A中delegatecall(委托调用)合约B中的函数，我将在合约A中执行合约B的逻辑</p>
<p><img src="img/image-20221206175209834.png" alt="image-20221206175209834"></p>
<p>上图的示例中我们与fallback函数相结合，使我们能够通过代理合约将所有调用委托给其他合约。</p>
<p><img src="img/image-20221206175632956.png" alt="image-20221206175632956"></p>
<p>这意味着我们可以拥有一个永远具有相同地址的代理合约，我可以指点和引导人们到正确的有逻辑的实现合约中，每当我想更新的时候，我就部署一个新的实现合约并将我的代理指向那个新的实现。现在每当用户调用代理合约上的函数时，我将把它委托给新合约，我只能调用我的代理合约上面的管理员专用合约。</p>
<p><img src="img/image-20221206180003029.png" alt="image-20221206180003029"></p>
<p>当我们谈论代理时，我们要记住四个术语</p>
<p>1.The Implementation Contract(实现合约)</p>
<p>——其中包含我们协议的所有代码。当我们升级时，我们启动一个全新的实现合约。</p>
<p>2.The Proxy Contract(代理合约)</p>
<p>——代理指向哪个实现是正确的并发送每个人的调用到正确的执行合约，我们可以认为代理合约位于实现合约之上。</p>
<p>3.The user(用户)</p>
<p>——用户将通过代理合约进行合约函数调用。</p>
<p>4.The admin(管理员)</p>
<p>——管理员将决定何时升级以及指向哪个合约。</p>
<p>关于proxy和delegate call的另一个很酷的事情是我们所有的存储变量都将被存储在代理合约中，而不是实现合约中，这样每当我升级到新的逻辑合约时，我所有的数据都将保留在代理合约中，所以每当我想更新我的逻辑时，只需指向一个新的实现合约，如果我想添加一个新的存储变量，则直接添加到我们的逻辑合约中，代理合约会取走它的。</p>
<p>但是使用代理有几个陷阱(Gotchas),这也就是使用代理来更新合约不被大家推荐的原因了，因为代理这种方法充满了很多潜在的问题，最大的两个问题是1.存储冲突2.函数选择器冲突。</p>
<p><img src="img/image-20221206204100534.png" alt="image-20221206204100534"></p>
<p>当我们使用delegateCall时，请记住我们在合约A中执行合约B的逻辑，因此如果合约B表示我们需要将值设置为2，我们将继续并将值设置成2。我们实际上设置了合约A中与合约B相同存储位置的任何变量的值,因此，如果我们的合约A看起来像下面这样，并且合同A中有两个变量，我们仍然会将合同A中的第一个存储变量设置为新值。</p>
<p><img src="img/image-20221206215050038.png" alt="image-20221206215050038"></p>
<p>因为这意味着我们只能在新的实现合约中添加新的存储变量，而不能重新排序或更改旧的存储变量，这被称为存储冲突。</p>
<p><img src="img/image-20221206215239709.png" alt="image-20221206215239709"></p>
<p><strong>函数选择器:定义函数的函数名称和函数签名的 4 字节哈希</strong></p>
<p>下一个被称为函数选择器冲突，当我们告诉代理(proxies)将调用委托(delegate call)给这些实现之一时。它使用所谓的函数选择器来查找函数。</p>
<p>现在有可能实现合约中的函数与代理合约中的管理函数具有相同的函数选择器，这可能导致我们不小心做了一大堆奇怪的事。</p>
<p><img src="img/image-20221206222431554.png" alt="image-20221206222431554"></p>
<p>例如上图中的示例代码，即使这些函数完全不同，但是他们实际上有相同的函数选择器，这就会导致一个问题，一些无害的函数例如getPrice()具有与升级代理或销毁代理相同的函数选择器，这就引出了<strong>透明代理模式(Transparent Proxy Pattern)</strong>,在这个方法中管理员只能调用管理函数,他们不能调用实现合约中的任何函数，用户只能调用实现合中的函数，这样我们就永远不会出现函数选择器冲突。</p>
<p>第二种我们要介绍的代理模式是<strong>通用可升级代理模式</strong>(Universal Upgradeable Proxies),这个版本的可升级合约把升级的所有逻辑都放到了实现合约里面而是代理合约里。</p>
<p><img src="img/image-20221206223507285.png" alt="image-20221206223507285"></p>
<p>在通用可升级代理模式下，Solidity编译器实际上会弹出错误并告诉我们这里有两个具有相同函数选择器的函数，这也是有利的，因为我们少了一个我们必须做的读函数操作，我们不需要再检查代理合约中是否有人是管理员，同时可以节省汽油费，但问题是如果我们部署一个没有任何可升级函数的实现合约，这种方法无法进行。</p>
<p>第三种我们要介绍的代理模式是<strong>diamond模式</strong>,这种模式实际上允许多个实现合约，如果我们的合约过大的话，我们可以通过这种多重实现的方式拥有多个合约，它还允许我们进行更精细的升级，也就是说我们不必部署升级我们的整个智能合约，我们可以只升级它的一小部分。</p>
<p><img src="img/image-20221206224037787.png" alt="image-20221206224037787"></p>
<p>上面提到的所有代理模式都有专属于它们自己的以太坊改进建议(EIP),而且大部分都在草稿阶段(例如Diamond就是EIP2535).</p>
<h3 id="delegatecall">Delegatecall</h3>
<p>现在我们要学习如何构建这些可升级的智能合约。</p>
<p>首先我们需要了解一下这个Delegatecall(委托调用)函数,它和我们之前学过的call(调用)函数非常相似。</p>
<p>每当我们与存储变量有某种类型的合约时，它们就会存储在存储数据结构中，并且索引从0开始。</p>
<pre><code>//SPDX-License-Identifier:MIT
pragma solidity ^0.8.7;

// 为了仅使用 call 的数据字段来调用函数，我们需要编码：1.函数名称;2.我们想要添加的参数;
// 将以上编码为二进制级别,以便EVM或者这些基于以太坊的Solidity智能合约可以理解实际发生的事情

// 现在，每个合约为每个函数分配一个函数ID.这被称为“函数选择器”.
// “函数选择器”是函数签名编码的前 4 个字节.
// “函数签名”是定义函数名称和参数的字符串.

contract CaLLAnything{
    address public s_someAddress;//合约地址
    uint256 public s_amount;//传送金额

    //函数签名示例
    function transfer(address someAddress,uint256 amount) public {
        s_someAddress = someAddress;
        s_amount = amount;
    }

    //函数选择器示例1
    function getSelectorOne() public pure returns(bytes4 selector){
        selector = bytes4(keccak256(bytes(&quot;transfer(address,uint256)&quot;)));//以太坊使用的是keccak256算法
    }

    //我们需要将所有数据放入交易的data字段中，以发送给该合约，让该合约知道“使用transefer函数，传入一些地址，然后传入一个金额”
    function getDataToCallTransfer(address someAddress,uint256 amount) public pure returns(bytes memory){
        return abi.encodeWithSelector(getSelectorOne(),someAddress,amount);
    }

    //上述都是为了使用call来调用函数而提前做的准备,“函数选择器”是函数签名编码的前 4 个字节所以这里只返回前四个byte
    //这个函数会让我们通过传递这些参数来直接调用transfer函数,我们只需更改调用的地址就可以跨多个合约执行此操作(不需要继承合约也可以调用其他合约里的函数)
    function callTransferFunctionDirectly(address someAddress,uint256 amount) public returns(bytes4,bool){
        (bool success,bytes memory returnData) = address(this).call(
            //getDataToCallTransfer(someAddress,amount) 这一行代码和下面这行的作用一样
            abi.encodeWithSelector(getSelectorOne(),someAddress,amount)
        );
        return(bytes4(returnData),success);
    }
    //我们也可以使用签名进行编码调用而不是选择器
    function callTransferFunctionDirectlySig(address someAddress,uint256 amount) public returns(bytes4,bool){
        (bool success,bytes memory returnData) = address(this).call(
                          abi.encodeWithSignature(&quot;transfer(address,uint256)&quot;,someAddress,amount)
        );
        return(bytes4(returnData),success);
    }
}
</code></pre><p><strong>DelegateCallExample.sol</strong></p>
<p><img src="img/image-20221207094305773.png" alt="image-20221207094305773"></p>
<p>当我们部署合约A之后，合约A委托调用(delegatecall)合约B中的setVars函数，并在合约A中运行它，我们几乎可以把它想象成我们将合约B中的setVars函数复制之后并粘贴它进入我们的合约A，只运行一次后然后立即再次删除。(这就是这个委托调用函数的作用)</p>
<h3 id="small-proxy-example">Small Proxy Example</h3>
<p>一个最小的代理示例，可以展示出合约如何做到地址不改变的前提下同时改变底层代码。</p>
<p>Yul（以前也称为JULIA或IULIA）是一种中间语言，可以编译成字节码用于不同的后端。(Yul发挥了什么作用,assemly又发挥了什么作用?)</p>
<pre><code>assembly就是来自Yul的内联汇编代码
</code></pre><p>EIP-1967:Standard Proxy Storage Slots(标准代理存储槽)</p>
<pre><code>// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;

import &quot;@openzeppelin/contracts/proxy/Proxy.sol&quot;;

//我们的代理的工作方式是调用此代理合约的任何合约
contract SmallProxy is Proxy {
    // 这是“eip1967.proxy.implementation”的 keccak-256 哈希值减去 1
    bytes32 private constant _IMPLEMENTATION_SLOT =
        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    function setImplementation(address newImplementation) public {
        assembly {
            sstore(_IMPLEMENTATION_SLOT, newImplementation)
        }
    }

    function _implementation() internal view override returns (address implementationAddress) {
        assembly {
            implementationAddress := sload(_IMPLEMENTATION_SLOT)
        }
    }

    //辅助函数
    //获取调用SmallProxy的数据
    function getDataToTransact(uint256 numberToUpdate) public pure returns (bytes memory) {
        return abi.encodeWithSignature(&quot;setValue(uint256)&quot;, numberToUpdate);
    }

    //读取我们在SmallProxy中的存储
    function readStorage() public view returns (uint256 valueAtStorageSlotZero) {
        assembly {
            valueAtStorageSlotZero := sload(0)
        }//调用sload操作码以读取存储槽0处的值
    }
}

//现在如果有人调用SmallProxy合约,它将被委托调用到到我们的实现A/实现B,然后将存储保存在我们的SmallProxy地址中

contract ImplementationA {
    uint256 public value;

    function setValue(uint256 newValue) public {
        value = newValue;
    }
}

contract ImplementationB {
    uint256 public value;

    function setValue(uint256 newValue) public {
        value = newValue + 2;
    }
}

// function setImplementation(){}
// 透明代理 -&gt; OK，只有管理员可以调用代理上的函数
// 其他人总是被发送到fallback合约.

//UUPS -&gt; 所有升级逻辑都在实现合约中，您不能有 2 个具有相同函数选择器的函数。
</code></pre><h3 id="-">透明可升级代理合约</h3>
<p><strong>本小节具体内容请查看hardhat-upgrades-fcc文件夹</strong></p>
<p><img src="img/image-20221207231250834.png" alt="image-20221207231250834"></p>
<p>第一次部署Box合约的时候,我们实际上部署了好几个合约,我们部署了我们的BoxProxyAdmin(这将是我们的管理合约)，然后我们部署Box_Implementation(将Box合约重命名为Box_Implementation)，最后部署了我们的Box_Proxy(任何时候我们调用这个合约的地址，它实际上会指向我们的Box的逻辑)</p>
<p><strong>手动升级我们的合约</strong></p>
<p><img src="img/image-20221207235219193.png" alt="image-20221207235219193"></p>
<pre><code>//手动升级
//我们要进行手动升级的原因是我们想准确展示在升级过程中我们所调用的函数
//然而hardhat-deploy也带有一个API,使得升级我们的Box合约变得非常容易

const { ethers } = require(&quot;hardhat&quot;)

async function main() {
    const boxProxyAdmin = await ethers.getContract(&quot;BoxProxyAdmin&quot;)
    const transparentProxy = await ethers.getContract(&quot;Box_Proxy&quot;) //透明代理(这是刚刚部署过的合约)

    const proxyBoxV1 = await ethers.getContractAt(&quot;Box&quot;, transparentProxy.address)
    const versionV1 = await proxyBoxV1.version()
    console.log(versionV1)

    const boxV2 = await ethers.getContract(&quot;BoxV2&quot;)
    const upgradeTx = await boxProxyAdmin.upgrade(transparentProxy.address, boxV2.address) //发送调用升级函数的交易,将透明代理的对象升级BoxV2
    await upgradeTx.wait(1)

    //现在开始使用boxV2合约上的函数
    const proxyBoxV2 = await ethers.getContractAt(&quot;BoxV2&quot;, transparentProxy.address) //我们得到BoxV2的abi,然后在透明代理地址加载它
    //我们可以在透明代理地址上调用所有的函数
    const versionV2 = await proxyBoxV2.version()
    console.log(versionV2)
}

main()
    .then(() =&gt; process.exit(0))
    .catch((error) =&gt; {
        console.error(error)
        process.exit(1)
    })

</code></pre><p>使用此代码就可以用编程的方式升级我们的合约。</p>
<h2 id="17-hardhat-dao">17.使用Hardhat开发DAO</h2>
<h3 id="-dao-">什么是DAO？</h3>
<p>DAOs或者去中心化的自治组织:<strong>受区块链或智能合约上的一组透明规则管辖的任何团体</strong></p>
<p>这组透明规则是不可变的(Immutable)，透明的(Transparent)，去中心化的(Decentralized)，这样的规则解决了信任问题，赋予不同协议和应用的用户们权力，而不是闭门造车，投票机制是运作这个组织的基石。</p>
<p><strong>这种去中心化的治理(DeGov)可以概括为仅通过代码进行运转的公司或组织。</strong></p>
<p><img src="img/image-20221208133442198.png" alt="image-20221208133442198"></p>
<p>Compound协议,这是一个借贷应用程序，允许用户借贷他们的资产，而且这个应用程序的所有内容都内置在智能合约中。</p>
<p>在这个协议的治理页面(Governance)可以获取所有提案和所有不同选票列表的用户界面，这里列出了该协议实际上一直在改进的一些治理建议。</p>
<p>让我们点击其中的一项建议，我们可以看到关于这个协议的一切，For后面跟的是赞成票，Against后面跟的是反对票，下方还有提案历史(Proposal Hsitory).</p>
<p><img src="img/image-20221208133530921.png" alt="image-20221208133530921"></p>
<p><img src="img/image-20221208135134935.png" alt="image-20221208135134935"></p>
<p>上图是提案历史,第一项就是在拟议的交易中实际创建提案(Created)，提案在短暂的延迟后被创建，然后它就变得活跃起来(Active)，这时候人们真正开始对它们投票，如果该提案通过了投票，然后它就成功了(Succeeded)，这时候我们前往区块链浏览器上面就可以发现人们投票要求的确切功能(函数)，成功后它进入了排队阶段(Queued)，这是提案成功(Succeeded)与提案执行(Executed)之间的延迟阶段。</p>
<p>这就是一个提案的完整生命周期，当反对票&gt;赞同票的时候我们提案就会在活跃(Active)阶段后转向失败(Failed)。</p>
<p>仅仅通过一项提案还不足以真正获得一些选票，我们通常需要一个论坛或某种类型的讨论场所，来讨论这些提案以及我们喜欢它们/不喜欢它们的原因。</p>
<p>SnapShot整合了这些DAO的社区，我们可以加入其中任意一个然后我们的代币实际上可以进行投票而无需执行提案，也就是说SnapShot可以帮助我们完成投票过程。</p>
<p><img src="img/image-20221208141727748.png" alt="image-20221208141727748"></p>
<p><strong>在上面我们了解了什么是DAO，现在让我们讨论如何构建一个DAO的体系结构和要用到的工具以及它们所拥有的权力。</strong></p>
<p><strong>首先要讨论的就是投票机制(Voting Mechanism)</strong></p>
<p>投票和去中心化治理对于这些DAOs来说至关重要，因为有时候它们确实需要更新和更改以与时俱进，并非所有协议都需要有DAO，对于社区成员来说投票是最重要的事情，现在一般来说解决投票的问题是使用ERC20代币或NFT代币作为投票权类似于我们在compound中看到的那样使用comp代币为不同的提案投票，这种方法在有些情况下是正确的，但是对于某些DAO来说它也存在着不公平的风险，因为当我们将投票权代币化后，我们实际上是在将这种投票权拍卖给财力最雄厚的人，谁拥有最多的钱谁就可以选择投票权的改变，这并不是我们想要看到的，但是这种方法的正确与否取决于我们的DAO社区，社区外的人无权过问。</p>
<p><strong>接下来我们要讨论的就是游戏中的皮肤(Skin In The Game)</strong>，Skin In The Game这种方法意味着每当我们做出决定，我们的投票就已记录，如果这个决定导致不好的结果，我们的代币将被砍掉，也就是说我们会因为我们恶意或错误的决定而受到惩罚，从这里引申出的另一个问题是，我们作为一个社区如何决定什么是一个糟糕的结果，我们实际上如何惩罚这些人。</p>
<p><strong>然后我们要讨论的第三种方法是投票机制中最有趣也是最难实施的方法</strong>，也就是Proof of Personhood or Participation(人格或参与的证明)，例如compound协议中的用户即使有1000个钱包使用了这个协议，但是一个用户永远只能有一票，这是更公平的方法(不能购买额外的选票了)，但是这种方法的问题出现在了Sybil resistance(女巫抵抗)，我们如何确定一张选票等于一个参与者，而不是一个参与者假装成成千上万的人，以便他们获得更多选票，这种方法尚未真正解决这种问题，Chainlink集成有可能可以解决这个问题，因为Proof of Personhood基本上只是链下数据可以交付到链上，这正是Chainlink发挥作用的地方。</p>
<p>总的来说，所有的方法都和我们的日常生活息息相关。</p>
<p>投票机制其实可以分为两类，On Chain Voting(链上投票)和Off Chain Voting(链下投票)，我们在Compound中看到的就是<strong>链上投票</strong>,链上有智能合约 ，我们是选民，我们调用一些名为vote的函数，使用我们的Metamask发送交易，然后就投票成功了，但是链上的投票需要花费Gas费，假设社区有10000人，每人每次投票都要花费100美金，每次改进都要花掉整个社区100万美金，这显然是不可持续的，链上投票的优点是架构很简单，一切都会变得透明，一切都会上链。现在有了一种解决高昂Gas费的方法Governor C，他们使用一些随机抽样进行二次投票，以帮助降低成本，同时增加女巫抵抗力。 </p>
<p>我们可以进行<strong>链下投票</strong>，并保持100%去中心化。我们实际上可以在不实际发送到区块链的情况下签署交易以签署投票，因此无需实际花费任何 gas，但是我们需要把该签名交易发送到去中心化数据库(例如IPFS)，然后在IPFS中计算所有选票，到时候通过诸如 Chainlink 之类的预言机将数据的结果在一次交易中全部传递到区块链上；除了这种方法外我们还可以在单笔交易之中重放其他所有附加交易以节省Gas费，这样可以把投票花费减少99%。;另外最流行的方法是通过Snapshot。链下投票方式节省了社区内的很多Gas费，但是我们需要注意的一点是如果我们使用一个中心化的预言机运行我们的DAO，这相当于是破坏了我们应用程序的中心化。</p>
<p>现在有很多应用可以无代码构建DAOs,例如Colony，DAO house这些都是可以实际帮助我们运行DAO和构建的客户端的替代方案。但是如果我们想要更精细的控制并且我们不想支付与这些协议相关的任何费用，我们可以从头开始做更复杂的，<strong>SnapShot</strong>的解决方案是目前最流行的工具之一，既可以获取DAO的提案，又可以实际执行该提案，用户可以使用他们的真实代币通过该协议进行投票，这些交易存储在IPFS中，但是这些投票都不会被执行除非DAO选择执行。</p>
<p><strong>架构DAO所要用到的所有工具</strong></p>
<p><strong>Zodiac</strong>是一套基于DAO的工具，因为我们也可以在我们的DAO中使用；<strong>Tail</strong>是这些UI中的另一个，它允许人们通过用户界面查看并实际投票，并与这些智能合约交互。<strong>Gnosisi Safe</strong>是一个多重签名钱包，尽管这个工具添加了中心化的组件，但任何协议一开始都是会从某种类型的中心化开始，当我们没有成千上万的人等待投票时，无论如何使用多重签名，投票仅通过少数关键成员进行，但是我们仍要记住的一点是只要我们使用了一个中心化工具，我们就是在DAO中增加中心化的权力，。<strong>Openzeppelin</strong>是我们最常用也是最好用的库。</p>
<p><strong>合法性(Legality)</strong></p>
<p>DAO的未来很有趣，因为DAO采用了和政府相似的公投来决定每一项提案，这会让政府觉得不安，很难认定一个DAO的具体负责人，但是我们实际上可以形成自己的意识不去做越界的事(怀俄明州已经认定DAO是合法的了)</p>
<h3 id="-dao">怎样开发一个DAO</h3>
<p>我们将模拟Compound开发我们自己的DAO，这将是100%的链上投票和链上治理，我们将向学到使用Ssolidity和Hardhat启动 NFT 或 ERC20 投票类型 DAO 的最简单方法。我们将使用Openzeppelin合约和Hardhat框架来构建它。</p>
<p><strong>首先运行命令检查我们各类工具的版本.</strong></p>
<p><img src="img/image-20221209102759467.png" alt="image-20221209102759467"></p>
<p>然后运行yarn add --dev <a href="mailto:hardhat@2.8.4">hardhat@2.8.4</a>安装hardhat，</p>
<p>然后运行yarn hardhat选择创建空的harhatconfig.js</p>
<p>然后在创建完合约后导入openzeppelin合约的库</p>
<pre><code>yarn add --dev @openzeppelin/contracts
</code></pre><p>Box.sol创建编译好后我们就要开始创建治理代币(GovernanceToken)合约,我们将按照ERC20的标准构建这个Governance平台,因此我们将获得ERC20代币，这将是我们用来投票的代币。</p>
<p>治理代币(GovernanceToken)合约创建编译好后我们将创建一个名为governance_standard的文件夹,因为这将是标准的治理模式,这将是链上ERC20。在此文件夹下创建两个合约。</p>
<p><img src="img/image-20221209194906109.png" alt="image-20221209194906109"></p>
<p>Voting Delay(投票延迟):这是自提案创建以来直到投票开始的延迟。(基于区块)</p>
<p>Voting Period(投票期限):投票应该持续多长时间。(基于时间)基于时间比基于区块要好得多。</p>
<p>1 block = 12 secodes(以区块为单位的投票延迟)。</p>
<p>Proposal Threshold(提案门槛):这将是一个账户创建提案所需的最低票数。</p>
<p>Quorum(核心百分比):指的是DAO中投票的人所占的百分比。</p>
<p><strong>在写好GovernorContract.sol之后我们就开始编写TimeLock.sol合约</strong></p>
<p>记得Openzeppelin进行了更新,现在我们必须传入四个参数才可以使用TimelockController合约了。</p>
<p>写完后我们就获得了开发一个DAO所需要的最基础的代码。</p>
<p>结下来我们要编写脚本文件部署合约并与之交互(使用typescript)</p>
<p>运行下面这条命令,使用hardhat-ethers来覆盖原来的hardhat-deploy-ethers,并添加ethers.js</p>
<pre><code>yarn add --dev @nomicliabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers
</code></pre><p>然后添加hardhat-deploy依赖</p>
<pre><code>yarn add --dev hardhat-deploy
</code></pre><p>然后创建deploy文件夹,将我们的部署脚本建立在这里。</p>
<p>然后由于我们要使用typescript,我们要运行下面这条命令安装typescript所需要的所有依赖</p>
<pre><code>yarn add --dev typescript typechain ts -node @typechain/ethers-v5 @typechain/hardhat @types/chai @types/node 
</code></pre><p>安装好后就前去编写我们的第一个typescript部署脚本文件</p>
<p><strong>01-deploy-governor-token.ts</strong></p>
<pre><code>import { HardhatRuntimeEnvironment } from &quot;hardhat/types&quot;; //导入types类型下hardhat的运行环境
import { DeployFunction } from &quot;hardhat-deploy/dist/types&quot;;//导入部署函数
import { ethers } from &quot;hardhat&quot;;

//创建我们的部署函数
const deployGovernanceToken:DeployFunction = async function (hre:HardhatRuntimeEnvironment) {
    const {getNamedAccounts,deployments,network} = hre;         //需要账户来部署合约
    const {deploy,log} = deployments; //deploy函数和log函数,log函数很适合做日志记录
    const {deployer} = await getNamedAccounts();//getNamedAccounts从我们的hardhatconfig中导入账户
    log(&quot;Deploying Governance Token...&quot;);
    //部署GovernanceToken合约  
    const governanceToken = await deploy(&quot;GovernanceToken&quot;,{
        from:deployer,
        args:[],
        log:true,
        // waitConfirmations:
    })
    // verify
    log(`Deployed governance token to address ${governanceToken.address}`)

    await delegate(governanceToken.address,deployer)//进行委托调用
    log(&quot;Delegated!&quot;)
};

//创建我们的委托函数,因为当我们实际部署这个合约时,还没有人拥有投票权,原因是因为没有人委托给他们代币
//所以我们想把代币委托给我们的部署者

const delegate  = async (governanceTokenAddress:string,delegatedAccount:string) =&gt; {
    const governanceToken = await ethers.getContractAt(&quot;GovernanceToken&quot;,governanceTokenAddress);//获得GovernanceToken合约对象
    const tx = await governanceToken.delegate(delegatedAccount);//发送委托调用的交易
    await tx.wait(1);
    console.log(`Checkpoints ${await governanceToken.numCheckpoints(delegatedAccount)}`);//numCheckpoints函数可以让我们查看该账户实际上有多少Checkpoints,因为人们都是基于Checkpoints来进行投票的
    //任何时候我们转移代币或者委托代币都是调用moveVotingPower函数(从这个函数里可以得知Checkpoints相当于每个人的投票权 every block = every checkpoints)

}

export default deployGovernanceToken;
</code></pre><p>在我们部署了我们的治理代币合约后,我们就要开始部署Timelock合约</p>
<p>如果部署代码出现未知错误的话,可以添加// @ts-ignore这行代码来纠错。</p>
<p>如果部署合约时需要参数的话记得创建helper-hardhat-config.ts这个自定义配置文件</p>
<p>在部署完2-deploy-time-lock.ts后我们就要开始部署GovernorContract合约文件</p>
<pre><code>// import { HardhatRuntimeEnvironment } from &quot;hardhat/types&quot;; //导入types类型下hardhat的运行环境
// import { DeployFunction } from &quot;hardhat-deploy/dist/types&quot;;//导入部署函数
// import { VOTING_DELAY,VOTING_PERIOD,QUORUM_PERCENTAGE } from &quot;../helper-hardhat-config&quot;;

// const deployGovernorContract:DeployFunction = async function(hre:HardhatRuntimeEnvironment){
//     const {getNamedAccounts,deployments} = hre;         //需要账户来部署合约
//     const {deploy,log,get} = deployments; //deploy函数和log函数,log函数很适合做日志记录
//     const {deployer} = await getNamedAccounts();//getNamedAccounts从我们的hardhatconfig中导入账户
//     const governanceToken = await get(&quot;GovernanceToken&quot;);//获得GovernanceToken合约对象
//     const timeLock = await get(&quot;TimeLock&quot;);//获得TimeLock合约对象
//     //需要这两个合约的参数传递到我们的GovernorContract构造函数中去
//     log(&quot;Deploying governor&quot;);
//     const governorContract = await deploy(&quot;GovernorContract&quot;,{
//         from:deployer,
//         args:[
//             governanceToken.address,//治理代币
//             timeLock.address,//时间锁对象
//             VOTING_DELAY,//投票延迟
//             VOTING_PERIOD,//投票期限
//             QUORUM_PERCENTAGE//核心百分比
//         ],
//         log:true,
//     });
// };

// export default deployGovernorContract;
</code></pre><p>然后我们开始编写合约交互的脚本:setup治理合约。</p>
<p>最后部署我们的Box合约,也就是我们的提案。</p>
<p>我们部署了GovernorToken,TimeLock(它拥有Governance Process),GovernonContract,建立了GovernanceProcess以便完全去中心化,部署并建立了我们的Box,可以通过Governance Process进行更新。(由于TimeLock合约中的admin,导致GovernonContract合约无法部署成功,也就导致了后续的合约无法部署成功,同时本地节点无法正常运行。)</p>
<p>接下来我们就要编写我们的交互脚本(在DAO中提议并投票,在前端交互中可以发挥显著作用,也可以使用Snapshot进行集成),我们可以准确看到Governance Process的样子。</p>
<p>首先创建propose.ts(提案脚本)，vote.ts(投票脚本)，queue-and-execute.ts(排队和执行脚本)</p>
<p><img src="img/image-20221212134138792.png" alt="image-20221212134138792"></p>
<p>创建完propose.ts之后就创建一个proposal.json存储我们所有的提案,阅读文件需要用到fs指令,运行下面这条命令获得fs指令的依赖</p>
<pre><code>yarn add fs
</code></pre><p>然后开始编写我们的vote.ts文件</p>
<p>编写后就开始编写我们的queue-and-execute.ts文件</p>
<p><img src="img/image-20221212222120607.png" alt="image-20221212222120607"></p>
<p>至此我们就完成了这个DAO,完全去中心化的链上投票。</p>
<h2 id="18-">18.安全&amp;审计</h2>
<p>在这个部分中我们会学到不同的安全功能,例如Reentrance,Oracle tax以及一些可以使得我们的代码更高效,更安全的工具.</p>
<p><strong>什么是Aduit(审计)?</strong></p>
<p>审计是一种以安全为中心的代码审查，用于查找代码问题。我们希望审计员可以审计我们的代码确保一切无误。审计员在审查代码前需要知道我们的代码是做什么的,如何使用它以及我们的目的，审计员也是人，他们也会错过一些东西，他们也不能确保我们的代码没有错误，审计以安全为中心对我们的代码库进行评审，当我们把代码发送给审计时，我们需要确保我们可以尽可能地帮助审计员。</p>
<p>也就是说在编写好的代码时，在将代码发送给审核之前，我们需要100%遵循这些。</p>
<ul>
<li>添加注释<ul>
<li>这将帮助您的审计员了解您在做什么。</li>
</ul>
</li>
<li>使用natspec<ul>
<li>记录我们的函数</li>
</ul>
</li>
<li>测试<ul>
<li>如果你没有测试，测试覆盖你所有的函数和代码行，你不应该去审计。如果您的测试没有通过，请不要去审计。</li>
</ul>
</li>
<li>准备好与审计员交谈<ul>
<li>沟通越多越好</li>
</ul>
</li>
<li>准备好给审计员足够的时间<ul>
<li>他们一定会在你的代码上用心的</li>
</ul>
</li>
</ul>
<p><strong>审计过程是什么样的?</strong></p>
<ul>
<li>运行测试</li>
<li>阅读natspec/文档</li>
<li>运行快速工具（如 slither、linters、static analysis等）<ul>
<li>static analysisi是运行一些程序来读取代码并寻找常见错误的过程,slither是最受欢迎的static analysisi工具</li>
</ul>
</li>
<li>手动分析</li>
<li><p>运行缓慢的工具（如 echidna、manticore、symbolic execution、MythX）</p>
<ul>
<li>symbolic execution是指我们在区块链上模拟执行交易，并且Echidna是最有代表性的symbolic execution工具</li>
<li>manticore也是来自Trail of Bits团队的工具，MythX实际上是来自ConsenSys团队的智能合约安全服务(团队口号是确保开发团队避免代价高昂的错误，并使以太坊成为一个更安全、更值得信赖的平台，这是一个付费服务专为大项目而生。)</li>
</ul>
</li>
<li><p>讨论（并根据需要重复步骤）</p>
<ul>
<li>与其他的智能合约开发者一起讨论</li>
</ul>
</li>
<li><p>撰写报告（示例报告）</p>
<ul>
<li>最后审计员会给我们一份报告,里面是我们所有的安全漏洞.</li>
</ul>
</li>
</ul>
<p>通常，审计员在图表中组织报告，如下所示：</p>
<p><img src="img/image-20221213103639733.png" alt="image-20221213103639733"></p>
<p>创建我们的项目文件夹,并复制Github上的代码</p>
<pre><code>git clone https://github.com/PatrickAlphaC/hardhat-security-fcc .
</code></pre><h3 id="slither">Slither</h3>
<p>我们要在Github上复制的代码里运行slither这个工具来看一看static analysis的效果</p>
<p>Slither这个工具是由Crytic团队创建的,Crytic团队又名比特线索(Trail of Bits)团队,这个团队是Web3领域很出名的审计员团队,他们推出了很多开源安全工具。</p>
<p>为了使用Slither我们首先要安装Python，然后使用pip3来安装solc-select以防我们使用奇怪的solidity版本</p>
<pre><code>pip3 install solc-select
</code></pre><p>然后运行下面这条命令选择一个版本的solidity</p>
<pre><code>solc-select use 0.8.7
</code></pre><p>然后运行下面这条命令安装slither-analyzer</p>
<pre><code>pip3 install slither-analyzer
</code></pre><p>然后运行yarn安装我们项目的所有依赖项</p>
<p>下面通过slither来运行我们的整个合约文件夹</p>
<p><img src="img/image-20221213141703548.png" alt="image-20221213141703548"></p>
<p>我们会看到红色和绿色,红色是指它发现的合约中急需解决的安全问题，以及这个问题可以参考的Github仓库(我们可以从参考仓库中看到问题是什么以及如何纠正的信息)。</p>
<p>绿色是影响较小的安全问题(可以看作是警告)</p>
<p>0.8.4-0.8.7版本的Solidity被认为是更稳定的Solidity版本</p>
<p>但是在我们的了解中,我们的5个合约都存在着很严重的安全问题，但是static analysis只分析出了两个错误，还有三个没有分析出来。这就是为什么我们不能仅仅依靠Slither，因为它没办法发现所有的错误，但它会捕获很多重大漏洞。</p>
<h3 id="fuzzing-eth-security-toolbox">Fuzzing 和eth-security-toolbox</h3>
<p>在我们使用了快速工具后我们进入手动分析阶段，我们遍历代码然后手动纠错。</p>
<p>Echidna：一种快速的智能合约模糊器(A Fast Smart Contract Fuzzer)</p>
<p><strong>模糊测试</strong>（fuzz testing, fuzzing）是一种软件测试技术。其核心思想是将自动或半自动生成的随机数据输入到一个计算机程序中，并监视程式异常，如崩溃，断言（assertion）失败，以发现可能的程序错误，比如记忆体流失。模糊测试常常用于检测软件或电脑系统的安全漏洞。</p>
<p>在我们的很多代码中，在我们的很多代码中，我们经常会让人们以我们永远不会想到的方式与代码互动，所以我们希望能够提供我们测试的随机数据和随机信息来看一看是否发生了我们没想到的奇怪事情。</p>
<p>所以我们实际上可以构建我们自己的模糊测试(fuzz test)，在我们的hardhat项目中运行这些模糊测试(fuzz test)。</p>
<p>我们用Solidity编写我们的模糊测试，实际上与用JavaScript编写测试相反。</p>
<p>我们需要导入这个包</p>
<p><img src="img/image-20221213160123030.png" alt="image-20221213160123030"></p>
<p>所有安全工具都在这个包中，例如Echidna,Etheno,Slither等，这个包堪称是以太坊安全工具箱，为了能够和这个工具箱一起工作我们需要安装docker。</p>
<p>在下载好docker并运行后我们只需要运行yarn toolbox这个命令就可以运行docker命令了(在package.json中已经设置好了命令)，因为docker在这个课程中一闪即过,所以暂时并不会详细讲解。</p>
<p>先切换到WSL2</p>
<p><img src="img/image-20221213205108769.png" alt="image-20221213205108769"></p>
<p>我们需要启动Docker引擎，并让它真正开始工作，在Docker里面有很多配置</p>
<p>但是Chainlink视频里并没有说Docker是如何配置的所以说暂时搁置。</p>
<p>如果配置好Docker的话可以输入以下命令在模糊测试合约中运行Echidna这个智能合约模糊器</p>
<pre><code>echidna-test /src/contracts/test/fuzzing/ValutFuzzTest.sol --contract VaultFuzzTest --config /src/contracts/test/fuzzing/config.yaml
</code></pre><p>我们通过视频可以知道Echidna在很快的时间内就从一大堆随机数中试出了保险库合约的密码</p>
<p><img src="img/image-20221213212410372.png" alt="image-20221213212410372"></p>
<h3 id="-">结束前的一些想法</h3>
<p>通过OpenZeppelin,sigmaprime和Trail of Bits可以看到很多完整的审计示例，同时这也是Web3领域最强大的三个审计员团队</p>
<p>如果想要更深入地了解合约安全和审计的话可以去玩Github上推荐的这两个游戏</p>
<p><img src="img/image-20221213223724115.png" alt="image-20221213223724115"></p>
<p>然后就是一些以合约安全为重点的博客</p>
<p><img src="img/image-20221213223819803.png" alt="image-20221213223819803"></p>
<p><strong>合约安全和审计是每一个智能合约工程师职业生涯耗时最长也是最重要的一部分。</strong></p>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>